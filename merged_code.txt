================================================================================
### 文件路径: src/App.css
================================================================================

/*// FILE: src/App.css*/
:root {
  --highlight-color: #c0392b;
  --highlight-bg: rgba(192, 57, 43, 0.08);
  --border-color: #dcdfe6;
  --bg-color: #f5f7fa;
  --text-color: #303133;
  --arrow-color: #888;
  --component-bg: #ffffff;
  --component-header-bg: #f8f9fa;
  --residual-bg: #f0f4c3;
  --residual-border: #dce775;

  /* Highlighting */
  --highlight-target-bg: rgba(230, 57, 70, 0.15);
  --highlight-target-color: #d63031;
  --highlight-target-border: #e63946;
  --highlight-source-bg: rgba(96, 98, 102, 0.1);
  --highlight-source-color: #2f3542;
  --highlight-source-border: #606266;

  --highlight-formula-bg: rgba(252, 163, 17, 0.15);
  --highlight-formula-border: #fca311;
  --highlight-vector-bg: rgba(69, 123, 157, 0.2);
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  background-color: var(--bg-color);
  color: var(--text-color);
  margin: 0;
  font-size: 15px;
}

#root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

h1 {
  text-align: center;
  color: #000;
  margin: 0;
  padding: 20px 0;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
}


/* [NEW] Generic styles for draggable/resizable panels */
.resizable-panel {
    position: absolute;
    background-color: var(--component-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}
.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #eee;
    padding: 8px 15px;
    margin: 0;
    cursor: move;
    background-color: var(--component-header-bg);
    flex-shrink: 0;
}
.panel-title {
    font-weight: bold;
    font-size: 1.1em;
}
.panel-toggle-btn, .tooltip-close-btn, .tooltip-toggle-btn {
    background: none;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
    color: #999;
    padding: 0 5px;
    line-height: 1;
}
.panel-toggle-btn:hover, .tooltip-close-btn:hover, .tooltip-toggle-btn:hover {
    color: #333;
}
.resize-handle {
    position: absolute;
    opacity: 0;
    transition: opacity 0.2s ease;
}
.resizable-panel:hover .resize-handle {
    opacity: 1;
}
.resize-handle.br { right: 0; bottom: 0; width: 15px; height: 15px; cursor: nwse-resize; }
.resize-handle.t { top: 0; left: 5px; right: 5px; height: 5px; cursor: ns-resize; }
.resize-handle.r { top: 5px; right: 0; bottom: 5px; width: 5px; cursor: ew-resize; }
.resize-handle.b { bottom: 0; left: 5px; right: 5px; height: 5px; cursor: ns-resize; }
.resize-handle.l { top: 5px; left: 0; bottom: 5px; width: 5px; cursor: ew-resize; }


/* Specific overrides for Controls Panel */
.controls-panel .panel-header {
    padding: 5px;
}
.controls-panel .panel-toggle-btn {
    width: 40px;
    height: 40px;
    font-size: 20px;
}
.controls-panel.collapsed {
    padding: 0;
    min-width: 50px;
    min-height: 50px;
    width: 50px !important;
    height: 50px !important;
    transition: width 0.3s ease, height 0.3s ease;
}
.controls-panel.collapsed .resize-handle {
    display: none;
}
.controls-container {
    padding: 20px;
    flex-grow: 1;
    overflow-y: auto;
}

/* [REVISED] Specific overrides for Calculation Tooltip */
.calculation-tooltip {
    /* [MODIFIED] max-width is intentionally NOT set to allow the tooltip to become very wide if needed. */
}
.calculation-tooltip .panel-header {
    cursor: move;
}
.calculation-tooltip .panel-header .tooltip-controls {
    display: flex;
    align-items: center;
    gap: 5px;
}
.calculation-tooltip .panel-header .view-toggle-btn {
    font-size: 0.8em;
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    background-color: #f0f0f0;
}
.calculation-tooltip .panel-header .view-toggle-btn:hover {
    background-color: #e0e0e0;
}
.calculation-tooltip.collapsed {
    height: auto !important;
}
.calculation-tooltip.collapsed .tooltip-content-wrapper {
    max-height: 0;
    overflow: hidden;
}
.tooltip-content-wrapper {
    flex-grow: 1;
    min-height: 0;
    overflow-y: auto;
    transition: max-height 0.3s ease-in-out;
    max-height: 1000px;
}
.tooltip-body {
    padding: 15px;
    display: flex;
    flex-direction: column;
    min-height: 100%; /* Ensure it can fill the space */
    box-sizing: border-box;
}
/* [NEW] This is the new container that will hold the visualizer and grow to fill space */
.calculation-content-container {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
.calculation-content-container > div { /* Target the visualizer's root div */
    flex-grow: 1;
    display: flex; /* Ensure visualizer itself can be a flex container */
    flex-direction: column;
}


/* [NEW & REFINED] Styles for upgraded tooltip content (used by InteractiveMatMulVisualizer) */
.tooltip-step-container {
    padding: 10px 0;
    border-bottom: 1px dashed #eee;
}
.tooltip-step-container:last-child {
    border-bottom: none;
}
.tooltip-step-title {
    font-family: sans-serif;
    font-size: 1em;
    font-weight: bold;
    color: #333;
    margin: -10px 0 10px 0;
}
.tooltip-vector-group {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 5px 0;
}
.tooltip-symbol {
    font-family: 'Times New Roman', serif;
    font-weight: bold;
    font-size: 1.2em;
}
.tooltip-vector {
    display: flex;
    gap: 3px;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 4px;
    background-color: #f9f9f9;
    overflow-x: auto;
}
.tooltip-vector.column {
    flex-direction: column;
}
.tooltip-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  transition: all 0.2s ease;
}
.tooltip-element.highlight {
    background-color: var(--highlight-formula-bg);
    border-color: var(--highlight-formula-border);
    transform: scale(1.1);
}
.tooltip-op-symbol {
    font-size: 1.4em; /* [MODIFIED] Reduced size */
    font-weight: bold;
    padding: 0 8px; /* [MODIFIED] Reduced padding */
}
.tooltip-matmul-container {
    display: inline-flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
}
.tooltip-result-line {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1.1em;
}
.tooltip-result {
    padding: 2px 6px;
    border-radius: 4px;
    background-color: var(--highlight-target-bg);
    border: 1px solid var(--highlight-target-border);
    color: var(--highlight-target-color);
    font-weight: bold;
}
.tooltip-calculation-detail {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #eee;
    width: 100%;
}
.tooltip-calc-title {
    font-weight: bold;
    font-size: 0.9em;
    color: #333;
    margin-bottom: 8px;
    font-family: sans-serif;
}
/* [MODIFIED] Revised for flex-wrap to prevent overflow */
.tooltip-calc-equation {
    font-family: monospace;
    font-size: 0.95em;
    color: #555;
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto; /* Fallback for very long single words */
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    row-gap: 5px; /* Space between wrapped lines */
}
.tooltip-calc-equation-multi {
    font-family: monospace;
    font-size: 0.95em;
    color: #555;
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto;
    white-space: pre-wrap;
}
.tooltip-calc-equation > * { /* Add spacing between direct children */
    margin-right: 5px;
}
.tooltip-calc-equation .op {
    color: #c0392b;
    font-weight: bold;
}
.tooltip-calc-equation .result {
    font-weight: bold;
    color: var(--highlight-target-color);
}
.tooltip-calc-term {
    transition: background-color 0.2s ease;
    border-radius: 3px;
    padding: 1px 3px;
    cursor: default;
    white-space: nowrap; /* Prevent individual terms from breaking */
}
.tooltip-calc-term.highlight {
    background-color: var(--highlight-formula-bg);
}
.tooltip-calc-equation-multi {
    display: flex;
    flex-direction: column;
    gap: 5px;
}
/* [NEW] Styles for braced calculation breakdown */
.tooltip-braced-group {
    display: flex;
    align-items: center;
    gap: 5px;
}
.tooltip-curly-brace {
    font-size: 2.5em;
    color: #555;
    font-family: serif;
    align-self: center;
}
.tooltip-calc-terms-wrapper {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    row-gap: 5px;
}
.tooltip-calc-terms-wrapper > * {
    margin-right: 5px;
}

/* [NEW] Generic styles for matrix symbolic display in tooltips */
.matrix-wrapper {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
}
.matrix-wrapper.side-label {
    flex-direction: row;
    gap: 8px;
    align-items: center;
}
.matrix-wrapper .matrix-label-side {
    font-size: 1.1em;
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    border: 1px solid #ced4da;
    line-height: 1;
}

/* [NEW] Split pane separator style */
.split-pane-separator {
    width: 8px;
    background-color: #e4e7ed;
    cursor: col-resize;
    flex-shrink: 0;
    z-index: 10;
    transition: background-color 0.2s ease;
}
.split-pane-separator:hover {
    background-color: #409eff;
}

/*// END OF FILE: src/App.css*/


================================================================================
### 文件路径: src/App.tsx
================================================================================

// FILE: src/App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';
// [FIXED] Corrected import paths based on our new flat 'pages' directory structure
import { HomePage } from './pages/HomePage/HomePage';
import { TopicPage } from './pages/TopicPage/TopicPage';
import './App.css'; // Global styles remain

function App() {
  return (
    <Router>
      <div className="app-container">
        <header className="app-header">
            <h1><Link to="/" style={{ textDecoration: 'none', color: 'inherit' }}>AI 深度探索专题</Link></h1>
        </header>
        <main className="app-main-content">
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/topic/:topicId" element={<TopicPage />} />
          </Routes>
        </main>
      </div>
    </Router>
  );
}

// Add new global styles for the new layout
const globalStyles = `
  .app-header {
    flex-shrink: 0;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--component-bg);
    z-index: 1001; /* Ensure header is on top */
  }
  .app-header h1 {
    padding: 15px 0;
    font-size: 1.8em;
  }
  .app-main-content {
    flex-grow: 1;
    overflow: hidden; /* It should NOT scroll itself */
    min-height: 0; /* Crucial for nested flex scrolling */
    position: relative; /* Needed for absolute positioned children like controls */
  }
  /* This is now a generic container for standard pages that need scrolling */
  .page-scroll-container {
      height: 100%;
      overflow-y: auto;
  }
`;

// Use a more robust way to ensure the stylesheet is added only once.
if (!document.getElementById('app-global-styles')) {
    const styleSheet = document.createElement("style");
    styleSheet.id = 'app-global-styles';
    styleSheet.innerText = globalStyles;
    document.head.appendChild(styleSheet);
}


export default App;

// END OF FILE: src/App.tsx


================================================================================
### 文件路径: src/index.tsx
================================================================================

// FILE: src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Add this empty export statement to treat this file as a module.
export {};
// END OF FILE: src/index.tsx


================================================================================
### 文件路径: src/components/MarkdownRenderer.tsx
================================================================================

// FILE: src/components/MarkdownRenderer.tsx
import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
import 'katex/dist/katex.min.css';

interface MarkdownRendererProps {
  children: string;
}

const MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ children }) => {
  // react-markdown expects children to be a string, not a React node array
  // The content is passed directly as the child of ReactMarkdown
  return (
    <ReactMarkdown
      remarkPlugins={[remarkMath]}
      rehypePlugins={[rehypeKatex]}
    >
      {children}
    </ReactMarkdown>
  );
};

export default MarkdownRenderer;
// END OF FILE: src/components/MarkdownRenderer.tsx


================================================================================
### 文件路径: src/components/visualizers/ActivationFunctionVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/ActivationFunctionVisualizer.tsx
import React, { useState, useMemo } from 'react';
import { Vector, ActivationFunctionType } from './types';
import { formatNumber } from './utils';

interface ActivationFunctionVisualizerProps {
  inputVector: Vector;
  functionType: ActivationFunctionType;
}

export const ActivationFunctionVisualizer: React.FC<ActivationFunctionVisualizerProps> = ({ inputVector, functionType }) => {
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

  const functions = {
    relu: (x: number) => Math.max(0, x),
    gelu: (x: number) => 0.5 * x * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * Math.pow(x, 3)))),
    silu: (x: number) => x / (1 + Math.exp(-x)), // Swish/SiLU
  };

  const outputVector = useMemo(() => inputVector.map(functions[functionType]), [inputVector, functionType]);

  const viewBox = { minX: -5, maxX: 5, minY: -2, maxY: 5 };
  const width = 300;
  const height = 200;

  const toSvgX = (x: number) => (x - viewBox.minX) / (viewBox.maxX - viewBox.minX) * width;
  const toSvgY = (y: number) => height - (y - viewBox.minY) / (viewBox.maxY - viewBox.minY) * height;

  const pathData = useMemo(() => {
    let d = '';
    for (let i = 0; i <= width; i++) {
      const x = viewBox.minX + (i / width) * (viewBox.maxX - viewBox.minX);
      const y = functions[functionType](x);
      const svgX = toSvgX(x);
      const svgY = toSvgY(y);
      if (i === 0) {
        d += `M ${svgX} ${svgY}`;
      } else {
        d += ` L ${svgX} ${svgY}`;
      }
    }
    return d;
  }, [functionType, viewBox, width, height]);

  // Inline Styles
  const styles: { [key: string]: React.CSSProperties } = {
    container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold', textTransform: 'uppercase' },
    mainArea: { display: 'flex', alignItems: 'center', gap: '20px', flexWrap: 'wrap', justifyContent: 'center' },
    vectorGroup: { display: 'flex', flexDirection: 'column', gap: '5px', alignItems: 'center' },
    vectorLabel: { fontWeight: 'bold', color: '#6c757d' },
    vector: { display: 'flex', flexDirection: 'column', gap: '5px' },
    element: { width: '60px', padding: '5px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', cursor: 'pointer' },
    highlight: { transform: 'scale(1.1)', borderColor: '#e63946', backgroundColor: 'rgba(230, 57, 70, 0.1)' },
    chartContainer: { position: 'relative', width: width, height: height, border: '1px solid #ccc', backgroundColor: 'white' },
    svg: { width: '100%', height: '100%' },
    axis: { stroke: '#adb5bd', strokeWidth: 1 },
    gridLine: { stroke: '#e9ecef', strokeWidth: 0.5 },
    path: { fill: 'none', stroke: '#007bff', strokeWidth: 2 },
    point: { transition: 'all 0.2s ease' },
  };

  const hoveredPoint = hoveredIndex !== null ? { x: inputVector[hoveredIndex], y: outputVector[hoveredIndex] } : null;

  return (
    <div style={styles.container}>
      <h3 style={styles.title}>{functionType} Activation</h3>
      <div style={styles.mainArea}>
        <div style={styles.vectorGroup}>
          <div style={styles.vectorLabel}>Input</div>
          <div style={styles.vector}>
            {inputVector.map((val, i) => (
              <div key={`in-${i}`} onMouseEnter={() => setHoveredIndex(i)} onMouseLeave={() => setHoveredIndex(null)} style={{ ...styles.element, ...(hoveredIndex === i ? styles.highlight : {}) }}>
                {formatNumber(val, 2)}
              </div>
            ))}
          </div>
        </div>
        <div style={styles.chartContainer}>
          <svg viewBox={`0 0 ${width} ${height}`} style={styles.svg}>
            <path d={`M 0 ${toSvgY(0)} L ${width} ${toSvgY(0)}`} style={styles.axis} />
            <path d={`M ${toSvgX(0)} 0 L ${toSvgX(0)} ${height}`} style={styles.axis} />
            <path d={pathData} style={styles.path} />
            {hoveredPoint && (
              <g>
                <line x1={toSvgX(hoveredPoint.x)} y1={toSvgY(0)} x2={toSvgX(hoveredPoint.x)} y2={toSvgY(hoveredPoint.y)} strokeDasharray="3 3" stroke="#e63946" />
                <line x1={toSvgX(0)} y1={toSvgY(hoveredPoint.y)} x2={toSvgX(hoveredPoint.x)} y2={toSvgY(hoveredPoint.y)} strokeDasharray="3 3" stroke="#e63946" />
                <circle cx={toSvgX(hoveredPoint.x)} cy={toSvgY(hoveredPoint.y)} r="4" fill="#e63946" style={styles.point} />
              </g>
            )}
          </svg>
        </div>
        <div style={styles.vectorGroup}>
          <div style={styles.vectorLabel}>Output</div>
          <div style={styles.vector}>
            {outputVector.map((val, i) => (
              <div key={`out-${i}`} onMouseEnter={() => setHoveredIndex(i)} onMouseLeave={() => setHoveredIndex(null)} style={{ ...styles.element, ...(hoveredIndex === i ? styles.highlight : {}) }}>
                {formatNumber(val, 2)}
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
};

// END OF FILE: src/components/visualizers/ActivationFunctionVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/ElementWiseOpVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/ElementWiseOpVisualizer.tsx
import React, { useState, useRef } from 'react';
import { Matrix } from './types';
import { formatNumber, getCurvePath } from './utils';

interface ElementWiseOpVisualizerProps {
  matrixA: Matrix;
  matrixB: Matrix;
  operation: '+' | '-' | '×' | '÷';
}

export const ElementWiseOpVisualizer: React.FC<ElementWiseOpVisualizerProps> = ({ matrixA, matrixB, operation }) => {
  const [hoveredCell, setHoveredCell] = useState<{ row: number; col: number } | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const elementsARef = useRef<(HTMLDivElement | null)[][]>([]);
  const elementsBRef = useRef<(HTMLDivElement | null)[][]>([]);
  const elementsCRef = useRef<(HTMLDivElement | null)[][]>([]);

  const resultMatrix = matrixA.map((row, r) =>
    row.map((val, c) => {
      switch (operation) {
        case '+': return val + matrixB[r][c];
        case '-': return val - matrixB[r][c];
        case '×': return val * matrixB[r][c];
        case '÷': return val / matrixB[r][c];
        default: return NaN;
      }
    })
  );

  const numRows = matrixA.length;
  const numCols = matrixA[0].length;

  // Initialize refs arrays
  elementsARef.current = Array(numRows).fill(null).map(() => Array(numCols).fill(null));
  elementsBRef.current = Array(numRows).fill(null).map(() => Array(numCols).fill(null));
  elementsCRef.current = Array(numRows).fill(null).map(() => Array(numCols).fill(null));

  // Inline Styles
  const styles: { [key: string]: React.CSSProperties } = {
    container: { position: 'relative', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '25px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6', flexWrap: 'wrap' },
    matrixContainer: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px' },
    matrixLabel: { fontSize: '1.2em', fontWeight: 'bold', fontFamily: 'monospace' },
    grid: { display: 'grid', gap: '5px', gridTemplateColumns: `repeat(${numCols}, 1fr)` },
    element: { width: '50px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease' },
    sourceHighlight: { transform: 'scale(1.1)', borderColor: '#007bff', backgroundColor: 'rgba(0, 123, 255, 0.1)' },
    targetHighlight: { transform: 'scale(1.1)', borderColor: '#28a745', backgroundColor: 'rgba(40, 167, 69, 0.1)' },
    opSymbol: { fontSize: '2em', fontWeight: 'bold' },
    svg: { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none' },
    path: { fill: 'none', strokeWidth: '2px', stroke: '#e63946', transition: 'opacity 0.2s ease', opacity: 0 },
    pathVisible: { opacity: 1 },
  };

  const pathA = hoveredCell ? getCurvePath(elementsARef.current[hoveredCell.row][hoveredCell.col], elementsCRef.current[hoveredCell.row][hoveredCell.col], containerRef.current) : '';
  const pathB = hoveredCell ? getCurvePath(elementsBRef.current[hoveredCell.row][hoveredCell.col], elementsCRef.current[hoveredCell.row][hoveredCell.col], containerRef.current) : '';

  const renderMatrix = (matrix: Matrix, label: string, refArray: React.MutableRefObject<(HTMLDivElement | null)[][]>, highlightType: 'source' | 'target') => (
    <div style={styles.matrixContainer}>
      <div style={styles.matrixLabel}>{label}</div>
      <div style={styles.grid}>
        {matrix.map((row, r) => row.map((val, c) => (
          <div
            key={`${label}-${r}-${c}`}
            ref={el => refArray.current[r][c] = el}
            style={{ ...styles.element, ...(hoveredCell && hoveredCell.row === r && hoveredCell.col === c ? (highlightType === 'source' ? styles.sourceHighlight : styles.targetHighlight) : {}) }}
            onMouseEnter={() => setHoveredCell({ row: r, col: c })}
            onMouseLeave={() => setHoveredCell(null)}
          >
            {formatNumber(val, 2)}
          </div>
        )))}
      </div>
    </div>
  );

  return (
    <div style={styles.container} ref={containerRef}>
      <svg style={styles.svg}>
        <path d={pathA} style={{ ...styles.path, ...(hoveredCell ? styles.pathVisible : {}) }} />
        <path d={pathB} style={{ ...styles.path, ...(hoveredCell ? styles.pathVisible : {}) }} />
      </svg>
      {renderMatrix(matrixA, 'A', elementsARef, 'source')}
      <div style={styles.opSymbol}>{operation}</div>
      {renderMatrix(matrixB, 'B', elementsBRef, 'source')}
      <div style={styles.opSymbol}>=</div>
      {renderMatrix(resultMatrix, 'C', elementsCRef, 'target')}
    </div>
  );
};

// END OF FILE: src/components/visualizers/ElementWiseOpVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/InteractiveMatMulVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/InteractiveMatMulVisualizer.tsx
import React from 'react';
import { Vector, CalculationComponent, SymbolInfo } from './types';
import 'katex/dist/katex.min.css';
import { InlineMath } from 'react-katex';

interface InteractiveMatMulVisualizerProps {
    vectorA: Vector;
    vectorB: Vector;
    symbolAInfo: SymbolInfo;
    symbolBInfo: SymbolInfo;
    result: number;
    components: CalculationComponent[];
    hoveredComponentIndex: number | null;
    setHoveredComponentIndex: (index: number | null) => void;
}

const formatNumber = (num: number, precision = 4) => {
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '+∞';
    const fixed = num.toFixed(precision);
    return parseFloat(fixed).toString();
};

// [COPIED & MODIFIED] from matrixView.ts to avoid complex relative imports in a generic component
const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12;
const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 1,
  windowSize: number = 5
): (number | typeof ELLIPSIS)[] => {
  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }
  const visible = new Set<number>();
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }
  if (focusIndex === -1 && totalSize >= MIN_SIZE_FOR_TRUNCATION) {
    visible.add(Math.floor((totalSize - 1) / 2));
  }
  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }
  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];
  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }
  return result;
};


export const InteractiveMatMulVisualizer: React.FC<InteractiveMatMulVisualizerProps> = ({
    vectorA,
    vectorB,
    symbolAInfo,
    symbolBInfo,
    result,
    components,
    hoveredComponentIndex,
    setHoveredComponentIndex,
}) => {

    const renderVector = (vec: number[], symbolInfo: SymbolInfo, direction: 'row' | 'column' = 'row') => {
        let mathSymbol = symbolInfo.base;
        if (symbolInfo.subscript) mathSymbol += `_{${symbolInfo.subscript}}`;
        if (symbolInfo.superscript) mathSymbol += `^{${symbolInfo.superscript}}`;
        const dims = direction === 'row' ? `1 \\times ${vec.length}` : `${vec.length} \\times 1`;
        mathSymbol += `_{${dims}}`;

        return (
            <div className="tooltip-vector-group">
                <div className="matrix-wrapper side-label">
                    <div className="matrix-label-side"><InlineMath math={mathSymbol} /></div>
                </div>
                <span className="tooltip-symbol">=</span>
                <div className={`tooltip-vector ${direction}`}>
                    {vec.map((val, i) => (
                        <span
                            key={i}
                            className={`tooltip-element source ${hoveredComponentIndex === i ? 'highlight' : ''}`}
                        >
                            {formatNumber(val, 2)}
                        </span>
                    ))}
                </div>
            </div>
        );
    };

    const visibleTermIndices = getVisibleIndices(components.length, hoveredComponentIndex ?? -1, 1, 5);

    return (
        <div className="tooltip-matmul-container">
            {renderVector(vectorA, symbolAInfo, 'row')}
            <div className="tooltip-op-symbol">·</div>
            {renderVector(vectorB, symbolBInfo, 'column')}
            <div className="tooltip-result-line">
                <span className="tooltip-op-symbol">=</span>
                <span className="tooltip-result">{formatNumber(result, 4)}</span>
            </div>
            {components && (
                <div className="tooltip-calculation-detail">
                    <div className="tooltip-calc-title">点积计算分解 (Dot Product Breakdown):</div>
                    <div className="tooltip-calc-equation">
                        <div className="tooltip-braced-group">
                            <span className="tooltip-curly-brace">{'{'}</span>
                            <div className="tooltip-calc-terms-wrapper">
                                {visibleTermIndices.map((idx, i) => {
                                    if (idx === ELLIPSIS) {
                                        return <span key={`ellipsis-${i}`} className="op">...</span>;
                                    }
                                    const comp = components[idx];
                                    return (
                                        <React.Fragment key={idx}>
                                            {i > 0 && visibleTermIndices[i-1] !== ELLIPSIS && <span className="op">+</span>}
                                            <span onMouseEnter={() => setHoveredComponentIndex(idx)} onMouseLeave={() => setHoveredComponentIndex(null)}>
                                                <span className={`tooltip-calc-term ${hoveredComponentIndex === idx ? 'highlight' : ''}`}>
                                                    ({formatNumber(comp.a, 2)} <span className="op">×</span> {formatNumber(comp.b, 2)})
                                                </span>
                                            </span>
                                        </React.Fragment>
                                    );
                                })}
                            </div>
                            <span className="tooltip-curly-brace">{'}'}</span>
                        </div>
                        <span>=</span>
                        <span className="result">{formatNumber(result, 4)}</span>
                    </div>
                </div>
            )}
        </div>
    );
};
// END OF FILE: src/components/visualizers/InteractiveMatMulVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/LayerNormVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/LayerNormVisualizer.tsx
import React, { useState, useMemo } from 'react';
import { Vector, ProcessingStep } from './types';
import { formatNumber } from './utils';

interface LayerNormVisualizerProps {
  inputVector: Vector;
  epsilon?: number;
}

export const LayerNormVisualizer: React.FC<LayerNormVisualizerProps> = ({ inputVector, epsilon = 1e-5 }) => {
  const [step, setStep] = useState<ProcessingStep>('start');

  const calculations = useMemo(() => {
    const mean = inputVector.reduce((a, b) => a + b, 0) / inputVector.length;
    const variance = inputVector.map(x => (x - mean) ** 2).reduce((a, b) => a + b, 0) / inputVector.length;
    const stdDev = Math.sqrt(variance + epsilon);
    const normalized = inputVector.map(x => (x - mean) / stdDev);
    return { mean, variance, stdDev, normalized };
  }, [inputVector, epsilon]);

  const stepsOrder: ProcessingStep[] = ['start', 'calculate-mean', 'calculate-variance', 'apply-norm', 'done'];
  const currentStepIndex = stepsOrder.indexOf(step);

  const handleNext = () => setStep(stepsOrder[Math.min(stepsOrder.length - 1, currentStepIndex + 1)]);
  const handlePrev = () => setStep(stepsOrder[Math.max(0, currentStepIndex - 1)]);
  const handleReset = () => setStep('start');

  // Inline Styles (reusing some from SoftmaxVisualizer for consistency)
  const styles: { [key: string]: React.CSSProperties } = {
    container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    stepContainer: { width: '100%', padding: '15px', border: '1px solid #e9ecef', borderRadius: '8px', backgroundColor: '#fff', textAlign: 'center' },
    title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
    description: { margin: '0 0 15px 0', color: '#6c757d', minHeight: '40px' },
    vector: { display: 'flex', justifyContent: 'center', gap: '5px', flexWrap: 'wrap' },
    element: { minWidth: '60px', padding: '5px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease' },
    highlight: { borderColor: '#17a2b8', backgroundColor: 'rgba(23, 162, 184, 0.1)' },
    connector: { fontSize: '2em', color: '#6c757d', margin: '5px 0' },
    scalarContainer: { display: 'flex', gap: '20px', justifyContent: 'center', alignItems: 'center', flexWrap: 'wrap' },
    scalar: { padding: '8px 15px', fontSize: '1.1em', fontWeight: 'bold', border: '1px solid #ced4da', borderRadius: '8px', backgroundColor: '#e9ecef' },
    controls: { display: 'flex', gap: '10px', marginTop: '10px' },
    button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
  };

  const descriptions: Record<ProcessingStep, string> = {
    start: '初始输入向量。点击 "下一步" 开始计算。',
    'calculate-mean': `首先，计算向量所有元素的平均值。`,
    'calculate-variance': `然后，计算方差 (variance)，衡量数据点的离散程度。`,
    'apply-norm': `最后，使用均值和标准差对每个元素进行归一化。公式: (x - μ) / √(σ² + ε)`,
    done: '计算完成！输出向量的均值接近0，方差接近1。',
    // [FIXED] Add unused keys to satisfy the Record type
    'subtract-max': '', 'exponentiate': '', 'sum-exps': '', 'normalize': '',
    'calculate-squared-sum': '', 'calculate-rms': '', 'apply-rms-norm': ''
  };

  const renderVector = (vec: Vector, isHighlighted: boolean = false) => (
    <div style={styles.vector}>
      {vec.map((val, i) => (
        <div key={i} style={{ ...styles.element, ...(isHighlighted ? styles.highlight : {}) }}>
          {formatNumber(val)}
        </div>
      ))}
    </div>
  );

  return (
    <div style={styles.container}>
      <div style={styles.stepContainer}>
        <h3 style={styles.title}>LayerNorm(x)</h3>
        <p style={styles.description}>{descriptions[step]}</p>

        {renderVector(inputVector, currentStepIndex >= 0)}

        {currentStepIndex >= 1 && <div style={styles.connector}>↓</div>}

        {currentStepIndex >= 1 && (
          <div style={styles.scalarContainer}>
            <div style={{ ...styles.scalar, ...(currentStepIndex === 1 ? styles.highlight : {}) }}>
              μ = {formatNumber(calculations.mean)}
            </div>
            {currentStepIndex >= 2 && (
              <div style={{ ...styles.scalar, ...(currentStepIndex === 2 ? styles.highlight : {}) }}>
                σ² = {formatNumber(calculations.variance)}
              </div>
            )}
          </div>
        )}

        {currentStepIndex >= 3 && <div style={styles.connector}>↓</div>}
        {currentStepIndex >= 3 && renderVector(calculations.normalized, currentStepIndex >= 3)}
      </div>
      <div style={styles.controls}>
        <button onClick={handlePrev} disabled={currentStepIndex <= 0} style={styles.button}>上一步</button>
        <button onClick={handleNext} disabled={currentStepIndex >= stepsOrder.length - 1} style={styles.button}>下一步</button>
        <button onClick={handleReset} style={styles.button}>重置</button>
      </div>
    </div>
  );
};

// END OF FILE: src/components/visualizers/LayerNormVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/MatMulVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/MatMulVisualizer.tsx
import React, { useRef, useMemo, useState, useEffect, useCallback } from 'react';
import { Vector, MatMulStep } from './types';
import { useAnimationController, formatNumber, getCurvePath } from './utils';

interface MatMulVisualizerProps {
  vectorA: Vector;
  vectorB: Vector;
}

export const MatMulVisualizer: React.FC<MatMulVisualizerProps> = ({ vectorA, vectorB }) => {
  const [svgPaths, setSvgPaths] = useState<any[]>([]);

  const containerRef = useRef<HTMLDivElement>(null);
  const scrollWrapperARef = useRef<HTMLDivElement>(null);
  const scrollWrapperBRef = useRef<HTMLDivElement>(null);
  const scrollWrapperProdRef = useRef<HTMLDivElement>(null);

  const elementsARef = useRef<(HTMLDivElement | null)[]>([]);
  const elementsBRef = useRef<(HTMLDivElement | null)[]>([]);
  const productRefs = useRef<(HTMLDivElement | null)[]>([]);
  const sumRef = useRef<HTMLDivElement>(null);

  const steps: MatMulStep[] = useMemo(() => {
    const generatedSteps: MatMulStep[] = [];
    let cumulativeSum = 0;
    for (let i = 0; i < vectorA.length; i++) {
      generatedSteps.push({ type: 'highlight-pair', index: i });
      const product = vectorA[i] * vectorB[i];
      generatedSteps.push({ type: 'multiply', index: i, product });
      cumulativeSum += product;
      generatedSteps.push({ type: 'accumulate', index: i, product, cumulativeSum });
    }
    generatedSteps.push({ type: 'finish', index: -1, cumulativeSum });
    return generatedSteps;
  }, [vectorA, vectorB]);

  const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 800);

  const result = useMemo(() => vectorA.reduce((sum, val, i) => sum + val * vectorB[i], 0), [vectorA, vectorB]);
  const currentAnimState: MatMulStep = steps[currentStep] || { type: 'idle', index: -1 };

  const recalculatePaths = useCallback(() => {
    if (!containerRef.current) return;
    const newPaths = vectorA.map((_, i) => ({
      id: `paths-${i}`,
      path1: getCurvePath(elementsARef.current[i], productRefs.current[i], containerRef.current),
      path2: getCurvePath(elementsBRef.current[i], productRefs.current[i], containerRef.current),
      // [REMOVED] Path 3 is no longer needed as we are not connecting each term to the sum.
    }));
    setSvgPaths(newPaths);
  }, [vectorA]);

  useEffect(() => {
    const observer = new ResizeObserver(recalculatePaths);
    const elementsToObserve = [
        containerRef.current,
        scrollWrapperARef.current,
        scrollWrapperBRef.current,
        scrollWrapperProdRef.current,
    ].filter(Boolean);

    elementsToObserve.forEach(el => observer.observe(el!));

    const scrollableElements = [scrollWrapperARef.current, scrollWrapperBRef.current, scrollWrapperProdRef.current].filter(Boolean);
    scrollableElements.forEach(el => el!.addEventListener('scroll', recalculatePaths, { passive: true }));

    const tooltipContent = containerRef.current?.closest('.tooltip-content-wrapper');
    if (tooltipContent) {
        tooltipContent.addEventListener('scroll', recalculatePaths, { passive: true });
    }

    const timeoutId = setTimeout(recalculatePaths, 50);

    return () => {
        clearTimeout(timeoutId);
        observer.disconnect();
        scrollableElements.forEach(el => el!.removeEventListener('scroll', recalculatePaths));
        if (tooltipContent) {
            tooltipContent.removeEventListener('scroll', recalculatePaths);
        }
    };
  }, [recalculatePaths, currentStep]);

  const handlePrevStep = () => {
    if (currentStep > -1) {
        setStepManually(currentStep - 1);
    }
  };

  const handleNextStep = () => {
    if (currentStep < steps.length - 1) {
        setStepManually(currentStep + 1);
    }
  };

  // Inline Styles
  const styles: { [key: string]: React.CSSProperties } = {
    container: { position: 'relative', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '15px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6', overflow: 'hidden' },
    vectorContainer: { display: 'flex', gap: '8px', alignItems: 'center', width: 'auto', maxWidth: '100%' },
    vectorLabel: { fontSize: '1.2em', fontWeight: 'bold', fontFamily: 'monospace' },
    vectorScrollWrapper: { flexGrow: 1, minWidth: 0, overflowX: 'auto', paddingBottom: '10px' },
    vector: { display: 'flex', gap: '5px', padding: '5px', border: '1px solid #ccc', borderRadius: '4px', backgroundColor: 'white', width: 'max-content' },
    element: { display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', flex: '1 1 0', minWidth: '60px', height: '30px', padding: '0 5px', cursor: 'pointer' },
    highlight: { transform: 'scale(1.15)', borderColor: '#e63946', backgroundColor: 'rgba(230, 57, 70, 0.1)', fontWeight: 'bold' },
    productContainer: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px', minHeight: '60px', width: '100%' },
    productsRow: { display: 'flex', gap: '10px', alignItems: 'center', width: 'max-content' },
    productTerm: { display: 'flex', justifyContent: 'center', alignItems: 'center', padding: '5px 8px', border: '1px dashed #adb5bd', borderRadius: '4px', opacity: 0, transition: 'opacity 0.3s ease', whiteSpace: 'nowrap', flex: '1 1 0', minWidth: '120px' },
    plusSymbol: { opacity: 0, transition: 'opacity 0.3s ease', fontWeight: 'bold', fontSize: '1.2em' },
    visible: { opacity: 1 },
    sumContainer: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px' },
    sumLabel: { fontWeight: 'bold' },
    sumValue: { padding: '8px 15px', fontSize: '1.2em', fontWeight: 'bold', border: '2px solid #28a745', borderRadius: '8px', backgroundColor: 'rgba(40, 167, 69, 0.1)', color: '#155724' },
    svg: { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 1 },
    path: { fill: 'none', strokeWidth: '2px', stroke: '#adb5bd', strokeDasharray: '4 4', transition: 'stroke 0.3s ease, d 0.1s linear' },
    pathHighlight: { stroke: '#e63946', strokeWidth: '2.5px', strokeDasharray: 'none' },
    controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center' },
    button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
    playingButton: { backgroundColor: '#6c757d', color: '#fff' },
    opSymbol: { fontSize: '1.8em', fontWeight: 'bold', margin: '5px 0' },
    braceStyle: { fontSize: '2.5em', color: '#6c757d', fontWeight: 'normal', alignSelf: 'center' },
  };

  return (
    <div style={styles.container} ref={containerRef}>
      <svg style={styles.svg}>
        {/* [MODIFIED] New SVG rendering logic for correct animation flow */}
        {svgPaths.map((pathData, i) => {
          // Find the first step related to this index
          const firstStepForIndex = steps.findIndex(s => s.index === i);
          // Don't render anything for future steps
          if (currentStep < firstStepForIndex || !pathData.id) {
            return null;
          }
          // Determine if the current animation step is actively processing this index
          const isCurrent = currentAnimState.index === i && (currentAnimState.type === 'highlight-pair' || currentAnimState.type === 'multiply');
          // Apply highlight style if current, otherwise default path style
          const pathStyle = isCurrent ? { ...styles.path, ...styles.pathHighlight } : styles.path;

          return (
            <React.Fragment key={pathData.id}>
              <path d={pathData.path1} style={pathStyle} />
              <path d={pathData.path2} style={pathStyle} />
            </React.Fragment>
          );
        })}
      </svg>

      <div style={styles.vectorContainer}>
        <div style={styles.vectorLabel}>A =</div>
        <div style={styles.vectorScrollWrapper} ref={scrollWrapperARef}>
          <div style={styles.vector}>
            {vectorA.map((val, i) => (
              <div key={i} ref={el => elementsARef.current[i] = el} style={{...styles.element, ...(currentAnimState.type !== 'idle' && currentAnimState.index === i ? styles.highlight : {})}}>
                {formatNumber(val, 2)}
              </div>
            ))}
          </div>
        </div>
      </div>

      <div style={styles.opSymbol}>&times;</div>

      <div style={styles.vectorContainer}>
        <div style={styles.vectorLabel}>B =</div>
        <div style={styles.vectorScrollWrapper} ref={scrollWrapperBRef}>
          <div style={styles.vector}>
            {vectorB.map((val, i) => (
              <div key={i} ref={el => elementsBRef.current[i] = el} style={{...styles.element, ...(currentAnimState.type !== 'idle' && currentAnimState.index === i ? styles.highlight : {})}}>
                {formatNumber(val, 2)}
              </div>
            ))}
          </div>
        </div>
      </div>

      <div style={styles.productContainer}>
        <div style={{fontWeight: 'bold'}}>Intermediate Products</div>
        {/* [FIXED] Added scroll wrapper to fix overflow */}
        <div style={styles.vectorScrollWrapper} ref={scrollWrapperProdRef}>
            <div style={styles.productsRow}>
            <span style={styles.braceStyle}>{'{'}</span>
            {vectorA.map((_, i) => (
                <React.Fragment key={`prod-frag-${i}`}>
                <div ref={el => productRefs.current[i] = el} style={{ ...styles.productTerm, ...(currentStep >= steps.findIndex(s => s.type === 'multiply' && s.index === i) ? styles.visible : {}) }}>
                    ({formatNumber(vectorA[i], 2)} &times; {formatNumber(vectorB[i], 2)})
                </div>
                {i < vectorA.length - 1 && <span style={{...styles.plusSymbol, ...(currentStep > steps.findIndex(s => s.type === 'multiply' && s.index === i) ? styles.visible : {})}}>+</span>}
                </React.Fragment>
            ))}
            <span style={styles.braceStyle}>{'}'}</span>
            </div>
        </div>
      </div>

      {/* [NEW] Added logical separator */}
      <div style={styles.opSymbol}>=</div>

      <div style={styles.sumContainer}>
        <div style={styles.sumLabel}>Final Result</div>
        <div ref={sumRef} style={styles.sumValue}>
          {currentAnimState.type === 'accumulate' ? formatNumber(currentAnimState.cumulativeSum ?? 0, 3) : currentAnimState.type === 'finish' ? formatNumber(result, 3) : '?'}
        </div>
      </div>

      <div style={styles.controls}>
        <button onClick={handlePrevStep} disabled={currentStep <= -1} style={styles.button}>上一步</button>
        <button onClick={play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>Play</button>
        <button onClick={pause} style={styles.button}>Pause</button>
        <button onClick={handleNextStep} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
        <button onClick={reset} style={styles.button}>Reset</button>
      </div>
      <input
        type="range"
        min={-1}
        max={steps.length - 1}
        value={currentStep}
        onChange={e => setStepManually(parseInt(e.target.value))}
        style={{width: '80%', cursor: 'pointer', marginTop: '10px'}}
      />
    </div>
  );
};
// END OF FILE: src/components/visualizers/MatMulVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/RMSNormVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/RMSNormVisualizer.tsx
import React, { useState, useMemo } from 'react';
import { Vector, ProcessingStep } from './types';
import { formatNumber } from './utils';

interface RMSNormVisualizerProps {
  inputVector: Vector;
  epsilon?: number;
}

export const RMSNormVisualizer: React.FC<RMSNormVisualizerProps> = ({ inputVector, epsilon = 1e-5 }) => {
  const [step, setStep] = useState<ProcessingStep>('start');

  const calculations = useMemo(() => {
    const n = inputVector.length;
    const squaredSum = inputVector.map(x => x * x).reduce((a, b) => a + b, 0);
    const meanSquare = squaredSum / n;
    const rms = Math.sqrt(meanSquare + epsilon);
    const normalized = inputVector.map(x => x / rms);
    return { squaredSum, rms, normalized };
  }, [inputVector, epsilon]);

  const stepsOrder: ProcessingStep[] = ['start', 'calculate-squared-sum', 'calculate-rms', 'apply-rms-norm', 'done'];
  const currentStepIndex = stepsOrder.indexOf(step);

  const handleNext = () => setStep(stepsOrder[Math.min(stepsOrder.length - 1, currentStepIndex + 1)]);
  const handlePrev = () => setStep(stepsOrder[Math.max(0, currentStepIndex - 1)]);
  const handleReset = () => setStep('start');

  // Inline Styles
  const styles: { [key: string]: React.CSSProperties } = {
    container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    stepContainer: { width: '100%', padding: '15px', border: '1px solid #e9ecef', borderRadius: '8px', backgroundColor: '#fff', textAlign: 'center' },
    title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
    description: { margin: '0 0 15px 0', color: '#6c757d', minHeight: '40px' },
    vector: { display: 'flex', justifyContent: 'center', gap: '5px', flexWrap: 'wrap' },
    element: { minWidth: '60px', padding: '5px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease' },
    highlight: { borderColor: '#fd7e14', backgroundColor: 'rgba(253, 126, 20, 0.1)' },
    connector: { fontSize: '2em', color: '#6c757d', margin: '5px 0' },
    scalar: { padding: '8px 15px', fontSize: '1.1em', fontWeight: 'bold', border: '1px solid #ced4da', borderRadius: '8px', backgroundColor: '#e9ecef' },
    controls: { display: 'flex', gap: '10px', marginTop: '10px' },
    button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
  };

  const descriptions: Record<ProcessingStep, string> = {
    start: '初始输入向量。RMSNorm 是一种简化的 LayerNorm。',
    'calculate-squared-sum': `首先，计算向量所有元素的平方和。`,
    'calculate-rms': `然后，计算均方根 (Root Mean Square)。公式: √ (Σ(x²) / n + ε)`,
    'apply-rms-norm': `最后，将每个原始元素除以 RMS 值进行归一化。公式: x / RMS(x)`,
    done: '计算完成！(注意：这里省略了可学习的 gamma 缩放步骤)',
    'subtract-max': '', 'exponentiate': '', 'sum-exps': '', 'normalize': '', 'calculate-mean': '', 'calculate-variance': '', 'apply-norm': ''
  };

  const renderVector = (vec: Vector, isHighlighted: boolean = false) => (
    <div style={styles.vector}>
      {vec.map((val, i) => (
        <div key={i} style={{ ...styles.element, ...(isHighlighted ? styles.highlight : {}) }}>
          {formatNumber(val)}
        </div>
      ))}
    </div>
  );

  return (
    <div style={styles.container}>
      <div style={styles.stepContainer}>
        <h3 style={styles.title}>RMSNorm(x)</h3>
        <p style={styles.description}>{descriptions[step]}</p>

        {renderVector(inputVector, currentStepIndex >= 0)}

        {currentStepIndex >= 1 && <div style={styles.connector}>↓</div>}

        {currentStepIndex >= 1 && (
            <div style={{ ...styles.scalar, ...(currentStepIndex === 1 ? styles.highlight : {}) }}>
              Σ(x²) = {formatNumber(calculations.squaredSum)}
            </div>
        )}

        {currentStepIndex >= 2 && <div style={styles.connector}>↓</div>}

        {currentStepIndex >= 2 && (
            <div style={{ ...styles.scalar, ...(currentStepIndex === 2 ? styles.highlight : {}) }}>
              RMS = {formatNumber(calculations.rms)}
            </div>
        )}

        {currentStepIndex >= 3 && <div style={styles.connector}>↓</div>}
        {currentStepIndex >= 3 && renderVector(calculations.normalized, currentStepIndex >= 3)}
      </div>
      <div style={styles.controls}>
        <button onClick={handlePrev} disabled={currentStepIndex <= 0} style={styles.button}>上一步</button>
        <button onClick={handleNext} disabled={currentStepIndex >= stepsOrder.length - 1} style={styles.button}>下一步</button>
        <button onClick={handleReset} style={styles.button}>重置</button>
      </div>
    </div>
  );
};

// END OF FILE: src/components/visualizers/RMSNormVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/SoftmaxVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/SoftmaxVisualizer.tsx
import React, { useState, useMemo } from 'react';
import { Vector, ProcessingStep } from './types';
import { formatNumber } from './utils';

interface SoftmaxVisualizerProps {
  inputVector: Vector;
}

export const SoftmaxVisualizer: React.FC<SoftmaxVisualizerProps> = ({ inputVector }) => {
  const [step, setStep] = useState<ProcessingStep>('start');

  const calculations = useMemo(() => {
    const maxVal = Math.max(...inputVector);
    const shifted = inputVector.map(v => v - maxVal);
    const exps = shifted.map(v => Math.exp(v));
    const sumExps = exps.reduce((a, b) => a + b, 0);
    const result = exps.map(v => v / sumExps);
    return { maxVal, shifted, exps, sumExps, result };
  }, [inputVector]);

  const stepsOrder: ProcessingStep[] = ['start', 'subtract-max', 'exponentiate', 'sum-exps', 'normalize', 'done'];
  const currentStepIndex = stepsOrder.indexOf(step);

  const handleNext = () => setStep(stepsOrder[Math.min(stepsOrder.length - 1, currentStepIndex + 1)]);
  const handlePrev = () => setStep(stepsOrder[Math.max(0, currentStepIndex - 1)]);
  const handleReset = () => setStep('start');

  // Inline Styles
  const styles: { [key: string]: React.CSSProperties } = {
    container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    stepContainer: { width: '100%', padding: '15px', border: '1px solid #e9ecef', borderRadius: '8px', backgroundColor: '#fff', textAlign: 'center' },
    title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
    description: { margin: '0 0 15px 0', color: '#6c757d', minHeight: '40px' },
    vector: { display: 'flex', justifyContent: 'center', gap: '5px', flexWrap: 'wrap' },
    element: { minWidth: '60px', padding: '5px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease' },
    highlight: { borderColor: '#e63946', backgroundColor: 'rgba(230, 57, 70, 0.1)' },
    connector: { fontSize: '2em', color: '#6c757d', margin: '5px 0' },
    scalar: { padding: '8px 15px', fontSize: '1.1em', fontWeight: 'bold', border: '1px solid #ced4da', borderRadius: '8px', backgroundColor: '#e9ecef' },
    controls: { display: 'flex', gap: '10px', marginTop: '10px' },
    button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
  };

  const descriptions: Record<ProcessingStep, string> = {
    start: '初始输入向量 (Logits)。点击 "下一步" 开始计算。',
    'subtract-max': `为了数值稳定性，首先从每个元素中减去最大值 (${formatNumber(calculations.maxVal, 2)})。`,
    exponentiate: '对每个新元素应用指数函数 e^x。',
    'sum-exps': `将所有指数结果相加，得到归一化因子。`,
    normalize: `将每个指数结果除以总和，得到最终的概率分布。`,
    done: '计算完成！这是一个有效的概率分布，所有元素之和为1。',
    // [FIXED] Add unused keys to satisfy the Record type
    'calculate-mean': '', 'calculate-variance': '', 'apply-norm': '',
    'calculate-squared-sum': '', 'calculate-rms': '', 'apply-rms-norm': ''
  };

  const renderVector = (vec: Vector, isHighlighted: boolean = false) => (
    <div style={styles.vector}>
      {vec.map((val, i) => (
        <div key={i} style={{ ...styles.element, ...(isHighlighted ? styles.highlight : {}) }}>
          {formatNumber(val)}
        </div>
      ))}
    </div>
  );

  return (
    <div style={styles.container}>
      <div style={styles.stepContainer}>
        <h3 style={styles.title}>Softmax(x)</h3>
        <p style={styles.description}>{descriptions[step]}</p>

        {/* Step 1: Input */}
        {renderVector(inputVector, currentStepIndex >= 0)}

        {/* Step 2: Subtract Max */}
        {currentStepIndex >= 1 && <div style={styles.connector}>↓</div>}
        {currentStepIndex >= 1 && renderVector(calculations.shifted, currentStepIndex === 1)}

        {/* Step 3: Exponentiate */}
        {currentStepIndex >= 2 && <div style={styles.connector}>↓</div>}
        {currentStepIndex >= 2 && renderVector(calculations.exps, currentStepIndex === 2)}

        {/* Step 4: Sum */}
        {currentStepIndex >= 3 && <div style={styles.connector}>↓</div>}
        {currentStepIndex >= 3 && <div style={{...styles.scalar, ...(currentStepIndex === 3 ? styles.highlight : {})}}>{formatNumber(calculations.sumExps)}</div>}

        {/* Step 5: Normalize */}
        {currentStepIndex >= 4 && <div style={styles.connector}>↓</div>}
        {currentStepIndex >= 4 && renderVector(calculations.result, currentStepIndex >= 4)}

      </div>
      <div style={styles.controls}>
        <button onClick={handlePrev} disabled={currentStepIndex <= 0} style={styles.button}>上一步</button>
        <button onClick={handleNext} disabled={currentStepIndex >= stepsOrder.length - 1} style={styles.button}>下一步</button>
        <button onClick={handleReset} style={styles.button}>重置</button>
      </div>
    </div>
  );
};
// END OF FILE: src/components/visualizers/SoftmaxVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/SwiGLUVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/SwiGLUVisualizer.tsx
import React, { useRef } from 'react';
import { Vector } from './types';
import { formatNumber, getCurvePath } from './utils';

interface SwiGLUVisualizerProps {
  inputVector: Vector; // This would be x
  gateActivation: Vector; // This would be SiLU(xW)
  dataVector: Vector; // This would be xV
}

export const SwiGLUVisualizer: React.FC<SwiGLUVisualizerProps> = ({ inputVector, gateActivation, dataVector }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRefs = useRef<(HTMLDivElement | null)[]>([]);
  const gateRefs = useRef<(HTMLDivElement | null)[]>([]);
  const dataRefs = useRef<(HTMLDivElement | null)[]>([]);
  const outputRefs = useRef<(HTMLDivElement | null)[]>([]);

  const outputVector = gateActivation.map((val, i) => val * dataVector[i]);

  // Inline Styles
  const styles: { [key: string]: React.CSSProperties } = {
    container: { position: 'relative', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '20px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
    mainArea: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '30px', flexWrap: 'wrap' },
    pathContainer: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px' },
    label: { fontWeight: 'bold', color: '#6c757d', padding: '4px 8px', backgroundColor: '#e9ecef', borderRadius: '4px' },
    vector: { display: 'flex', flexDirection: 'column', gap: '5px' },
    element: { width: '60px', padding: '5px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease' },
    opSymbol: { fontSize: '2em', fontWeight: 'bold', alignSelf: 'center' },
    svg: { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none' },
    path: { fill: 'none', strokeWidth: '2px', stroke: '#adb5bd', strokeDasharray: '4 4' },
  };

  const renderVector = (vec: Vector, refs: React.MutableRefObject<(HTMLDivElement | null)[]>) => (
    <div style={styles.vector}>
      {vec.map((val, i) => (
        <div key={i} ref={el => refs.current[i] = el} style={styles.element}>
          {formatNumber(val, 2)}
        </div>
      ))}
    </div>
  );

  return (
    <div style={styles.container} ref={containerRef}>
      <svg style={styles.svg}>
        {inputVector.map((_, i) => (
          <React.Fragment key={`path-${i}`}>
            <path d={getCurvePath(inputRefs.current[i], gateRefs.current[i], containerRef.current)} style={styles.path} />
            <path d={getCurvePath(inputRefs.current[i], dataRefs.current[i], containerRef.current)} style={styles.path} />
            <path d={getCurvePath(gateRefs.current[i], outputRefs.current[i], containerRef.current)} style={styles.path} />
            <path d={getCurvePath(dataRefs.current[i], outputRefs.current[i], containerRef.current)} style={styles.path} />
          </React.Fragment>
        ))}
      </svg>
      <h3 style={styles.title}>SwiGLU(x) = SiLU(xW) ⊙ xV</h3>
      <div style={styles.mainArea}>
        <div style={styles.pathContainer}>
          <div style={styles.label}>Input (x)</div>
          {renderVector(inputVector, inputRefs)}
        </div>

        <div style={styles.opSymbol}>→</div>

        <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
          <div style={styles.pathContainer}>
            <div style={styles.label}>Gate Path: SiLU(xW)</div>
            {renderVector(gateActivation, gateRefs)}
          </div>
          <div style={styles.pathContainer}>
            <div style={styles.label}>Data Path: xV</div>
            {renderVector(dataVector, dataRefs)}
          </div>
        </div>

        <div style={styles.opSymbol}>⊙</div>

        <div style={styles.pathContainer}>
          <div style={styles.label}>Output</div>
          {renderVector(outputVector, outputRefs)}
        </div>
      </div>
    </div>
  );
};

// END OF FILE: src/components/visualizers/SwiGLUVisualizer.tsx


================================================================================
### 文件路径: src/components/visualizers/types.ts
================================================================================

// FILE: src/components/visualizers/types.ts

/**
 * 定义可视化组件库共享的类型
 */

export type Vector = number[];
export type Matrix = number[][];

// 动画步骤的状态，用于控制分步可视化
export type AnimationStatus = 'idle' | 'running' | 'paused' | 'finished';

// 点积动画的详细步骤
export interface MatMulStep {
  type: 'highlight-pair' | 'multiply' | 'accumulate' | 'finish' | 'idle'; // [FIXED] Added 'idle'
  index: number; // 当前处理的元素索引
  product?: number; // 乘积结果
  cumulativeSum?: number; // 累加和
}

// Softmax/LayerNorm/RMSNorm 动画的步骤名称
export type ProcessingStep =
  | 'start'
  | 'subtract-max'
  | 'exponentiate'
  | 'sum-exps'
  | 'normalize'
  | 'calculate-mean'
  | 'calculate-variance'
  | 'apply-norm'
  | 'calculate-squared-sum' // For RMSNorm
  | 'calculate-rms'         // For RMSNorm
  | 'apply-rms-norm'      // For RMSNorm
  | 'done';

// 支持的激活函数类型
export type ActivationFunctionType = 'relu' | 'gelu' | 'silu';

// [NEW] For InteractiveMatMulVisualizer
export interface CalculationComponent {
    a: number;
    b: number;
}

// [NEW] Generic Symbol Information for tooltips
export interface SymbolInfo {
    base: string;
    superscript?: string;
    subscript?: string;
}
// END OF FILE: src/components/visualizers/types.ts


================================================================================
### 文件路径: src/components/visualizers/utils.ts
================================================================================

// FILE: src/components/visualizers/utils.ts

import { useState, useEffect, useCallback } from 'react';

/**
 * 格式化数字以便显示
 * @param num 要格式化的数字
 * @param precision 小数位数，默认为3
 * @returns 格式化后的字符串
 */
export const formatNumber = (num: number, precision: number = 3): string => {
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '∞';
    const fixed = num.toFixed(precision);
    // 移除末尾多余的0和可能存在的小数点
    return parseFloat(fixed).toString();
};


/**
 * 一个用于控制分步动画的 React Hook
 * @param totalSteps 动画总步数
 * @param delay 动画每一步之间的延迟（毫秒）
 * @returns [currentStep, play, pause, reset]
 */
export const useAnimationController = (totalSteps: number, delay: number = 500) => {
    const [step, setStep] = useState<number>(-1); // -1表示未开始
    const [isPlaying, setIsPlaying] = useState<boolean>(false);

    useEffect(() => {
        if (!isPlaying || step >= totalSteps - 1) {
            if (step >= totalSteps - 1) {
                setIsPlaying(false);
            }
            return;
        }

        const timer = setTimeout(() => {
            setStep(prev => prev + 1);
        }, delay);

        return () => clearTimeout(timer);
    }, [isPlaying, step, totalSteps, delay]);

    const play = useCallback(() => {
        if (step >= totalSteps - 1) {
            setStep(0); // 如果已完成，则从头播放
        } else if (step === -1) {
            setStep(0); // 首次播放
        }
        setIsPlaying(true);
    }, [step, totalSteps]);

    const pause = useCallback(() => {
        setIsPlaying(false);
    }, []);

    const reset = useCallback(() => {
        setIsPlaying(false);
        setStep(-1);
    }, []);

    const setStepManually = useCallback((newStep: number) => {
        setIsPlaying(false);
        if (newStep >= -1 && newStep < totalSteps) {
            setStep(newStep);
        }
    }, [totalSteps]);


    return {
        currentStep: step,
        isPlaying,
        play,
        pause,
        reset,
        setStepManually
    };
};

/**
 * 计算两个 DOM 元素中心点之间的 SVG 曲线路径
 * @param startEl 起始 DOM 元素
 * @param endEl 结束 DOM 元素
 * @param containerEl 容器 DOM 元素，用于计算相对坐标
 * @returns SVG 'd' 属性字符串
 */
export const getCurvePath = (startEl: Element | null, endEl: Element | null, containerEl: Element | null): string => {
    if (!startEl || !endEl || !containerEl) return '';

    const containerRect = containerEl.getBoundingClientRect();
    const startRect = startEl.getBoundingClientRect();
    const endRect = endEl.getBoundingClientRect();

    const startX = startRect.left + startRect.width / 2 - containerRect.left;
    const startY = startRect.top + startRect.height / 2 - containerRect.top;
    const endX = endRect.left + endRect.width / 2 - containerRect.left;
    const endY = endRect.top + endRect.height / 2 - containerRect.top;

    const dx = endX - startX;
    const dy = endY - startY;

    // 控制点，用于创建曲线效果
    const cp1x = startX + dx * 0.25;
    const cp1y = startY + dy * 0.1;
    const cp2x = startX + dx * 0.75;
    const cp2y = startY + dy * 0.9;

    return `M ${startX} ${startY} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${endX},${endY}`;
};


// END OF FILE: src/components/visualizers/utils.ts


================================================================================
### 文件路径: src/hooks/useDraggableAndResizable.tsx
================================================================================

// FILE: src/hooks/useDraggableAndResizable.ts
import { useState, useCallback, useRef, MouseEvent, useEffect } from 'react';

type DragType = 'move' | 'resize-t' | 'resize-r' | 'resize-b' | 'resize-l' | 'resize-br';

interface DragState {
  type: DragType;
  startX: number;
  startY: number;
  startWidth: number;
  startHeight: number;
  startLeft: number;
  startTop: number;
}

export const useDraggableAndResizable = (initialState: {
  width: number;
  height: number | 'auto';
  x: number;
  y: number;
}, contentRef: React.RefObject<HTMLDivElement>) => {
  const [size, setSize] = useState<{width: number, height: number | 'auto'}>({ width: initialState.width, height: initialState.height });
  const [position, setPosition] = useState({ x: initialState.x, y: initialState.y });
  const observerRef = useRef<ResizeObserver | null>(null);

  const dragState = useRef<DragState | null>(null);

  // --- [NEW] Effect to clamp initial position and size to be within the viewport ---
  useEffect(() => {
    const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));

    let initialWidth = initialState.width;
    let initialHeight = typeof initialState.height === 'number' ? initialState.height : 500; // Use a default for 'auto'

    let clampedWidth = clamp(initialWidth, 200, window.innerWidth);
    let clampedHeight = clamp(initialHeight, 100, window.innerHeight);

    let clampedX = clamp(initialState.x, 0, window.innerWidth - clampedWidth);
    let clampedY = clamp(initialState.y, 0, window.innerHeight - clampedHeight);

    // If the window is smaller than the component, adjust position to 0
    if (clampedWidth >= window.innerWidth) clampedX = 0;
    if (clampedHeight >= window.innerHeight) clampedY = 0;

    setSize({ width: clampedWidth, height: initialState.height === 'auto' ? 'auto' : clampedHeight });
    setPosition({ x: clampedX, y: clampedY });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Run only once on mount


  const disconnectObserver = useCallback(() => {
    if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
    }
  }, []);

  useEffect(() => {
    if (size.height === 'auto' && contentRef.current) {
        disconnectObserver();
        observerRef.current = new ResizeObserver(entries => {
            const entry = entries[0];
            if (entry) {
                const contentHeight = entry.contentRect.height;
                // Add panel header/padding height to content height
                const totalHeight = contentHeight + 80; // Approximate extra height
                setSize(s => ({...s, height: Math.min(totalHeight, window.innerHeight - 40)}));
            }
        });
        observerRef.current.observe(contentRef.current);
    }
    return () => disconnectObserver();
  }, [contentRef, size.height, disconnectObserver]);


  const handleMouseDown = useCallback((e: MouseEvent<HTMLDivElement>, type: DragType) => {
    e.preventDefault();
    e.stopPropagation();

    if (!contentRef.current) return;

    const currentHeight = typeof size.height === 'number' ? size.height : contentRef.current.offsetHeight;
    if (size.height === 'auto') {
        setSize(s => ({...s, height: currentHeight}));
    }

    dragState.current = {
      type,
      startX: e.clientX,
      startY: e.clientY,
      startWidth: contentRef.current.offsetWidth,
      startHeight: currentHeight,
      startLeft: position.x,
      startTop: position.y,
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [size, position, contentRef]);

  const handleMouseMove = useCallback((e: globalThis.MouseEvent) => {
    if (!dragState.current) return;
    e.preventDefault();
    e.stopPropagation();

    const dx = e.clientX - dragState.current.startX;
    const dy = e.clientY - dragState.current.startY;
    const { type, startWidth, startHeight, startLeft, startTop } = dragState.current;

    let newWidth = startWidth;
    let newHeight = startHeight;
    let newX = startLeft;
    let newY = startTop;

    if (type === 'move') {
      newX = startLeft + dx;
      newY = startTop + dy;
    } else {
        if (type.includes('r')) newWidth = startWidth + dx;
        if (type.includes('l')) {
            newWidth = startWidth - dx;
            newX = startLeft + dx;
        }
        if (type.includes('b')) newHeight = startHeight + dy;
        if (type.includes('t')) {
            newHeight = startHeight - dy;
            newY = startTop + dy;
        }
    }

    // --- [MODIFIED] Add boundary constraints ---
    const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));

    // Minimum dimensions
    newWidth = Math.max(200, newWidth);
    newHeight = Math.max(100, newHeight);

    // Clamp size to viewport
    newWidth = Math.min(newWidth, window.innerWidth);
    newHeight = Math.min(newHeight, window.innerHeight);

    // Clamp position to viewport
    newX = clamp(newX, 0, window.innerWidth - newWidth);
    newY = clamp(newY, 0, window.innerHeight - newHeight);
    // --- End of boundary constraints ---

    setSize({ width: newWidth, height: newHeight });
    setPosition({ x: newX, y: newY });

  }, []);

  const handleMouseUp = useCallback(() => {
    dragState.current = null;
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  }, [handleMouseMove]);

  return {
    size,
    position,
    dragHandleProps: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'move') },
    resizeHandleProps: {
        br: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-br') },
        r: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-r') },
        b: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-b') },
        l: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-l') },
        t: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-t') },
    },
  };
};
// END OF FILE: src/hooks/useDraggableAndResizable.ts


================================================================================
### 文件路径: src/hooks/useSplitPane.ts
================================================================================

// FILE: src/hooks/useSplitPane.ts
import { useState, useCallback, useRef, MouseEvent } from 'react';

export const useSplitPane = (initialPrimarySize: number, minPrimarySize: number = 200, minSecondarySize: number = 200) => {
    const [primarySize, setPrimarySize] = useState(initialPrimarySize);
    const separatorRef = useRef<HTMLDivElement>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    const handleMouseDown = useCallback((e: MouseEvent<HTMLDivElement>) => {
        e.preventDefault();

        const startX = e.clientX;
        const startSize = primarySize;

        const handleMouseMove = (moveEvent: globalThis.MouseEvent) => {
            if (!containerRef.current) return;
            const dx = moveEvent.clientX - startX;
            const containerWidth = containerRef.current.offsetWidth;

            let newPrimarySize = startSize + dx;

            // Enforce min sizes
            if (newPrimarySize < minPrimarySize) {
                newPrimarySize = minPrimarySize;
            }
            if (containerWidth - newPrimarySize < minSecondarySize) {
                newPrimarySize = containerWidth - minSecondarySize;
            }

            setPrimarySize(newPrimarySize);
        };

        const handleMouseUp = () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    }, [primarySize, minPrimarySize, minSecondarySize]);

    return {
        primarySize,
        separatorProps: {
            ref: separatorRef,
            onMouseDown: handleMouseDown,
        },
        containerProps: {
            ref: containerRef,
        },
    };
};

// END OF FILE: src/hooks/useSplitPane.ts


================================================================================
### 文件路径: src/pages/HomePage/HomePage.css
================================================================================

/* FILE: src/pages/HomePage/HomePage.css */
.homepage-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 40px 20px;
}

.homepage-intro {
    text-align: center;
    margin-bottom: 50px;
}

.homepage-intro h2 {
    font-size: 2.8em;
    color: #303133;
    font-weight: 700;
}

.homepage-intro p {
    font-size: 1.25em;
    color: #606266;
    max-width: 700px;
    margin: 10px auto 0;
}

.topic-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 30px;
}

.topic-card-link {
    text-decoration: none;
    color: inherit;
    display: flex; /* Ensure link takes up full grid cell height */
}

/* --- [REWRITTEN] New Topic Card Styles --- */
.topic-card {
  position: relative;
  color: #2e2e2f;
  background-color: #fff;
  padding: 1.5rem;
  border-radius: 12px;
  box-shadow: rgba(99, 99, 99, 0.1) 0px 2px 8px 0px;
  border: 2px solid transparent;
  transition: all 0.3s ease-in-out;
  display: flex;
  flex-direction: column;
  width: 100%;
}

.topic-card:hover {
  box-shadow: rgba(99, 99, 99, 0.2) 0px 4px 12px 0px;
  transform: translateY(-5px);
  border-color: rgba(64, 158, 255, 0.3);
}

.topic-card-header {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.topic-card-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.topic-card-tag {
    border-radius: 100px;
    padding: 5px 12px;
    font-size: 12px;
    font-weight: 500;
    color: #ffffff;
}

/* Define a few colors for tags */
.topic-card-tag.color-1 { background-color: #409EFF; }
.topic-card-tag.color-2 { background-color: #67C23A; }
.topic-card-tag.color-3 { background-color: #E6A23C; }
.topic-card-tag.color-4 { background-color: #F56C6C; }
.topic-card-tag.color-5 { background-color: #909399; }

.topic-card-content {
    flex-grow: 1;
}

.topic-card-title {
    font-size: 1.6em;
    margin: 0 0 0.8rem 0;
    color: #303133;
    font-weight: 600;
}

.topic-card-description {
    font-size: 1em;
    line-height: 1.6;
    color: #606266;
    margin: 0;
}

.topic-card-footer {
  position: relative;
  width: 100%;
  color: #9fa4aa;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: flex-start; /* Align date to the left */
  margin-top: 1.5rem;
  padding-top: 1rem;
  border-top: 1px solid #f0f2f5;
}

.topic-card-date {
  display: flex;
  align-items: center;
  cursor: pointer;
}

.topic-card-date svg {
  margin-right: 8px;
  height: 20px;
  width: 20px;
  stroke: #9fa4aa;
}

/*// END OF FILE: src/pages/HomePage/HomePage.css*/


================================================================================
### 文件路径: src/pages/HomePage/HomePage.tsx
================================================================================

// FILE: src/pages/HomePage/HomePage.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { topics, Topic } from '../../topics';
import './HomePage.css';

const TAG_COLORS = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5'];

const TopicCard: React.FC<{ topic: Topic }> = ({ topic }) => {
    return (
        <Link to={`/topic/${topic.id}`} className="topic-card-link">
            <div className="topic-card">
                <div className="topic-card-header">
                    <div className="topic-card-tags">
                        {topic.tags.map((tag, index) => (
                            <span key={tag} className={`topic-card-tag ${TAG_COLORS[index % TAG_COLORS.length]}`}>{tag}</span>
                        ))}
                    </div>
                </div>
                <div className="topic-card-content">
                    <h3 className="topic-card-title">{topic.title}</h3>
                    <p className="topic-card-description">{topic.description}</p>
                </div>
                <div className="topic-card-footer">
                    <div className="topic-card-date">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <g strokeWidth="0" id="SVGRepo_bgCarrier"></g>
                            <g strokeLinejoin="round" strokeLinecap="round" id="SVGRepo_tracerCarrier"></g>
                            <g id="SVGRepo_iconCarrier">
                                <path strokeLinecap="round" strokeWidth="2" d="M12 8V12L15 15"></path>
                                <circle strokeWidth="2" r="9" cy="12" cx="12"></circle>
                            </g>
                        </svg>
                        {topic.date}
                    </div>
                </div>
            </div>
        </Link>
    );
};


export const HomePage: React.FC = () => {
    return (
        <div className="page-scroll-container">
            <div className="homepage-container">
                <div className="homepage-intro">
                    <h2>欢迎来到 AI 深度探索</h2>
                    <p>一个旨在通过交互式可视化和深度文章，剖析前沿AI技术的知识平台。</p>
                </div>
                <div className="topic-grid">
                    {topics.map(topic => (
                        <TopicCard key={topic.id} topic={topic} />
                    ))}
                </div>
            </div>
        </div>
    );
};

// END OF FILE: src/pages/HomePage/HomePage.tsx


================================================================================
### 文件路径: src/pages/TopicPage/TopicPage.css
================================================================================

/* FILE: src/pages/TopicPage/TopicPage.css */
.topic-page-layout {
    display: flex;
    height: 100%;
    overflow: hidden; /* Important: this container does not scroll */
}

.topic-content-area {
    flex-grow: 1;
    height: 100%;
    min-width: 0; /* Crucial for flexbox children overflow */
    display: flex;
    flex-direction: column; /* Allows child components to manage their own layout */
}

/* This is the wrapper for the actual topic component, e.g., TransformerExplorer or an article */
.topic-component-wrapper {
    flex-grow: 1;
    overflow-y: auto; /* Standard articles will scroll here */
    min-height: 0;
}

/* Specific override for components like TransformerExplorer that manage their own scrolling */
.topic-component-wrapper.no-scroll {
    overflow-y: hidden;
}

/* END OF FILE: src/pages/TopicPage/TopicPage.css */


================================================================================
### 文件路径: src/pages/TopicPage/TopicPage.tsx
================================================================================

// FILE: src/pages/TopicPage/TopicPage.tsx
import React from 'react';
import { useParams } from 'react-router-dom';
import { topics } from '../../topics';
import { TopicSidebar } from './components/TopicSidebar';
import './TopicPage.css';

export const TopicPage: React.FC = () => {
    const { topicId } = useParams<{ topicId: string }>();
    const topic = topics.find(t => t.id === topicId);

    if (!topic) {
        return <div style={{textAlign: 'center', padding: '40px'}}>专题 '{topicId}' 未找到！</div>;
    }

    const TopicComponent = topic.component;

    // Some topics like the explorers have their own internal scrolling mechanisms
    // and should not be wrapped in a scrolling container.
    const hasCustomLayout = ['transformer-explorer', 'attention-variants'].includes(topic.id);

    return (
        <div className="topic-page-layout">
            <TopicSidebar />
            <div className="topic-content-area">
                <div className={`topic-component-wrapper ${hasCustomLayout ? 'no-scroll' : ''}`}>
                    <TopicComponent />
                </div>
            </div>
        </div>
    );
};

// END OF FILE: src/pages/TopicPage/TopicPage.tsx


================================================================================
### 文件路径: src/pages/TopicPage/components/TopicSidebar.css
================================================================================

/* FILE: src/pages/TopicPage/components/TopicSidebar.css */
.topic-sidebar {
    width: 280px;
    flex-shrink: 0;
    background-color: var(--component-bg);
    border-right: 1px solid var(--border-color);
    padding: 20px;
    overflow-y: auto;
    height: 100%;
    box-sizing: border-box;
}

.sidebar-title {
    font-size: 1.2em;
    font-weight: 600;
    color: var(--text-color);
    padding-bottom: 10px;
    margin: 0 0 15px 0;
    border-bottom: 2px solid var(--highlight-color);
}

.sidebar-topic-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.sidebar-topic-item {
    margin-bottom: 5px;
}

.sidebar-topic-link {
    display: block;
    padding: 12px 15px;
    text-decoration: none;
    color: #606266;
    border-radius: 6px;
    font-size: 0.95em;
    font-weight: 500;
    transition: background-color 0.2s ease, color 0.2s ease;
    border: 1px solid transparent;
}

.sidebar-topic-link:hover {
    background-color: var(--highlight-bg);
    color: var(--highlight-color);
}

.sidebar-topic-link.active {
    background-color: var(--highlight-bg);
    color: var(--highlight-color);
    font-weight: 700;
    border-color: var(--highlight-color);
}

/* END OF FILE: src/pages/TopicPage/components/TopicSidebar.css */


================================================================================
### 文件路径: src/pages/TopicPage/components/TopicSidebar.tsx
================================================================================

// FILE: src/pages/TopicPage/components/TopicSidebar.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import { Topic, topics } from '../../../topics';
import './TopicSidebar.css';

export const TopicSidebar: React.FC = () => {
    return (
        <aside className="topic-sidebar">
            <h3 className="sidebar-title">所有专题</h3>
            <ul className="sidebar-topic-list">
                {topics.map((topic: Topic) => (
                    <li key={topic.id} className="sidebar-topic-item">
                        <NavLink
                            to={`/topic/${topic.id}`}
                            className={({ isActive }) =>
                                `sidebar-topic-link ${isActive ? 'active' : ''}`
                            }
                        >
                            {topic.title}
                        </NavLink>
                    </li>
                ))}
            </ul>
        </aside>
    );
};

// END OF FILE: src/pages/TopicPage/components/TopicSidebar.tsx


================================================================================
### 文件路径: src/topics/index.tsx
================================================================================

// FILE: src/topics/index.tsx
import React from 'react'; // 必须导入 React 才能使用 React.FC
import { TransformerExplorerTopic } from './transformer-explorer/TransformerExplorerTopic';
import { AttentionVariantsTopic } from './attention-variants/AttentionVariantsTopic';

export interface Topic {
    id: string;
    title: string;
    description: string;
    date: string;
    tags: string[];
    component: React.FC;
}

export const topics: Topic[] = [
    {
        id: 'attention-variants',
        title: '多头注意力变体: 从MHA, MQA, GQA到MLA',
        description: '通过交互式图表，深入探讨注意力机制从Multi-Head到Multi-head Latent的演进过程，直观理解其设计理念以及对KV Cache效率和性能的影响。',
        date: '2025年9月7日',
        tags: ['Attention', 'LLM', 'GQA', 'MLA', 'Visualization'],
        component: AttentionVariantsTopic,
    },
    {
        id: 'transformer-explorer',
        title: 'Transformer 深度探索器',
        description: '一个完全交互式的可视化工具，带您深入探索Transformer模型内部的数据流动、矩阵变换和数学原理。点击任何数字，追溯它的计算来源。',
        date: '2025年9月6日',
        tags: ['Transformer', 'Visualization', 'Interactive', 'PyTorch'],
        component: TransformerExplorerTopic,
    },
    // 未来可以在这里添加更多专题...
];

// [最终修复] 即使已有其他 export 语句，在 .tsx 文件中再添加一个空的 export
// 是最明确、最可靠地将其标记为模块的方式，可以彻底解决 TS1208 错误。
export {};

// END OF FILE: src/topics/index.tsx


================================================================================
### 文件路径: src/topics/attention-variants/AttentionVariantsTopic.css
================================================================================

/* FILE: src/topics/attention-variants/AttentionVariantsTopic.css */
/* This file contains all necessary styles for the attention-variants topic,
   ensuring it is fully self-contained. Many styles are adapted from the
   transformer-explorer topic to maintain visual consistency. */

/* [ADDED] Layout styles for independent scrolling columns */
.main-layout {
  display: flex;
  height: 100%;
  overflow: hidden;
  position: relative;
}
.column {
  height: 100%;
  overflow-y: auto;
  box-sizing: border-box;
}
.column-content {
    padding: 20px;
}
.column.left-column {
    border-right: 1px solid var(--border-color);
}
.column h2 {
  text-align: center;
  margin-top: 0;
  padding-bottom: 15px;
  border-bottom: 1px solid var(--border-color);
  position: sticky;
  top: -20px;
  background-color: var(--bg-color);
  z-index: 10;
}

.attention-variant-section {
    border: 3px solid var(--border-color);
    border-radius: 12px;
    margin-bottom: 25px;
    background-color: #fdfdfd;
    transition: all 0.3s ease;
    overflow: hidden;
}

.attention-variant-section.active-component {
    border-color: var(--highlight-formula-border);
    box-shadow: 0 0 20px var(--highlight-formula-bg);
}


.attention-variant-section .component-header {
    background-color: var(--component-header-bg);
    padding: 12px 20px;
    font-weight: bold;
    font-size: 1.3em;
    border-bottom: 1px solid var(--border-color);
    border-radius: 8px 8px 0 0;
}

.attention-variant-section .component-body {
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
}

/* [NEW] Styles for explanation subsections */
.explanation-subsection {
    width: 100%;
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #f0f2f5;
    border-radius: 8px;
    background: #fcfcfc;
}
.explanation-subsection h5 {
    margin-top: 0;
    font-size: 1.2em;
    color: #303133;
    border-bottom: 2px solid #e4e7ed;
    padding-bottom: 8px;
}
.explanation-subsection p, .explanation-subsection li {
    line-height: 1.7;
    color: #606266;
}
.explanation-subsection code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}
.explanation-subsection ul {
    padding-left: 20px;
}


.attention-calculation-step {
    width: 100%;
    border: 1px solid #eef;
    border-radius: 8px;
    padding: 15px;
    background-color: rgba(0,0,0,0.015);
    display: flex; /* [ADDED] For centering single matrices */
    flex-direction: column; /* [ADDED] */
    align-items: center; /* [ADDED] */
}

.step-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #303133;
    font-size: 1.1em;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px dashed var(--border-color);
}

.viz-row, .explanation-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    width: 100%;
    flex-wrap: nowrap;
    margin-bottom: 10px;
}

.viz-row.vertical, .explanation-row.vertical {
    flex-direction: column;
}


.explanation-row p {
    flex-basis: 100%;
    text-align: center;
    color: #606266;
    margin: 5px 0 15px 0;
}

.placeholder-matrix {
    opacity: 0.3;
}

/* [REWRITTEN] Robust side-label logic using CSS context */

/* Default state: bottom label */
.matrix-wrapper .matrix-label-side { display: none; }
.matrix-wrapper .matrix-label,
.matrix-wrapper .matrix-label-container {
    display: flex;
}

/* Symbolic matrix needs a separate rule for its bottom label */
.matrix-wrapper > .matrix-label {
    margin-top: 8px;
}

/* Side-label state: triggered by prop OR parent class */
.matrix-wrapper.side-label,
.viz-row.vertical .matrix-wrapper,
.explanation-row.vertical .matrix-wrapper,
.explanation-row > .matrix-wrapper:only-child {
    flex-direction: row;
    align-items: center;
    gap: 12px;
}

.matrix-wrapper.side-label .matrix-label-side,
.viz-row.vertical .matrix-wrapper .matrix-label-side,
.explanation-row.vertical .matrix-wrapper .matrix-label-side,
.explanation-row > .matrix-wrapper:only-child .matrix-label-side {
    display: flex; /* Show side label */
}

.matrix-wrapper.side-label .matrix-label-container,
.viz-row.vertical .matrix-wrapper .matrix-label-container,
.explanation-row.vertical .matrix-wrapper .matrix-label-container,
.matrix-wrapper.side-label > .matrix-label, /* Target symbolic matrix bottom label */
.viz-row.vertical .matrix-wrapper > .matrix-label,
.explanation-row.vertical .matrix-wrapper > .matrix-label,
.explanation-row > .matrix-wrapper:only-child .matrix-label-container,
.explanation-row > .matrix-wrapper:only-child > .matrix-label {
    display: none; /* Hide bottom label */
}


/* [NEW] Styles for Elementwise Operation Visualization */
.elementwise-op-container {
    width: 100%;
    padding: 10px;
    margin: 5px 0;
    border: 1px dashed #ccc;
    border-radius: 8px;
    background-color: #f8f9fa;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    box-sizing: border-box;
}
.elementwise-op-label {
    font-weight: bold;
    font-size: 1.1em;
}

/* [NEW] Styles for ElementwiseCalculation */
.elementwise-calc-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: 100%;
    font-size: 0.9em;
}
.calc-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}
.calc-label {
    color: #555;
    font-size: 0.9em;
}
.elementwise-op-row {
    display: flex;
    gap: 5px;
    border: 1px solid #ddd;
    padding: 4px;
    border-radius: 4px;
    background: #fff;
    align-items: center;
}
.elementwise-op-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease;
}
.elementwise-op-element.symbolic-ellipsis {
    border: none;
    background-color: transparent;
    color: #aaa;
    width: auto;
}
.elementwise-op-element.sum {
    width: auto;
    padding: 0 10px;
    font-weight: bold;
}
.elementwise-op-element.source, .elementwise-op-element.sum.source {
    background-color: var(--highlight-source-bg) !important;
    color: var(--highlight-source-color) !important;
    border-color: var(--highlight-source-border) !important;
}
.elementwise-op-element.target, .elementwise-op-element.sum.target {
    background-color: var(--highlight-target-bg) !important;
    color: var(--highlight-target-color) !important;
    border-color: var(--highlight-target-border) !important;
}

/* [NEW] Styles for Calculation Tooltip - specific to this topic */
.tooltip-matmul-container {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
}

/* [NEW] Styles for Summary Table */
.summary-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    font-size: 0.95em;
}

.summary-table th, .summary-table td {
    border: 1px solid #dcdfe6;
    padding: 12px 10px;
    text-align: left;
    vertical-align: top;
}

.summary-table th {
    background-color: #f5f7fa;
    font-weight: bold;
    color: #303133;
}

.summary-table tbody tr:nth-child(even) {
    background-color: #fdfdfd;
}

.summary-table td:first-child {
    font-weight: bold;
    min-width: 120px;
}

/* [ADDED & MODERNIZED] Styles for Controls panel in this topic */
.controls-container {
    display: flex;
    flex-direction: column;
    gap: 18px; /* More vertical space */
    padding: 20px;
    flex-grow: 1;
    overflow-y: auto;
}

.control-group {
    display: flex;
    justify-content: space-between; /* Label on left, input on right */
    align-items: center;
    width: 100%;
}

.control-group label {
    font-size: 0.95em;
    color: #495057; /* Darker, more professional gray */
    font-weight: 500; /* Medium weight */
    flex-shrink: 0;
    padding-right: 15px; /* Space between label and input */
    text-align: left;
}

/* Common styles for number inputs and the d_model display */
.control-group input[type="number"],
.control-group .d_k-value {
    width: 80px; /* Align the number inputs and the d_k value */
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px; /* Slightly more rounded */
    font-size: 1em;
    text-align: center;
    box-sizing: border-box;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.control-group input:focus {
    outline: none;
    border-color: #409eff; /* Accent color on focus */
    box-shadow: 0 0 0 3px rgba(64, 158, 255, 0.2); /* Subtle glow */
}

.d_k-value {
    font-weight: 600; /* Bolder */
    background-color: #f0f2f5; /* Subtle background */
    color: #303133;
    border-color: #e4e7ed;
}


/* [NEW] Styles for introduction blocks and other typography */
.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li {
    line-height: 1.7;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

/* [ADDED] For matrix overflow */
.matrix-scroll-wrapper {
    overflow-x: auto;
    padding-bottom: 10px;
    width: 100%;
}


/* END OF FILE: src/topics/attention-variants/AttentionVariantsTopic.css */


================================================================================
### 文件路径: src/topics/attention-variants/AttentionVariantsTopic.tsx
================================================================================

// FILE: src/topics/attention-variants/AttentionVariantsTopic.tsx
import React, { useState, useCallback } from 'react';
import './AttentionVariantsTopic.css';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { CalculationTooltip } from './components/CalculationTooltip';
import { useAttention } from './hooks/useAttention';
import { useSplitPane } from '../../hooks/useSplitPane';
import { HighlightState, ElementIdentifier, AttentionData, HighlightSource, TooltipState, CalculationComponent, AttentionVariantData } from './types';
import { getSymbolParts } from './lib/symbolMapping';

// =======================
//   TOOLTIP LOGIC
// =======================
const getMatrixByName = (name: string, data: AttentionData): number[][] | undefined => {
    const parts = name.split('.');
    if (parts.length < 2) return undefined;

    const variant = parts[0] as keyof AttentionData;
    const conceptualName = name.split('.').pop() || '';

    if (variant !== 'mha' && variant !== 'gqa' && variant !== 'mqa') return undefined;

    const variantData = data[variant] as AttentionVariantData;
    if (!variantData) return undefined;

    const headIndexMatch = name.match(/heads\.(\d+)/);
    const headIndex = headIndexMatch ? parseInt(headIndexMatch[1], 10) : 0;

    if (name.includes('.heads.')) {
        const headData = variantData.heads[headIndex];
        if (!headData) return undefined;
        // This is a type assertion, be careful with it.
        return headData[conceptualName as keyof typeof headData] as number[][] | undefined;
    }

    if (conceptualName === 'input') return data.input;
    if (conceptualName === 'wo') return data.Wo;
    if (conceptualName === 'combined') return variantData.CombinedOutput;
    if (conceptualName === 'output') return variantData.FinalOutput;

    // For weights like mha.wq.0
    if(parts[1]?.startsWith('w')) {
        const type = parts[1].charAt(1); // q, k, v
        const index = parseInt(parts[2] || '0', 10);
        if (type === 'q') return data.Wq[index];
        if (type === 'k') return data.Wk[index];
        if (type === 'v') return data.Wv[index];
    }


    return undefined;
};


const generateTooltipData = (element: ElementIdentifier, data: AttentionData, sources: HighlightSource[]): TooltipState | null => {
    const { name, row, col } = element;
    let opType: TooltipState['opType'] = 'info';
    let steps: TooltipState['steps'] = [];

    const targetMatrix = getMatrixByName(name, data);
    if (!targetMatrix || targetMatrix[row]?.[col] === undefined) return null;
    const targetValue = targetMatrix[row][col];

    const conceptualName = name.split('.').pop() || '';

    if (['Q', 'K', 'V', 'Scores', 'Output', 'combined', 'output'].includes(conceptualName)) {
        opType = 'matmul';
        const source1 = sources.find(s => s.highlightRow);
        const source2 = sources.find(s => s.highlightCol);
        if (source1 && source2) {
             const matrixA = getMatrixByName(source1.name, data);
             const matrixB = getMatrixByName(source2.name, data);
             if (matrixA && matrixB) {
                 const vecA = matrixA[source1.row];
                 const vecB = matrixB.map(r => r[source2.col]);
                 const components: CalculationComponent[] = vecA.map((val, i) => ({ a: val, b: vecB[i] }));
                 steps.push({
                     a: vecA,
                     b: vecB,
                     op: '·',
                     result: targetValue,
                     aSymbolInfo: getSymbolParts(source1.name),
                     bSymbolInfo: getSymbolParts(source2.name),
                     components
                 });
             }
        }
    } else if (conceptualName === 'Weights' && element.isInternal) {
        opType = 'softmax';
        const scoresName = sources.find(s => s.name.endsWith('.Scores'))?.name;
        if(scoresName){
            const matrixA = getMatrixByName(scoresName, data);
            if(matrixA) {
                const vecA = matrixA[row];
                steps.push({
                    a: vecA,
                    b: [],
                    op: 'softmax',
                    result: targetValue,
                    aSymbolInfo: getSymbolParts(scoresName),
                    bSymbolInfo: { base: '' }
                });
            }
        }
    }

    if (steps.length === 0) return null;

    const symbol = getSymbolParts(name);
    element.symbol = `${symbol.base}${symbol.subscript ? `_{${symbol.subscript}}` : ''}${symbol.superscript ? `^{${symbol.superscript}}` : ''}`;

    return { target: element, opType, steps, title: `Calculation for ${element.symbol}[${row},${col}]` };
};

// =======================
//   HIGHLIGHTING LOGIC
// =======================
const createBackwardHighlight = (element: ElementIdentifier, data: AttentionData, dims: any): HighlightState => {
    const { variant, name, row, col, isInternal } = element;
    const sources: HighlightSource[] = [];

    if (variant === 'mla') {
        return { target: element, sources: [] };
    }

    const internalDims = {
        d_head: data.mha.heads[0].Q[0].length,
        n_q_heads: data.gqa.heads.length,
        n_kv_heads_gqa: data.gqa.K_proj ? (data.gqa.K_proj[0].length / data.mha.heads[0].Q[0].length) : dims.n_kv_heads,
    };

    const conceptualName = name.split('.').pop() || '';
    const headIndexMatch = name.match(/heads\.(\d+)/);
    const headIndex = headIndexMatch ? parseInt(headIndexMatch[1], 10) : 0;

    if (isInternal) {
        const baseName = name.replace('.internal', '');
        const baseElementName = `${baseName.split('.')[0]}.heads.${headIndex}.Scores`;
        if (col === -1) {
             sources.push({ ...element, name: baseElementName, row: row, col: -1, highlightRow: true, isInternal: true });
        } else {
             sources.push({ ...element, name: `${baseName.split('.')[0]}.heads.${headIndex}.Scores`, row: row, col: col, isInternal: true });
        }
        return { target: element, sources };
    }


    if (conceptualName === 'output') {
        sources.push({ ...element, name: `${variant}.combined`, row: row, col: -1, highlightRow: true });
        sources.push({ ...element, name: `${variant}.wo`, row: -1, col: col, highlightCol: true });
    }
    else if (conceptualName === 'combined') {
        const headIndexForCol = Math.floor(col / internalDims.d_head);
        sources.push({ ...element, name: `${variant}.heads.${headIndexForCol}.Output`, row: row, col: col % internalDims.d_head });
    }
    else if (conceptualName === 'Output') {
        sources.push({ ...element, name: `${variant}.heads.${headIndex}.Weights`, row: row, col: -1, highlightRow: true });
        sources.push({ ...element, name: `${variant}.heads.${headIndex}.V`, row: -1, col: col, highlightCol: true });
    }
    else if (conceptualName === 'Weights') {
        sources.push({ ...element, name: `${variant}.heads.${headIndex}.Scores`, row: row, col: -1, highlightRow: true });
        sources.push({ ...element, name: `${name}.internal`, row: row, col: col, isInternal: true });
    }
    else if (conceptualName === 'Scores') {
        sources.push({ ...element, name: `${variant}.heads.${headIndex}.Q`, row: row, col: -1, highlightRow: true });
        sources.push({ ...element, name: `${variant}.heads.${headIndex}.K`, row: col, col: -1, highlightRow: true });
    }
    else if (['Q', 'K', 'V'].includes(conceptualName)) {
        const type = conceptualName.toLowerCase() as 'q' | 'k' | 'v';
        let weightIndex = 0;

        if (type === 'q') {
            weightIndex = headIndex;
        } else {
            if (variant === 'mha') {
                weightIndex = headIndex;
            } else if (variant === 'gqa') {
                const q_heads_per_kv_gqa = internalDims.n_q_heads / internalDims.n_kv_heads_gqa;
                weightIndex = Math.floor(headIndex / q_heads_per_kv_gqa);
            }
        }

        sources.push({ ...element, name: `${variant}.input`, row: row, col: -1, highlightRow: true });
        sources.push({ ...element, name: `${variant}.w${type}.${weightIndex}`, row: -1, col: col, highlightCol: true });
    }

    return { target: element, sources };
};


export const AttentionVariantsTopic: React.FC = () => {
    const [dims, setDims] = useState({
        seq_len: 4,
        d_model: 16,
        n_q_heads: 4,
        n_kv_heads: 2,
        d_head: 4,
    });

    const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [] });
    const [tooltip, setTooltip] = useState<TooltipState | null>(null);

    const { primarySize, separatorProps, containerProps } = useSplitPane(window.innerWidth * 0.55);

    const attentionData: AttentionData | null = useAttention(dims);

    const handleInteraction = useCallback((element: ElementIdentifier, event: React.MouseEvent) => {
        if (!attentionData) return;
        const newHighlight = createBackwardHighlight(element, attentionData, dims);
        setHighlight(newHighlight);

        const newTooltip = generateTooltipData(element, attentionData, newHighlight.sources);
        setTooltip(newTooltip);

    }, [attentionData, dims]);

    const closeTooltip = useCallback(() => setTooltip(null), []);

    if (!attentionData) {
        return <div style={{ padding: "20px", textAlign: "center" }}>正在加载或维度设置无效... (确保 d_model = n_q_heads * d_head 且 n_q_heads 能被 n_kv_heads 整除)</div>;
    }

    return (
        <div className="main-layout" {...containerProps}>
            {tooltip && <CalculationTooltip tooltip={tooltip} onClose={closeTooltip} />}
            <Controls dims={dims} setDims={setDims} />
            <div className="column left-column" style={{width: primarySize, flex: 'none'}}>
                <div className="column-content">
                    <h2>数值模拟</h2>
                    <Viz data={attentionData} dims={dims} highlight={highlight} onElementClick={handleInteraction} />
                </div>
            </div>
             <div className="split-pane-separator" {...separatorProps} />
            <div className="column right-column" style={{flex: 1}}>
                <div className="column-content">
                    <h2>理论推导</h2>
                    <Explanation dims={dims} highlight={highlight} onSymbolClick={handleInteraction} />
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/AttentionVariantsTopic.tsx


================================================================================
### 文件路径: src/topics/attention-variants/types.ts
================================================================================

// FILE: src/topics/attention-variants/types.ts
import { SymbolInfo as GenericSymbolInfo } from '../../components/visualizers/types';

// 该文件为注意力变体专题定义了所有必要的类型
export type SymbolInfo = GenericSymbolInfo;
export type Matrix = number[][];
export type Vector = number[];

// 用于标识被点击的元素
export interface ElementIdentifier {
  variant: 'mha' | 'mqa' | 'gqa' | 'mla'; // 所属的注意力变体
  name: string; // 矩阵或向量的唯一名称, e.g., "mha.heads.0.Q" or "gqa.wk.1"
  row: number;
  col: number;
  isInternal?: boolean; // True if it's part of an internal calculation visualization
  symbol?: string; // e.g., "Z_GQA"
}

// 用于定义高亮的来源
export interface HighlightSource extends ElementIdentifier {
  highlightRow?: boolean;
  highlightCol?: boolean;
}

// 全局高亮状态
export interface HighlightState {
  target: ElementIdentifier | null;
  sources: HighlightSource[];
  activeComponent?: string | null; // e.g., "mha", "gqa"
}

// 单个注意力头的计算结果
export interface AttentionHeadData {
  Q: Matrix;
  K: Matrix;
  V: Matrix;
  Scores: Matrix;
  Weights: Matrix;
  Output: Matrix;
}

// MHA, MQA, GQA 的计算结果结构
export interface AttentionVariantData {
  Q_proj: Matrix;
  K_proj: Matrix;
  V_proj: Matrix;
  heads: AttentionHeadData[];
  CombinedOutput: Matrix;
  FinalOutput: Matrix;
}

// MLA 的特定计算结果结构
export interface MLAData {
  C_kv: Matrix; // 潜在KV向量
  C_q: Matrix; // 潜在Q向量
  K_rope: Matrix; // RoPE部分的K
  // ... 其他MLA中间量，此处为简化示例
  FinalOutput: Matrix;
}

// 包含所有注意力变体计算结果的总数据结构
export interface AttentionData {
  input: Matrix;
  Wq: Matrix[]; // N_q_heads 个 Wq 矩阵
  Wk: Matrix[]; // N_kv_heads 个 Wk 矩阵
  Wv: Matrix[]; // N_kv_heads 个 Wv 矩阵
  Wo: Matrix;
  mha: AttentionVariantData;
  mqa: AttentionVariantData;
  gqa: AttentionVariantData;
  mla: MLAData; // MLA结构不同，单独定义
}

// Types for CalculationTooltip
export interface CalculationComponent {
    a: number;
    b: number;
}

export interface CalculationStep {
    a: Vector;
    b: Vector;
    op: string;
    result: number;
    aSymbolInfo: SymbolInfo;
    bSymbolInfo: SymbolInfo;
    components?: CalculationComponent[];
}

export interface TooltipState {
    target: ElementIdentifier;
    opType: 'matmul' | 'softmax' | 'info' | 'add';
    steps: CalculationStep[];
    title: string;
}


// END OF FILE: src/topics/attention-variants/types.ts


================================================================================
### 文件路径: src/topics/attention-variants/components/CalculationTooltip.tsx
================================================================================

// FILE: src/topics/attention-variants/components/CalculationTooltip.tsx
import React, { useState, useEffect, useRef } from 'react';
import { TooltipState } from '../types';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';
import { MatMulVisualizer } from '../../../components/visualizers/MatMulVisualizer';
import 'katex/dist/katex.min.css';
import { InlineMath } from 'react-katex';


interface CalculationTooltipProps {
  tooltip: TooltipState;
  onClose: () => void;
}

const formatNumber = (num: number, precision = 4) => {
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '+∞';
    const fixed = num.toFixed(precision);
    return parseFloat(fixed).toString();
};

export const CalculationTooltip: React.FC<CalculationTooltipProps> = ({ tooltip, onClose }) => {
    const [isCollapsed, setIsCollapsed] = useState(true);
    const [viewMode, setViewMode] = useState<'compact' | 'detailed'>('compact');
    const [hoveredComponentIndex, setHoveredComponentIndex] = useState<number | null>(null);
    const panelRef = useRef<HTMLDivElement>(null);

    const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
        x: 20,
        y: 20,
        width: 650,
        height: 500,
    }, panelRef);

    useEffect(() => {
        setIsCollapsed(false);
        setViewMode('compact');
        setHoveredComponentIndex(null);
    }, [tooltip]);

    // This renderVector is for the Softmax case
    const renderSimpleVector = (vec: number[], symbol: string, direction: 'row' | 'column' = 'row', focusIndex: number = -1) => {
        const visibleIndices = getVisibleIndices(vec.length, focusIndex, 1, 4);

        return (
            <div className="tooltip-vector-group">
                <span className="tooltip-symbol">{symbol} =</span>
                <div className={`tooltip-vector ${direction}`}>
                    {visibleIndices.map((idx, i) => {
                        if (idx === ELLIPSIS) {
                            return <span key={`ellipsis-${i}`} className="tooltip-element">...</span>;
                        }
                        return (
                            <span
                                key={idx}
                                className={`tooltip-element source`}
                            >
                                {formatNumber(vec[idx], 2)}
                            </span>
                        );
                    })}
                </div>
            </div>
        );
    };

    // This function specifically renders the interactive MatMul view
    const renderMatmulCompact = () => {
        const step = tooltip.steps[0];
        if (!step?.components) return null;
        const { a: vectorA, b: vectorB, result, components, aSymbolInfo, bSymbolInfo } = step;

        const visibleTermIndices = getVisibleIndices(components.length, hoveredComponentIndex ?? -1, 1, 5);

        // A specialized renderVector for the interactive part
        const renderInteractiveVector = (vec: number[], symbolInfo: TooltipState['steps'][0]['aSymbolInfo'], direction: 'row' | 'column' = 'row') => {
            let mathSymbol = symbolInfo.base;
            if (symbolInfo.subscript) mathSymbol += `_{${symbolInfo.subscript}}`;
            if (symbolInfo.superscript) mathSymbol += `^{${symbolInfo.superscript}}`;
            const dims = direction === 'row' ? `1 \\times ${vec.length}` : `${vec.length} \\times 1`;
            mathSymbol += `_{${dims}}`;

            return (
                <div className="tooltip-vector-group">
                    <div className="matrix-wrapper side-label">
                        <div className="matrix-label-side"><InlineMath math={mathSymbol} /></div>
                    </div>
                    <span className="tooltip-symbol">=</span>
                    <div className={`tooltip-vector ${direction}`}>
                        {vec.map((val, i) => (
                            <span
                                key={i}
                                className={`tooltip-element source ${hoveredComponentIndex === i ? 'highlight' : ''}`}
                            >
                                {formatNumber(val, 2)}
                            </span>
                        ))}
                    </div>
                </div>
            );
        };

        return (
            <div className="tooltip-matmul-container">
                {renderInteractiveVector(vectorA, aSymbolInfo, 'row')}
                <div className="tooltip-op-symbol">·</div>
                {renderInteractiveVector(vectorB, bSymbolInfo, 'column')}
                <div className="tooltip-result-line">
                    <span className="tooltip-op-symbol">=</span>
                    <span className="tooltip-result">{formatNumber(result, 4)}</span>
                </div>
                <div className="tooltip-calculation-detail">
                    <div className="tooltip-calc-title">点积计算分解 (Dot Product Breakdown):</div>
                    <div className="tooltip-calc-equation">
                        <div className="tooltip-braced-group">
                            <span className="tooltip-curly-brace">{'{'}</span>
                            <div className="tooltip-calc-terms-wrapper">
                                {visibleTermIndices.map((idx, i) => {
                                    if (idx === ELLIPSIS) {
                                        return <span key={`ellipsis-${i}`} className="op">...</span>;
                                    }
                                    const comp = components[idx];
                                    return (
                                        <React.Fragment key={idx}>
                                            {i > 0 && visibleTermIndices[i-1] !== ELLIPSIS && <span className="op">+</span>}
                                            <span onMouseEnter={() => setHoveredComponentIndex(idx)} onMouseLeave={() => setHoveredComponentIndex(null)}>
                                                <span className={`tooltip-calc-term ${hoveredComponentIndex === idx ? 'highlight' : ''}`}>
                                                    ({formatNumber(comp.a, 2)} <span className="op">×</span> {formatNumber(comp.b, 2)})
                                                </span>
                                            </span>
                                        </React.Fragment>
                                    );
                                })}
                            </div>
                            <span className="tooltip-curly-brace">{'}'}</span>
                        </div>
                        <span>=</span>
                        <span className="result">{formatNumber(result, 4)}</span>
                    </div>
                </div>
            </div>
        );
    };

    const renderBody = () => {
        if (!tooltip.steps || tooltip.steps.length === 0) return null;
        const step = tooltip.steps[0];
        const focusIndex = tooltip.target.col;

        switch (tooltip.opType) {
            case 'matmul':
                 if (step.components) {
                    return viewMode === 'compact' ? renderMatmulCompact() : <MatMulVisualizer vectorA={step.a} vectorB={step.b} />;
                 }
                 return <div>Matmul visualization requires components data.</div>;
             case 'add':
                 return (
                    <div className="tooltip-calculation-detail">
                        <div className="tooltip-calc-title">逐元素加法:</div>
                        <div className="tooltip-calc-equation">
                            <span>{formatNumber(step.a[0], 2)} <span className="op">+</span> {formatNumber(step.b[0], 2)}</span>
                            <span> = <span className="result">{formatNumber(step.result, 2)}</span></span>
                        </div>
                    </div>
                );
            case 'softmax':
                const finiteInputRow = step.a.filter(v => isFinite(v));
                const maxVal = finiteInputRow.length > 0 ? Math.max(...finiteInputRow) : 0;
                const exps = step.a.map(v => isFinite(v) ? Math.exp(v - maxVal) : 0);
                const sumExps = exps.reduce((a, b) => a + b, 0);
                 return (
                    <>
                        {renderSimpleVector(step.a, step.aSymbolInfo.base, 'row', focusIndex)}
                         <div className="tooltip-calculation-detail">
                            <div className="tooltip-calc-title">Softmax 计算分解 (for {tooltip.target.symbol}[{tooltip.target.row}, {tooltip.target.col}]):</div>
                            <div className="tooltip-calc-equation-multi">
                                <div>1. 减去最大值: <span>max(...) = {formatNumber(maxVal, 2)}</span></div>
                                <div>2. 计算指数: <span>e^({formatNumber(step.a[tooltip.target.col], 2)} - {formatNumber(maxVal, 2)}) = {formatNumber(exps[tooltip.target.col], 4)}</span></div>
                                <div>3. 计算所有指数之和: <span>Σ e^(...) = {formatNumber(sumExps, 4)}</span></div>
                                <div>4. 归一化: <span>{formatNumber(exps[tooltip.target.col], 4)} / {formatNumber(sumExps, 4)} = <span className="result">{formatNumber(step.result, 4)}</span></span></div>
                            </div>
                        </div>
                    </>
                );
            default:
                return <div>计算过程未定义</div>
        }
    };

    const panelStyle: React.CSSProperties = {
        top: position.y,
        left: position.x,
        width: size.width,
        height: typeof size.height === 'number' && !isCollapsed ? size.height : 'auto',
    };

    const showViewToggle = tooltip.opType === 'matmul' && tooltip.steps[0]?.components;

    return (
        <div ref={panelRef} style={panelStyle} className={`calculation-tooltip ${isCollapsed ? 'collapsed' : ''} resizable-panel`}>
            <div className="panel-header" {...dragHandleProps}>
                <span className="panel-title">{tooltip.title}</span>
                <div className="tooltip-controls">
                    {showViewToggle && (
                        <button
                            className="view-toggle-btn"
                            onClick={(e) => {
                                e.stopPropagation();
                                setViewMode(prev => prev === 'compact' ? 'detailed' : 'compact');
                            }}>
                            {viewMode === 'compact' ? '动画视图' : '交互视图'}
                        </button>
                    )}
                    <button onClick={() => setIsCollapsed(!isCollapsed)} className="tooltip-toggle-btn">
                        {isCollapsed ? '⊕' : '⊖'}
                    </button>
                    <button onClick={onClose} className="tooltip-close-btn">&times;</button>
                </div>
            </div>
             <div className="tooltip-content-wrapper">
                <div className="tooltip-body">
                   <div className="calculation-content-container">
                        {renderBody()}
                    </div>
                </div>
            </div>
            <div className="resize-handle br" {...resizeHandleProps.br}></div>
            <div className="resize-handle t" {...resizeHandleProps.t}></div>
            <div className="resize-handle r" {...resizeHandleProps.r}></div>
            <div className="resize-handle b" {...resizeHandleProps.b}></div>
            <div className="resize-handle l" {...resizeHandleProps.l}></div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/CalculationTooltip.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/Controls.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Controls.tsx
import React, { useState, useRef } from 'react';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';

interface ControlsProps {
  dims: {
    n_q_heads: number;
    n_kv_heads: number;
    d_head: number;
  };
  setDims: React.Dispatch<React.SetStateAction<any>>;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims }) => {
    const [isCollapsed, setIsCollapsed] = useState(true);
    const panelRef = useRef<HTMLDivElement>(null); // Create a ref
    const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
        x: window.innerWidth - 450,
        y: 90,
        width: 420,
        height: 200,
    }, panelRef); // Pass the ref to the hook

    const handleDimChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { id, value } = e.target;
        const numValue = parseInt(value, 10);

        setDims((prevDims: any) => {
            const newDims = { ...prevDims, [id]: numValue };

            if (id === 'n_q_heads') {
                if (numValue % newDims.n_kv_heads !== 0) {
                    let new_kv_heads = newDims.n_kv_heads;
                    while(numValue % new_kv_heads !== 0 && new_kv_heads > 1) {
                        new_kv_heads--;
                    }
                    newDims.n_kv_heads = Math.max(1, new_kv_heads);
                }
            }

            if (id === 'n_kv_heads') {
                if (newDims.n_q_heads % numValue !== 0) {
                     newDims.n_q_heads = numValue * Math.round(newDims.n_q_heads / numValue);
                     if (newDims.n_q_heads === 0) newDims.n_q_heads = numValue;
                }
            }

            newDims.d_model = newDims.n_q_heads * newDims.d_head;
            return newDims;
        });
    };

    const panelStyle: React.CSSProperties = {
        position: 'absolute',
        top: position.y,
        left: position.x,
        width: isCollapsed ? 50 : size.width,
        height: isCollapsed ? 50 : size.height,
    };

    return (
        <div ref={panelRef} style={panelStyle} className={`controls-panel ${isCollapsed ? 'collapsed' : ''} resizable-panel`}>
             <div className="panel-header" {...dragHandleProps}>
                <button className="panel-toggle-btn" onClick={() => setIsCollapsed(!isCollapsed)}>
                    {isCollapsed ? '⚙️' : '×'}
                </button>
                {!isCollapsed && <span className="panel-title">Controls</span>}
            </div>
            {!isCollapsed && (
                <div className="controls-container">
                    <div className="control-group">
                        <label htmlFor="n_q_heads">查询头 (N_q_heads)</label>
                        <input type="number" id="n_q_heads" value={dims.n_q_heads} onChange={handleDimChange} step={1} min={1} max={16} />
                    </div>
                    <div className="control-group">
                        <label htmlFor="n_kv_heads">键/值头 (N_kv_heads)</label>
                        <input type="number" id="n_kv_heads" value={dims.n_kv_heads} onChange={handleDimChange} step={1} min={1} max={dims.n_q_heads} />
                    </div>
                    <div className="control-group">
                        <label htmlFor="d_head">头维度 (d_head)</label>
                        <input type="number" id="d_head" value={dims.d_head} onChange={handleDimChange} step={2} min={2} max={32} />
                    </div>
                    <div className="control-group">
                        <label>模型维度 (d_model)</label>
                        <div className="d_k-value">{dims.n_q_heads * dims.d_head}</div>
                    </div>
                </div>
            )}
             <div className="resize-handle br" {...resizeHandleProps.br}></div>
             <div className="resize-handle t" {...resizeHandleProps.t}></div>
             <div className="resize-handle r" {...resizeHandleProps.r}></div>
             <div className="resize-handle b" {...resizeHandleProps.b}></div>
             <div className="resize-handle l" {...resizeHandleProps.l}></div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/Controls.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/Element.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isProbMax?: boolean;
}

export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick, isProbMax = false }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col;

  const isSource = highlight.sources.some(s => {
    if (s.name !== name) return false;
    if (s.highlightRow) return s.row === row;
    if (s.highlightCol) return s.col === col;
    return s.row === row && s.col === col;
  });

  const classNames = ['matrix-element'];
  if (isTarget) classNames.push('target');
  if (isSource) classNames.push('source');
  if (isProbMax) classNames.push('prob-max');

  const handleClick = (event: React.MouseEvent) => {
    // Assuming ElementIdentifier needs variant, which should be passed down or derived
    const variant = name.split('.')[0] as 'mha' | 'mqa' | 'gqa' | 'mla';
    onElementClick({ variant, name, row, col }, event);
  };

  const displayValue = () => {
      if (value === -Infinity) return '-∞';
      if (value === Infinity) return '+∞';
      return value.toFixed(2);
  }

  return (
    <div className={classNames.join(' ')} onClick={handleClick}>
      {displayValue()}
    </div>
  );
});

// END OF FILE: src/topics/attention-variants/components/Element.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/ElementwiseCalculation.tsx
================================================================================

// FILE: src/topics/attention-variants/components/ElementwiseCalculation.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier, HighlightState } from '../types';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface ElementwiseCalculationProps {
  opType: 'softmax' | 'relu';
  inputRow: number[];
  outputRow: number[];
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  baseName: string; // e.g., "mha.heads.0.Weights"
  rowIndex: number;
  variant: 'mha' | 'mqa' | 'gqa' | 'mla';
}

const formatNumber = (num: number, precision = 4) => {
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '+∞';
    return num.toFixed(precision);
}

export const ElementwiseCalculation: React.FC<ElementwiseCalculationProps> = ({
  opType,
  inputRow,
  outputRow,
  highlight,
  onElementClick,
  baseName,
  rowIndex,
  variant,
}) => {
  const targetCol = highlight.target?.isInternal && highlight.target.row === rowIndex ? highlight.target.col : -1;
  const visibleCols = getVisibleIndices(inputRow.length, targetCol);

  const handleClick = (event: React.MouseEvent, colIndex: number) => {
    onElementClick({
      variant,
      name: `${baseName}.internal`, // Special name for internal calculation
      row: rowIndex,
      col: colIndex,
      isInternal: true,
    }, event);
  };

  const isSource = (colIndex: number) => {
      // Check if the current element (or the sum) is a source in the internal calculation view
      return highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === colIndex && s.name === `${baseName}.internal`);
  }
  const isTarget = (colIndex: number) => {
      return highlight.target?.isInternal && highlight.target.row === rowIndex && highlight.target.col === colIndex;
  }


  const renderVisibleElements = (data: (number | string)[], type: 'input' | 'output' | 'exp' | 'sum') => {
    return visibleCols.map((col, i) => {
      if (col === ELLIPSIS) {
        return <div key={`ellipsis-${i}`} className="elementwise-op-element symbolic-ellipsis">...</div>;
      }
      const value = data[col];
      const className = `elementwise-op-element ${isSource(col) ? 'source' : ''} ${isTarget(col) ? 'target' : ''}`;
      return (
        <div key={`${type}-${col}`} className={className} onClick={(e) => handleClick(e, col)}>
          {typeof value === 'number' ? formatNumber(value) : value}
        </div>
      );
    });
  };

  const renderSoftmax = () => {
    // [FIXED] Filter out -Infinity for max calculation, as it's a masked value
    const finiteInputRow = inputRow.filter(v => isFinite(v));
    const maxVal = finiteInputRow.length > 0 ? Math.max(...finiteInputRow) : 0;

    const exps = inputRow.map(val => isFinite(val) ? Math.exp(val - maxVal) : 0);
    const sumExps = exps.reduce((a, b) => a + b, 0);

    const fullSumIsSource = isSource(-1); // -1 indicates whole row/sum

    return (
      <>
        {/* Step 1: exp(x - max(x)) */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(x_i - \text{max}(\mathbf{x}))" /></div>
          <div className="elementwise-op-row">
            {renderVisibleElements(exps, 'exp')}
          </div>
        </div>
        {/* Step 2: Sum */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\sum \text{exp}(\dots)" /></div>
          <div className={`elementwise-op-element sum ${fullSumIsSource ? 'source' : ''}`} onClick={(e) => handleClick(e, -1)}>
            {formatNumber(sumExps)}
          </div>
        </div>
        {/* Step 3: Division */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(\dots) / \sum" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };

  // Dummy render for other opTypes
  const renderOther = () => (
      <div>Operation {opType} detail view not implemented.</div>
  );

  return (
    <div className="elementwise-calc-container">
        {opType === 'softmax' ? renderSoftmax() : renderOther()}
    </div>
  );
};
// END OF FILE: src/topics/attention-variants/components/ElementwiseCalculation.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/ElementwiseOperation.tsx
================================================================================

// FILE: src/topics/attention-variants/components/ElementwiseOperation.tsx
import React from 'react';
import { Matrix, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { ElementwiseCalculation } from './ElementwiseCalculation';

interface ElementwiseOperationProps {
    opType: 'softmax';
    inputMatrix: Matrix;
    outputMatrix: Matrix;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    variant: 'mha' | 'mqa' | 'gqa' | 'mla';
}

export const ElementwiseOperation: React.FC<ElementwiseOperationProps> = ({
    opType,
    inputMatrix,
    outputMatrix,
    outputMatrixName,
    highlight,
    onElementClick,
    variant
}) => {
    let targetRowIndex = 0;

    if (highlight.target) {
        if (highlight.target.name === outputMatrixName || highlight.target.name.startsWith(outputMatrixName.split('.')[0] + ".heads." + outputMatrixName.split('.')[2] + ".Scores")) {
             targetRowIndex = highlight.target.row;
        } else if (highlight.target.isInternal && highlight.target.name.startsWith(outputMatrixName)) {
            targetRowIndex = highlight.target.row;
        }
    }

    const inputRow = inputMatrix[targetRowIndex] || [];
    const outputRow = outputMatrix[targetRowIndex] || [];

    const opName = opType.charAt(0).toUpperCase() + opType.slice(1);

    return (
        <div className="elementwise-op-container">
            <div className="elementwise-op-label">
                <InlineMath math={`\\text{Detailed Calculation: } \\text{${opName}}`} />
            </div>
            <p style={{margin: '0', fontSize: '0.8em', color: '#666'}}>* Showing calculation for Row {targetRowIndex}</p>
            <ElementwiseCalculation
                opType={opType}
                inputRow={inputRow}
                outputRow={outputRow}
                highlight={highlight}
                onElementClick={onElementClick}
                baseName={outputMatrixName}
                rowIndex={targetRowIndex}
                variant={variant}
            />
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/ElementwiseOperation.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/Explanation.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Explanation.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';

interface ExplanationProps {
  dims: { n_q_heads: number, n_kv_heads: number, d_head: number, d_model: number, seq_len: number };
  highlight: HighlightState;
  onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

const renderVariantExplanation = (
    variant: 'mha' | 'mqa' | 'gqa',
    dims: ExplanationProps['dims'],
    highlight: HighlightState,
    onSymbolClick: ExplanationProps['onSymbolClick']
) => {
    const { d_head, d_model, seq_len, n_q_heads } = dims;

    const q_head_name = `${variant}.heads.0.Q`;
    const k_head_name = `${variant}.heads.0.K`;
    const v_head_name = `${variant}.heads.0.V`;
    const scores_name = `${variant}.heads.0.Scores`;
    const weights_name = `${variant}.heads.0.Weights`;
    const output_head_name = `${variant}.heads.0.Output`;
    const combined_name = `${variant}.combined`;
    const final_output_name = `${variant}.output`;

    const threshold = 8;
    const break_qkv_proj = (d_model + d_head + d_head) > threshold;
    const break_scores = (d_head + seq_len + seq_len) > threshold;
    const break_output = (seq_len + d_head + d_head) > threshold;
    const break_final = (n_q_heads * d_head + d_model + d_model) > threshold;

    return (
      <>
        <div className="attention-calculation-step">
          <div className="step-title">1. 线性投影与多头拆分</div>
           <p>输入 <strong>H</strong> 乘以权重矩阵 <strong>W</strong> 生成Q, K, V。在MHA中，每个头都有独立的 <InlineMath math="W_{Q,h}, W_{K,h}, W_{V,h}"/>。而在GQA/MQA中，K, V的权重矩阵是分组共享或完全共享的。Q的权重矩阵在所有变体中始终是每个头独立的。</p>
           <div className={`explanation-row ${break_qkv_proj ? 'vertical' : ''}`}>
               <InteractiveSymbolicMatrix name={`${variant}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
               <BlockMath math="\times" />
               <InteractiveSymbolicMatrix name={`${variant}.wq.0`} rows={d_model} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
               <BlockMath math="=" />
               <InteractiveSymbolicMatrix name={q_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
            </div>
             <div className={`explanation-row ${break_qkv_proj ? 'vertical' : ''}`}>
               <InteractiveSymbolicMatrix name={`${variant}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
               <BlockMath math="\times" />
               <InteractiveSymbolicMatrix name={`${variant}.wk.0`} rows={d_model} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
               <BlockMath math="=" />
               <InteractiveSymbolicMatrix name={k_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
            </div>
             <div className={`explanation-row ${break_qkv_proj ? 'vertical' : ''}`}>
               <InteractiveSymbolicMatrix name={`${variant}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
               <BlockMath math="\times" />
               <InteractiveSymbolicMatrix name={`${variant}.wv.0`} rows={d_model} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
               <BlockMath math="=" />
               <InteractiveSymbolicMatrix name={v_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
            </div>
        </div>

        <div className="attention-calculation-step">
          <div className="step-title">2. 计算注意力分数 (Scaled Dot-Product)</div>
          <p>此步骤计算每个查询向量与所有键向量的相似度。点积结果越大，表示关联性越强。除以 <InlineMath math="\sqrt{d_{\text{head}}}" /> 是为了防止梯度在训练中过小或过大，保持数值稳定性。</p>
          <BlockMath math={"\\text{Scores}_h = \\frac{Q_h K_{\\text{group}(h)}^T}{\\sqrt{d_{\\text{head}}}}"} />
           <div className={`explanation-row ${break_scores ? 'vertical' : ''}`}>
                <InteractiveSymbolicMatrix name={q_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                <BlockMath math="\times" />
                <InteractiveSymbolicMatrix name={k_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} transpose={true} />
                <BlockMath math="=" />
                <InteractiveSymbolicMatrix name={scores_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onSymbolClick} />
           </div>
           <p>然后，应用Softmax函数将原始分数转换为一个和为1的概率分布，即“注意力权重” <InlineMath math="A_h"/>。</p>
           <BlockMath math={"A_h = \\text{Softmax}(\\text{Scores}_h)"} />
            <InteractiveSymbolicMatrix name={weights_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true} />
        </div>

        <div className="attention-calculation-step">
            <div className="step-title">3. 加权求和得到单头输出</div>
            <p>使用上一步计算出的注意力权重 <InlineMath math="A_h"/> 对值向量 <InlineMath math="V_h"/> 进行加权求和，得到融合了上下文信息的单头输出 <InlineMath math="H_h"/>。</p>
             <div className={`explanation-row ${break_output ? 'vertical' : ''}`}>
                  <InteractiveSymbolicMatrix name={weights_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onSymbolClick} />
                  <BlockMath math="\times" />
                  <InteractiveSymbolicMatrix name={v_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                  <BlockMath math="=" />
                  <InteractiveSymbolicMatrix name={output_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
             </div>
        </div>

        <div className="attention-calculation-step">
            <div className="step-title">4. 合并与最终投影</div>
            <p>将所有 <InlineMath math="N_q"/> 个头的输出 <InlineMath math="H_h"/> 拼接（Concatenate）起来，然后通过一个最终的线性投影矩阵 <InlineMath math="W^O"/> 将其维度变回 <InlineMath math="d_{\text{model}}"/>，得到该子层的最终输出 <InlineMath math="Z"/>。</p>
            <BlockMath math={"Z = \\text{Concat}(\\text{head}_0, ..., \\text{head}_{N_q-1}) W_O"} />
            <div className={`explanation-row ${break_final ? 'vertical' : ''}`}>
                <InteractiveSymbolicMatrix name={combined_name} rows={seq_len} cols={n_q_heads * d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                <BlockMath math="\times" />
                <InteractiveSymbolicMatrix name={`${variant}.wo`} rows={n_q_heads * d_head} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                <BlockMath math="=" />
                <InteractiveSymbolicMatrix name={final_output_name} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
            </div>
        </div>
      </>
    )
}

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight, onSymbolClick }) => {
  const { n_q_heads, n_kv_heads, d_head, d_model } = dims;

  return (
    <div>
        <div className="math-block">
            <h3>引言</h3>
            <p>在深度学习，特别是自然语言处理(NLP)领域，注意力机制(Attention Mechanism)是一个非常重要的概念。注意力机制的起源可以追溯到对生物视觉注意力的模拟以及神经机器翻译的实际需求。Bahdanau等人的工作首次将注意力机制引入自然语言处理领域；而Transformer架构则将注意力机制推向了一个新的高度，使其成为现代自然语言处理的核心技术之一。</p>
            <p>Transformer架构的出现可以说是全球人工智能快速发展的转折点，该架构由Encoder和Decoder两部分组成，其中Encoder部分发展成了Bert、Roberta等模型，Decoder部分发展成了GPT等生成式大模型。此类模型效果强悍，并得到了广泛的应用，这进一步推动了注意力机制的发展。</p>
            <p>然而，随着模型规模的不断扩大和上下文长度的日益增长，传统的注意力机制在推理阶段面临着巨大的计算和内存挑战。特别是，自回归生成任务中<strong>Key-Value (KV) Cache</strong>的指数级增长成为了瓶颈，极大地限制了大型语言模型(LLM)的吞吐量和可服务性。为了解决这些挑战，研究者们不断探索和提出了各种注意力变体，旨在优化性能、降低成本，并提升LLM在实际应用中的效率。</p>
        </div>
        <div className="attention-variant-section">
            <div className="component-header">变量定义</div>
            <div className="component-body">
                <div className="explanation-subsection">
                  <p>在深入探讨各种注意力机制之前,我们首先统一定义本文中将使用的变量。明确的变量命名有助于我们精确地理解每个计算步骤的含义。</p>
                    <ul>
                        <li><strong>基础维度 (Basic Dimensions)</strong>
                            <ul>
                                <li><InlineMath math="B"/>: 批处理大小 (Batch Size)</li>
                                <li><InlineMath math="S"/>: 序列长度 (Sequence Length)</li>
                                <li><InlineMath math="d_{model}"/>: 模型的隐藏层维度 (Hidden Dimension)</li>
                                <li><InlineMath math="N_{q\_heads}"/>: 查询头的数量 (Number of Query Heads)</li>
                                <li><InlineMath math="N_{kv\_heads}"/>: 键/值头的数量 (Number of Key/Value Heads)</li>
                                <li><InlineMath math="d_{head}"/>: 每个注意力头的维度, 通常 <InlineMath math="d_{head} = d_{model} / N_{q\_heads}"/></li>
                            </ul>
                        </li>
                        <li><strong>张量与向量 (Tensors & Vectors)</strong>
                            <ul>
                                <li><InlineMath math="H \in \mathbb{R}^{B \times S \times d_{model}}"/>: 输入张量</li>
                                <li><InlineMath math="W_Q, W_K, W_V \in \mathbb{R}^{d_{model} \times d_{model}}"/>: MHA的总投影矩阵</li>
                                <li><InlineMath math="W_O \in \mathbb{R}^{d_{model} \times d_{model}}"/>: 输出投影矩阵</li>
                            </ul>
                        </li>
                         <li><strong>精细化QKV向量 (Granular QKV Vectors)</strong>
                            <ul>
                                <li><InlineMath math="q_{t,h} \in \mathbb{R}^{d_{head}}"/>: 位置t, 头h的查询(Query)向量</li>
                                <li><InlineMath math="k_{j,h} \in \mathbb{R}^{d_{head}}"/>: 位置j, 头h的键(Key)向量</li>
                                <li><InlineMath math="v_{j,h} \in \mathbb{R}^{d_{head}}"/>: 位置j, 头h的值(Value)向量</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>


        <div className="attention-variant-section">
            <div className="component-header">MHA (Multi-Head Attention)</div>
            <div className="component-body">
                <div className="explanation-subsection">
                    <h5>出现原因与设计思路</h5>
                    <p><strong>单头注意力的局限性:</strong> 传统的单头注意力(Single-Head Attention)虽然能捕捉到输入元素之间的关系，但它只能在一个单一的、固定的表示空间中进行。这意味着模型在处理复杂信息时能力可能会受限，难以同时关注到输入序列中不同层面（例如语法结构、语义关系等）的细微特征。</p>
                    <p><strong>并行化与多视角学习:</strong> MHA通过引入多个“注意力头”，将输入的原始维度 <InlineMath math="d_{model}"/> 分割成 <InlineMath math="N_{q\_heads}"/> 个更小的子空间。每个头独立地在自己的子空间中执行注意力计算，学习不同的注意力模式。这种设计允许模型从多个“视角”去理解输入信息，例如，一个头可能关注长距离依赖，另一个头可能关注局部语义，从而捕获更丰富、更复杂的上下文信息。</p>
                </div>
                <div className="explanation-subsection">
                    <h5>交互式公式推导 (以头0为例)</h5>
                    {renderVariantExplanation('mha', dims, highlight, onSymbolClick)}
                </div>
                <div className="explanation-subsection">
                    <h5>KV Cache: 概念、变化与牺牲</h5>
                    <p><strong>概念与作用:</strong> 在LLM的自回归生成阶段，模型每次生成一个token，然后将新token附加到序列中。为避免重复计算前序token的Key和Value向量，KV Cache会将这些计算过的K/V向量存储起来，在后续步骤中直接复用，从而<strong>节省了大量的计算时间</strong>。这是一种典型的“<strong>以空间换时间</strong>”的优化策略。</p>
                    <p><strong>显存占用:</strong> KV Cache最大的牺牲就是显存。在MHA中，每个查询头都有独立的K/V头 (<InlineMath math={`N_q=${n_q_heads}, N_{kv}=${n_q_heads}`}/>)。因此，KV Cache的大小与查询头的数量成正比，公式为：</p>
                    <BlockMath math={"\\text{Cache}_{\\text{MHA}} \\propto S \\times N_{q\\_\\text{heads}} \\times d_{\\text{head}} = S \\times d_{\\text{model}}"} />
                    <p>对于Llama3 70B模型(L=80, <InlineMath math="N_{q\_heads}=64"/>, <InlineMath math="d_{head}=128"/>, 16位精度)，当批处理大小 <InlineMath math="B=8"/> 且序列长度 <InlineMath math="S=1000"/> 时，KV Cache大小约为 <strong>20.97 GB</strong>，随着序列长度线性增长，这很快成为瓶颈。</p>
                </div>
            </div>
        </div>

        <div className="attention-variant-section">
            <div className="component-header">GQA (Grouped-Query Attention)</div>
             <div className="component-body">
                <div className="explanation-subsection">
                    <h5>出现原因与设计思路</h5>
                    <p>GQA是MHA和MQA之间的折中方案。它认识到MHA的KV头可能存在冗余，而MQA的单一KV头又可能限制了模型性能。因此，GQA将查询头分组，每组共享一对K/V头，旨在保持接近MHA性能的同时，有效减少KV Cache。</p>
                    <p><strong>分组机制:</strong> GQA的核心思想是将 <InlineMath math="N_{q\_heads}"/> 个查询头平均分配到 <InlineMath math="N_{kv\_heads}"/> 个组中。通过调整组的数量，GQA可以灵活地在MHA(<InlineMath math="N_{kv\_heads} = N_{q\_heads}"/>)和MQA(<InlineMath math="N_{kv\_heads} = 1"/>)之间进行权衡。</p>
                </div>
                <div className="explanation-subsection">
                    <h5>交互式公式推导 (以头0为例)</h5>
                    {renderVariantExplanation('gqa', dims, highlight, onSymbolClick)}
                </div>
                <div className="explanation-subsection">
                     <h5>KV Cache: 变化与牺牲</h5>
                    <p><strong>显存占用:</strong> 在GQA中，查询头被分成 {n_kv_heads}$ 组，每组共享一个K/V头 (<InlineMath math={`N_q=${n_q_heads}, N_{kv}=${n_kv_heads}`}/>)。KV Cache只存储 <InlineMath math="N_{kv\_heads}"/> 份Key和Value，大小减少为MHA的 <InlineMath math={`${n_kv_heads}/${n_q_heads}`}/> 倍。</p>
                    <BlockMath math={"\\text{Cache}_{\\text{GQA}} \\propto S \\times N_{kv\\_\\text{heads}} \\times d_{\\text{head}}"} />
                    <p>以Llama3 70B为例，若采用GQA并设置 <InlineMath math="N_{kv\_heads}=8"/>，KV Cache将减少8倍，从20.97 GB降至约 <strong>2.62 GB</strong>，这是一个显著的优化。</p>
                    <p><strong>牺牲:</strong> GQA的牺牲主要是设计复杂性和需要对组数 <InlineMath math="N_{kv\_heads}"/> 进行超参数调优。虽然性能显著优于MQA，但理论上仍可能略低于MHA。</p>
                </div>
            </div>
        </div>

        <div className="attention-variant-section">
            <div className="component-header">MQA (Multi-Query Attention)</div>
            <div className="component-body">
                <div className="explanation-subsection">
                    <h5>出现原因与设计思路</h5>
                    <p>面对MHA高昂的KV Cache成本，MQA提出了一种极致的解决方案：让所有查询头共享<strong>同一份</strong>Key和Value。</p>
                    <p><strong>最大化共享:</strong> MQA的核心是将 <InlineMath math="N_{kv\_heads}"/> 降至1，即所有 <InlineMath math="N_{q\_heads}"/> 个查询头共享同一组Key和Value矩阵。这意味着模型只需要计算和存储一套Key和Value。</p>
                </div>
                <div className="explanation-subsection">
                    <h5>交互式公式推导 (以头0为例)</h5>
                    {renderVariantExplanation('mqa', dims, highlight, onSymbolClick)}
                </div>
                 <div className="explanation-subsection">
                    <h5>KV Cache: 变化与牺牲</h5>
                    <p><strong>显存占用:</strong> 在MQA中，所有查询头共享唯一的K/V头 (<InlineMath math={`N_q=${n_q_heads}, N_{kv}=1`}/>)。这使得KV Cache的大小减少为MHA的 <InlineMath math={`1/${n_q_heads}`}/> 倍，极大地节省了内存。</p>
                    <BlockMath math={"\\text{Cache}_{\\text{MQA}} \\propto S \\times 1 \\times d_{\\text{head}}"} />
                     <p>以Llama3 70B为例，当 <InlineMath math="N_{q\_heads}=64"/> 时，KV Cache将减少64倍，从约20.97 GB降至约 <strong>327.6 MB</strong>。这是一个非常显著的内存节省。</p>
                     <p><strong>牺牲:</strong> MQA的牺牲主要是<strong>模型性能</strong>。由于所有注意力头共享相同的K和V信息，它们无法像MHA那样从多样化的K/V子空间中学习，可能导致表达能力下降或收敛速度变慢。</p>
                </div>
            </div>
        </div>

        <div className="attention-variant-section">
            <div className="component-header">MLA (Multi-head Latent Attention)</div>
            <div className="component-body">
                 <div className="explanation-subsection">
                    <h5>出现原因与设计思路</h5>
                    <p><strong>GQA的局限:</strong> 尽管MQA和GQA在KV Cache优化方面取得了显著进展，但它们仍受限于将原始高维KV信息直接绑定到注意力头的数量。当追求更长的上下文时，即使是GQA的KV Cache仍然可能过大。</p>
                    <p><strong>低秩压缩与矩阵吸收:</strong> MLA (来自DeepSeek-V2) 是一种更激进的优化。其核心思想是：</p>
                    <ul>
                        <li><strong>低秩压缩KV:</strong> MLA假设Key和Value的原始高维表示中存在大量冗余，其有效信息可以被压缩到一个低维的“潜在空间”。它通过一个下投影矩阵将每个token的 <InlineMath math="d_{model}"/> 维隐藏状态投影成一个极小的共享潜在向量 <InlineMath math="c^{KV}"/>。KV Cache只存储这些低维向量。</li>
                        <li><strong>“矩阵吸收”实现计算效率:</strong> MLA利用矩阵乘法结合律的巧妙特性，将重建K、V所需的上投影矩阵“吸收”到Query侧的计算中，从而在推理时避免K、V的显式高维重建，直接在低维潜在空间进行部分计算。</li>
                        <li><strong>解耦RoPE兼容性:</strong> 为兼容“矩阵吸收”技巧，MLA将Q、K向量解耦为<strong>内容(Content)部分</strong>和<strong>RoPE部分</strong>。内容部分采用低秩压缩；RoPE部分则独立处理，通常采用类似MQA的共享K方式。</li>
                    </ul>
                </div>
                <div className="explanation-subsection">
                    <h5>实现方法与数学推导 (推理阶段)</h5>
                    <p>MLA在推理阶段是其效率提升的核心。通过“矩阵吸收”技巧，它可以避免显式的高维投影和重建K、V。</p>
                    <p><strong>1. 缓存内容:</strong> 在推理时，MLA只缓存两个低维的、所有头共享的向量：共享内容潜在向量 <InlineMath math="c_j^{KV} \in \mathbb{R}^{d_c}"/> 和共享RoPE键向量 <InlineMath math="k_j^R \in \mathbb{R}^{d_r}"/>。</p>
                    <p><strong>2. “矩阵吸收”技巧:</strong> 核心思想是将K侧的升维矩阵预先与Q侧的投影矩阵组合。训练时内容分数计算为 <InlineMath math="\text{score}^C \propto (c_t^Q W_{UQ,h}) \cdot (c_j^{KV} W_{UK,h})^T"/>。在推理时，利用矩阵乘法结合律重排：</p>
                    <BlockMath math={"\\text{score}_{t,j,h}^C = c_t^Q (W_{UQ,h} W_{UK,h}^T) (c_j^{KV})^T"}/>
                    <p>其中，矩阵 <InlineMath math="M_h^K = W_{UQ,h} W_{UK,h}^T"/> 可以在模型加载后<strong>预先计算并存储</strong>。因此，推理时只需用当前的 <InlineMath math="c_t^Q"/> 与预计算的 <InlineMath math="M_h^K"/> 相乘，再与缓存的 <InlineMath math="c_j^{KV}"/> 计算点积，极大地降低了计算量。</p>
                </div>
                <div className="explanation-subsection">
                    <h5>KV Cache: 变化与牺牲</h5>
                    <p><strong>显存占用:</strong> MLA实现了迄今为止最为极致的KV Cache压缩。其KV Cache只存储低维的潜在向量。</p>
                    <BlockMath math={"\\text{KV Cache Size (MLA)} = L \\times B \\times S \\times (d_c + d_r) \\times \\text{sizeof(float)}"}/>
                    <p>以DeepSeek-V2的参数为例(<InlineMath math="d_{model}=7168, d_c=512, d_r=64"/>)，MLA可以将KV Cache大小压缩到MHA的约<strong>1/25</strong>。对于Llama3 70B大小的模型，KV Cache可以从20.97 GB降至约 <strong>0.83 GB</strong>。</p>
                    <p><strong>牺牲:</strong> MLA的牺牲主要体现在<strong>模型结构和训练的复杂性</strong>。引入了多阶段投影、内容与RoPE解耦等机制，代码实现和理解难度增加，并可能导致训练不稳定，需要特殊的优化策略来稳定训练过程。</p>
                </div>
            </div>
        </div>

        <div className="attention-variant-section">
            <div className="component-header">总结: 从MHA到MLA的演进之路</div>
            <div className="component-body">
                <table className="summary-table">
                    <thead>
                        <tr>
                            <th>特性</th>
                            <th>MHA (Multi-Head Attention)</th>
                            <th>MQA (Multi-Query Attention)</th>
                            <th>GQA (Grouped-Query Attention)</th>
                            <th>MLA (Multi-head Latent Attention)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>核心思想</strong></td>
                            <td>并行多子空间学习</td>
                            <td>极致KV共享，压缩Cache</td>
                            <td>在性能和效率间折中</td>
                            <td>低秩压缩KV，推理时吸收权重</td>
                        </tr>
                        <tr>
                            <td><strong>KV头数量</strong></td>
                            <td><InlineMath math="N_{q\_heads}"/></td>
                            <td>1</td>
                            <td><InlineMath math="N_{kv\_heads}"/> (1 ≤ <InlineMath math="N_{kv\_heads}"/> ≤ <InlineMath math="N_{q\_heads}"/>)</td>
                            <td>推理时等效为1个共享<strong>潜在</strong>K/V</td>
                        </tr>
                        <tr>
                            <td><strong>KV Cache大小 (相对MHA)</strong></td>
                            <td>1x</td>
                            <td><InlineMath math="1/N_{q\_heads}"/></td>
                            <td><InlineMath math="N_{kv\_heads}/N_{q\_heads}"/></td>
                            <td>极小 (约1/25至1/60)</td>
                        </tr>
                        <tr>
                            <td><strong>优点</strong></td>
                            <td>强大的表达能力，训练效果佳</td>
                            <td>极低的KV Cache，显著加速推理</td>
                            <td>灵活的性能-效率权衡，性能接近MHA</td>
                            <td>极致的KV Cache压缩，同时保持高性能</td>
                        </tr>
                         <tr>
                            <td><strong>缺点</strong></td>
                            <td>KV Cache巨大，推理瓶颈</td>
                            <td>可能损失模型性能</td>
                            <td>实现复杂度略增，需调参</td>
                            <td>结构复杂，训练难度高</td>
                        </tr>
                        <tr>
                            <td><strong>适用场景</strong></td>
                            <td>训练，对性能要求高的场景</td>
                            <td>对推理速度和显存极度敏感的场景</td>
                            <td>大多数现代大模型的通用选择</td>
                            <td>对效率和性能都有极致要求的超长序列场景</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/topics/attention-variants/components/Explanation.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/InteractiveSymbolicElement.tsx
================================================================================

// FILE: src/topics/attention-variants/components/InteractiveSymbolicElement.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { HighlightState } from '../types';
import { useHighlighting } from '../hooks/useHighlighting';

interface InteractiveSymbolicElementProps {
  name: string;
  base: string;
  subscript?: string;
  row?: number;
  col?: number;
  highlight: HighlightState;
  onClick: (event: React.MouseEvent) => void;
}

export const InteractiveSymbolicElement: React.FC<InteractiveSymbolicElementProps> = React.memo(({ name, base, subscript, row, col, highlight, onClick }) => {
  const { isTarget, isSource } = useHighlighting(name, row ?? 0, col ?? 0, highlight);

  const elementBase = base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
  const subscriptContent = [subscript, row, col].filter(s => s !== undefined && s !== null).join(',');
  const mathString = `${elementBase}_{${subscriptContent}}`;

  const className = `symbolic-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''}`;

  return (
    <div className={className} onClick={onClick} style={{cursor: 'pointer'}}>
      <InlineMath math={mathString} />
    </div>
  );
});

// END OF FILE: src/topics/attention-variants/components/InteractiveSymbolicElement.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/InteractiveSymbolicMatrix.tsx
================================================================================

// FILE: src/topics/attention-variants/components/InteractiveSymbolicMatrix.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';
import { getSymbolParts } from '../lib/symbolMapping';

interface InteractiveSymbolicMatrixProps {
  name: string;
  rows: number;
  cols: number;
  highlight: HighlightState;
  onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  transpose?: boolean;
  isPlaceholder?: boolean;
  sideLabel?: boolean; // For explicit side-labeling
}

export const InteractiveSymbolicMatrix: React.FC<InteractiveSymbolicMatrixProps> = React.memo(({ name, rows, cols, highlight, onSymbolClick, transpose = false, isPlaceholder = false, sideLabel = false }) => {
  const symbol = getSymbolParts(name);
  const variant = name.split('.')[0] as ElementIdentifier['variant'];

  const displayRows = transpose ? cols : rows;
  const displayCols = transpose ? rows : cols;

  let focusRow = -1;
  let focusCol = -1;

  if (highlight.target?.name === name) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const isTargetMatrix = !!highlight.target && highlight.target.name === name;
  const isSourceMatrix = highlight.sources.some(s => s.name === name);
  const shouldShowHeaders = isTargetMatrix || isSourceMatrix;

  const visibleRowIndices = getVisibleIndices(displayRows, transpose ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, transpose ? focusRow : focusCol);

  let mathSymbol = symbol.base;
  if (symbol.superscript) mathSymbol += `^{${symbol.superscript}}`;
  if (transpose) mathSymbol += '^T';

  const subscriptParts = [];
  if (symbol.subscript) subscriptParts.push(symbol.subscript);
  subscriptParts.push(`${rows} \\times ${cols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;

  const containerClassName = `symbolic-matrix-container ${isPlaceholder ? 'placeholder-matrix' : ''}`;

  const matrixGrid = (
    <div className={containerClassName}>
       <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: shouldShowHeaders ? `auto repeat(${visibleColIndices.length}, auto)` : `repeat(${visibleColIndices.length}, auto)` }}>
        {/* Top-left corner & Column Headers */}
        {shouldShowHeaders && <div key="corner" />}
        {shouldShowHeaders && visibleColIndices.map((c, cIdx) => (
            <div key={`ch-${cIdx}`} className="symbolic-header-item">{c}</div>
        ))}

        {/* Row Headers and Matrix Elements */}
        {visibleRowIndices.map((r, rIdx) => (
            <React.Fragment key={`row-frag-${rIdx}`}>
                 {shouldShowHeaders && <div className="symbolic-header-item">{r}</div>}
                 {visibleColIndices.map((c, cIdx) => {
                    if (r === ELLIPSIS || c === ELLIPSIS) {
                      return <div key={`ellipsis-r${rIdx}-c${cIdx}`} className="symbolic-ellipsis">{r === ELLIPSIS && c === ELLIPSIS ? '⋱' : '…'}</div>;
                    }
                     const originalRow = transpose ? c : r;
                     const originalCol = transpose ? r : c;
                    return (
                      <InteractiveSymbolicElement
                        key={`elem-r${r}-c${c}`}
                        name={name}
                        base={symbol.base}
                        subscript={symbol.subscript}
                        row={originalRow}
                        col={originalCol}
                        highlight={highlight}
                        onClick={(event) => onSymbolClick({ variant, name, row: originalRow, col: originalCol }, event)}
                      />
                    );
                })}
            </React.Fragment>
        ))}
      </div>
    </div>
  );

  // [MODIFIED] Always render both label structures and let CSS handle visibility
  return (
    <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`}>
        <div className="matrix-label-side"><InlineMath math={`${mathSymbol}`} /></div>
        {matrixGrid}
        <div className="matrix-label"><InlineMath math={`${mathSymbol}`} /></div>
    </div>
  );
});

// END OF FILE: src/topics/attention-variants/components/InteractiveSymbolicMatrix.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/Matrix.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';
import { getSymbolParts } from '../lib/symbolMapping';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  sideLabel?: boolean; // For explicit side-labeling when not in a vertical row
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, sideLabel = false }) => {
  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const numRows = data.length;
  const numCols = data[0].length;

  let focusRow = -1;
  let focusCol = -1;

  const isTargetMatrix = !!highlight.target && highlight.target.name === name;
  const isSourceMatrix = highlight.sources.some(s => s.name === name);
  const shouldShowHeaders = isTargetMatrix || isSourceMatrix;

  if (isTargetMatrix) {
    focusRow = highlight.target!.row;
    focusCol = highlight.target!.col;
  } else if (isSourceMatrix) {
      const relevantSource = highlight.sources.find(s => s.name === name)!;
      focusRow = relevantSource.row === -1 ? focusRow : relevantSource.row;
      focusCol = relevantSource.col === -1 ? focusCol : relevantSource.col;
  }

  const visibleRowIndices = getVisibleIndices(numRows, focusRow);
  const visibleColIndices = getVisibleIndices(numCols, focusCol);

  const symbolParts = getSymbolParts(name);
  let mathSymbol = symbolParts.base;
  if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
  if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;

  const matrixGrid = (
      <div className="matrix-container">
        <div className="matrix-grid" style={{ gridTemplateColumns: shouldShowHeaders ? `auto repeat(${visibleColIndices.length}, auto)` : `repeat(${visibleColIndices.length}, auto)` }}>
            {/* Top-left corner & Column Headers */}
            {shouldShowHeaders && <div key="corner" />}
            {shouldShowHeaders && visibleColIndices.map((c, cIdx) => (
                <div key={`ch-${cIdx}`} className="matrix-header-item">{c}</div>
            ))}

            {/* Row Headers & Matrix Elements */}
            {visibleRowIndices.map((r, rIdx) => (
                <React.Fragment key={`row-frag-${rIdx}`}>
                    {shouldShowHeaders && <div className="matrix-header-item">{r}</div>}
                    {visibleColIndices.map((c, cIdx) => {
                      if (r === ELLIPSIS) {
                        return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                      }
                      if (c === ELLIPSIS) {
                        return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">…</div>;
                      }
                      return (
                        <Element
                          key={`${name}-${r}-${c}`}
                          name={name}
                          row={r}
                          col={c}
                          value={data[r][c]}
                          highlight={highlight}
                          onElementClick={onElementClick}
                        />
                      );
                    })}
                </React.Fragment>
            ))}
        </div>
      </div>
  );

  // [MODIFIED] Always render both label structures and let CSS handle visibility
  // The `side-label` class here is for explicit override when needed.
  return (
    <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`} data-name={name}>
        {/* Side label (hidden by default, shown via CSS context) */}
        <div className="matrix-label-side">
            <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
        </div>

        {matrixGrid}

        {/* Bottom label (shown by default, hidden via CSS context) */}
        <div className="matrix-label-container">
            <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
        </div>
    </div>
  );
};
// END OF FILE: src/topics/attention-variants/components/Matrix.tsx


================================================================================
### 文件路径: src/topics/attention-variants/components/Viz.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Viz.tsx
import React from 'react';
import { AttentionData, HighlightState, ElementIdentifier, AttentionVariantData } from '../types';
import { Matrix } from './Matrix';
import { BlockMath } from 'react-katex';
import { ElementwiseOperation } from './ElementwiseOperation';
import 'katex/dist/katex.min.css'; // [FIXED] Import KaTeX CSS to fix rendering issues

interface VizProps {
  data: AttentionData;
  dims: { n_q_heads: number, n_kv_heads: number, d_head: number, d_model: number, seq_len: number };
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

const AttentionVariantViz: React.FC<{
    variantName: 'mha' | 'mqa' | 'gqa';
    title: string;
    variantData: AttentionVariantData;
    commonData: { input: any; Wo: any; Wq: any; Wk: any; Wv: any };
    dims: { n_q_heads: number, n_kv_heads: number, d_head: number, d_model: number, seq_len: number };
    highlight: HighlightState;
    onElementClick: VizProps['onElementClick'];
}> = ({ variantName, title, variantData, commonData, dims, highlight, onElementClick }) => {

    const headData = variantData.heads[0];
    const { d_model, d_head, seq_len, n_q_heads } = dims;

    // [MODIFIED] Layout breaking logic now sums the columns of ALL matrices in the row for more accurate wrapping.
    const threshold = 15;
    const break_qkv_proj = (d_model + d_head + d_head) > threshold;
    const break_scores = (d_head + seq_len + seq_len) > threshold;
    const break_output = (seq_len + d_head + d_head) > threshold;
    const break_final = (n_q_heads * d_head + d_model + d_model) > threshold;

    const q_head_name = `${variantName}.heads.0.Q`;
    const k_head_name = `${variantName}.heads.0.K`;
    const v_head_name = `${variantName}.heads.0.V`;
    const scores_name = `${variantName}.heads.0.Scores`;
    const weights_name = `${variantName}.heads.0.Weights`;
    const output_head_name = `${variantName}.heads.0.Output`;

    // For head 0, the kv group is always 0
    const wq_name = `${variantName}.wq.0`;
    const wk_name = `${variantName}.wk.0`;
    const wv_name = `${variantName}.wv.0`; // V projection also needs a name

    return (
        <div className="attention-variant-section">
            <div className="component-header">{title}</div>
            <div className="component-body">

                <div className="attention-calculation-step">
                    <div className="step-title">1. 生成 Q, K, V (以头 0 为例)</div>
                     <div className={`viz-row ${break_qkv_proj ? 'vertical' : ''}`}>
                        <Matrix name={`${variantName}.input`} data={commonData.input} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="\times" />
                        <Matrix name={wq_name} data={commonData.Wq[0]} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="=" />
                        <Matrix name={q_head_name} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className={`viz-row ${break_qkv_proj ? 'vertical' : ''}`}>
                        <Matrix name={`${variantName}.input`} data={commonData.input} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="\times" />
                        <Matrix name={wk_name} data={commonData.Wk[0]} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="=" />
                        <Matrix name={k_head_name} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className={`viz-row ${break_qkv_proj ? 'vertical' : ''}`}>
                        <Matrix name={`${variantName}.input`} data={commonData.input} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="\times" />
                        <Matrix name={wv_name} data={commonData.Wv[0]} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="=" />
                        <Matrix name={v_head_name} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="attention-calculation-step">
                    <div className="step-title">2. 计算注意力分数 (头 0)</div>
                     <div className={`viz-row ${break_scores ? 'vertical' : ''}`}>
                        <Matrix name={q_head_name} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="\times" />
                        <Matrix name={k_head_name} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="=" />
                        <Matrix name={scores_name} data={headData.Scores} highlight={highlight} onElementClick={onElementClick} />
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.Scores}
                        outputMatrix={headData.Weights}
                        outputMatrixName={weights_name}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        variant={variantName}
                    />
                     <Matrix name={weights_name} data={headData.Weights} highlight={highlight} onElementClick={onElementClick} sideLabel={true}/>
                </div>

                <div className="arrow-down">↓</div>

                <div className="attention-calculation-step">
                    <div className="step-title">3. 加权求和 (头 0)</div>
                    <div className={`viz-row ${break_output ? 'vertical' : ''}`}>
                        <Matrix name={weights_name} data={headData.Weights} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="\times" />
                        <Matrix name={v_head_name} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="=" />
                        <Matrix name={output_head_name} data={headData.Output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="attention-calculation-step">
                    <div className="step-title">4. 合并与最终投影</div>
                     <div className={`viz-row ${break_final ? 'vertical' : ''}`}>
                        <Matrix name={`${variantName}.combined`} data={variantData.CombinedOutput} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="\times" />
                        <Matrix name={`${variantName}.wo`} data={commonData.Wo} highlight={highlight} onElementClick={onElementClick} />
                        <BlockMath math="=" />
                        <Matrix name={`${variantName}.output`} data={variantData.FinalOutput} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};


export const Viz: React.FC<VizProps> = ({ data, dims, highlight, onElementClick }) => {
  const commonData = { input: data.input, Wo: data.Wo, Wq: data.Wq, Wk: data.Wk, Wv: data.Wv };

  return (
    <div>
        <AttentionVariantViz variantName="mha" title="MHA (Multi-Head Attention)" variantData={data.mha} commonData={commonData} dims={dims} highlight={highlight} onElementClick={onElementClick} />
        <AttentionVariantViz variantName="gqa" title="GQA (Grouped-Query Attention)" variantData={data.gqa} commonData={commonData} dims={dims} highlight={highlight} onElementClick={onElementClick} />
        <AttentionVariantViz variantName="mqa" title="MQA (Multi-Query Attention)" variantData={data.mqa} commonData={commonData} dims={dims} highlight={highlight} onElementClick={onElementClick} />
    </div>
  );
};
// END OF FILE: src/topics/attention-variants/components/Viz.tsx


================================================================================
### 文件路径: src/topics/attention-variants/hooks/useAttention.ts
================================================================================

// FILE: src/topics/attention-variants/hooks/useAttention.ts
import { useMemo } from 'react';
import { AttentionData } from '../types';
import { calculateAttentionVariants } from '../lib/attention';

interface Dims {
  seq_len: number;
  d_model: number;
  d_head: number;
  n_q_heads: number;
  n_kv_heads: number;
}

export const useAttention = (dims: Dims): AttentionData | null => {
  return useMemo(() => {
    try {
      return calculateAttentionVariants(dims);
    } catch (e) {
      console.error("在注意力计算中发生错误:", e);
      return null;
    }
  }, [dims]);
};

// END OF FILE: src/topics/attention-variants/hooks/useAttention.ts


================================================================================
### 文件路径: src/topics/attention-variants/hooks/useHighlighting.ts
================================================================================

// FILE: src/topics/attention-variants/hooks/useHighlighting.ts
import { useMemo } from 'react';
import { HighlightState } from '../types';

export const useHighlighting = (
  name: string,
  row: number,
  col: number,
  highlight: HighlightState
) => {
  return useMemo(() => {
    const { target, sources } = highlight;

    const isTarget =
      !!target &&
      target.name === name &&
      target.row === row &&
      target.col === col;

    const isSource = sources.some(s => {
      if (s.name !== name) return false;
      if (s.highlightRow) return s.row === row;
      if (s.highlightCol) return s.col === col;
      return s.row === row && s.col === col;
    });

    return { isTarget, isSource };
  }, [name, row, col, highlight]);
};

// END OF FILE: src/topics/attention-variants/hooks/useHighlighting.ts


================================================================================
### 文件路径: src/topics/attention-variants/lib/attention.ts
================================================================================

// FILE: src/topics/attention-variants/lib/attention.ts
import { AttentionData, AttentionVariantData, Matrix, Vector } from '../types';

// ----------------- 辅助数学函数 -----------------

const createMatrix = (rows: number, cols: number, seed: number): Matrix => {
    const random = createSeededRandom(seed);
    return Array.from({ length: rows }, () => Array.from({ length: cols }, () => parseFloat(random().toFixed(2))));
};

const createSeededRandom = (seed: number) => {
    let state = seed;
    return () => {
        state = (state * 9301 + 49297) % 233280;
        return (state / 233280.0) * 2 - 1;
    };
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
  const rowsA = A.length, colsA = A[0].length, colsB = B[0].length;
  const C: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));
  for (let i = 0; i < rowsA; i++) {
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      C[i][j] = sum;
    }
  }
  return C;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => A.map(row => row.map(val => val * scalar));

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row);
        const exps = row.map(val => Math.exp(val - maxVal));
        const sumExps = exps.reduce((a, b) => a + b, 0);
        return exps.map(exp => exp / sumExps);
    });
};

const concatMatricesHorizontally = (...matrices: Matrix[]): Matrix => {
    const numRows = matrices[0].length;
    const result: Matrix = Array(numRows).fill(0).map(() => []);
    for (let i = 0; i < numRows; i++) {
        for (const matrix of matrices) {
            result[i].push(...matrix[i]);
        }
    }
    return result;
};

// ----------------- 核心计算逻辑 -----------------

interface Dims {
  seq_len: number;
  d_model: number;
  d_head: number;
  n_q_heads: number;
  n_kv_heads: number;
}

function calculateAttention(input: Matrix, Wq: Matrix[], Wk: Matrix[], Wv: Matrix[], Wo: Matrix, dims: Dims, n_kv_heads_variant: number): AttentionVariantData {
    const { seq_len, d_head, n_q_heads } = dims;
    const q_heads_per_kv = n_q_heads / n_kv_heads_variant;

    const Q_proj = concatMatricesHorizontally(...Wq.map(wq => multiplyMatrices(input, wq)));
    const K_proj = concatMatricesHorizontally(...Wk.slice(0, n_kv_heads_variant).map(wk => multiplyMatrices(input, wk)));
    const V_proj = concatMatricesHorizontally(...Wv.slice(0, n_kv_heads_variant).map(wv => multiplyMatrices(input, wv)));

    const heads = [];
    for (let i = 0; i < n_q_heads; i++) {
        const q_head = Q_proj.map(row => row.slice(i * d_head, (i + 1) * d_head));

        const kv_group_index = Math.floor(i / q_heads_per_kv);
        const k_head = K_proj.map(row => row.slice(kv_group_index * d_head, (kv_group_index + 1) * d_head));
        const v_head = V_proj.map(row => row.slice(kv_group_index * d_head, (kv_group_index + 1) * d_head));

        const k_head_T = k_head[0].map((_, colIndex) => k_head.map(row => row[colIndex]));

        const scores = scaleMatrix(multiplyMatrices(q_head, k_head_T), 1 / Math.sqrt(d_head));
        const weights = softmaxByRow(scores);
        const output = multiplyMatrices(weights, v_head);

        heads.push({ Q: q_head, K: k_head, V: v_head, Scores: scores, Weights: weights, Output: output });
    }

    const CombinedOutput = concatMatricesHorizontally(...heads.map(h => h.Output));
    const FinalOutput = multiplyMatrices(CombinedOutput, Wo);

    return { Q_proj, K_proj, V_proj, heads, CombinedOutput, FinalOutput };
}

export const calculateAttentionVariants = (dims: Dims): AttentionData | null => {
    const { seq_len, d_model, d_head, n_q_heads, n_kv_heads } = dims;

    if (d_model !== n_q_heads * d_head) return null; // 确保维度匹配

    // 1. 生成固定的输入和权重矩阵，确保可复现性
    const input = createMatrix(seq_len, d_model, 1);
    const Wq = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_model, d_head, 10 + i));
    const Wk = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_model, d_head, 100 + i));
    const Wv = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_model, d_head, 200 + i));
    const Wo = createMatrix(d_model, d_model, 999);

    // 2. 计算 MHA, MQA, GQA
    const mha = calculateAttention(input, Wq, Wk, Wv, Wo, dims, n_q_heads);
    const mqa = calculateAttention(input, Wq, Wk, Wv, Wo, dims, 1);
    const gqa = calculateAttention(input, Wq, Wk, Wv, Wo, dims, n_kv_heads);

    // 3. 计算 MLA (简化模拟)
    // 实际 MLA 复杂得多，这里我们只模拟其最终效果和概念
    const mla = {
        C_kv: createMatrix(seq_len, 32, 300), // 低秩潜在向量
        C_q: createMatrix(seq_len, 32, 400),
        K_rope: createMatrix(seq_len, 16, 500),
        FinalOutput: createMatrix(seq_len, d_model, 600)
    };

    return { input, Wq, Wk, Wv, Wo, mha, mqa, gqa, mla };
};

// END OF FILE: src/topics/attention-variants/lib/attention.ts


================================================================================
### 文件路径: src/topics/attention-variants/lib/symbolMapping.ts
================================================================================

// FILE: src/topics/attention-variants/lib/symbolMapping.ts
interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

export const getSymbolParts = (name: string): SymbolParts => {
    const parts = name.split('.');
    const variant = parts[0] as 'mha' | 'mqa' | 'gqa';

    // Handle weight matrices like 'gqa.wq.0'
    if (parts.length === 3 && parts[1].startsWith('w')) {
        const type = parts[1].charAt(1).toUpperCase(); // Q, K, V
        const index = parts[2];
        return { base: 'W', superscript: type, subscript: index };
    }

    // Handle 'gqa.wo'
    if (parts.length === 2 && parts[1] === 'wo') {
        return { base: 'W', superscript: 'O' };
    }

    // Handle head-specific matrices like 'mha.heads.0.Q'
    if (parts.length === 4 && parts[1] === 'heads') {
        const headIndex = parts[2];
        const type = parts[3]; // Q, K, V, Scores, Weights, Output

        const baseMap: { [key: string]: string } = {
            'Q': 'Q', 'K': 'K', 'V': 'V',
            'Scores': 'S', 'Weights': 'A', 'Output': 'H'
        };

        return { base: baseMap[type] || '?', subscript: headIndex };
    }

    // Handle top-level matrices like 'mha.input' or 'gqa.output'
    if (parts.length === 2) {
        const type = parts[1];
        if (type === 'input') return { base: 'H' };
        if (type === 'combined') return { base: 'H', subscript: 'cat' };
        if (type === 'output') return { base: 'Z', subscript: variant.toUpperCase() };
    }

    // Default fallback
    return { base: 'X' };
};
// END OF FILE: src/topics/attention-variants/lib/symbolMapping.ts


================================================================================
### 文件路径: src/topics/attention-variants/utils/matrixView.ts
================================================================================

// FILE: src/topics/attention-variants/utils/matrixView.ts
export const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12;

export const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {

  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }

  const visible = new Set<number>();

  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }

  // [NEW] Also include the middle index when there's no specific focus
  if (focusIndex === -1 && totalSize >= MIN_SIZE_FOR_TRUNCATION) {
    visible.add(Math.floor((totalSize - 1) / 2));
  }

  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }

  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];

  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }

  return result;
};
// END OF FILE: src/topics/attention-variants/utils/matrixView.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/TransformerExplorerTopic.css
================================================================================

/* FILE: src/topics/transformer-explorer/TransformerExplorerTopic.css */
/* This file contains all necessary styles for the transformer-explorer topic,
   ensuring it is fully self-contained. */

.main-layout {
  display: flex;
  gap: 20px;
  flex-grow: 1;
  overflow: hidden;
  padding: 20px;
  min-height: 0;
  position: relative;
}

.column {
  flex: 1;
  background: var(--component-bg);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
  overflow-y: auto;
  min-height: 0;
  min-width: 0;
}

.column-content {
  padding: 20px;
}

.column.left-column {
  flex: 1.4;
}

.column h2 {
  font-size: 1.6em;
  margin: -20px -20px 20px -20px;
  padding: 20px 20px 15px 20px;
  text-align: center;
  color: #000;
  position: sticky;
  top: -21px;
  background: inherit;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
  border-radius: 12px 12px 0 0;
}

.diagram-component {
  border: 2px solid var(--border-color);
  border-radius: 10px;
  margin-bottom: 15px;
  background-color: #fdfdfd;
  transition: all 0.3s ease;
}

.diagram-component .component-header {
    cursor: pointer;
    transition: background-color 0.3s ease;
}
.diagram-component .component-header:hover {
    background-color: #f0f2f5;
}
.diagram-component.active {
    border-color: var(--highlight-formula-border) !important;
    box-shadow: 0 0 30px var(--highlight-formula-bg) !important;
    transform: scale(1.01);
}

.component-header {
  background-color: var(--component-header-bg);
  padding: 8px 15px;
  font-weight: bold;
  font-size: 1.1em;
  border-bottom: 1px solid var(--border-color);
  border-radius: 8px 8px 0 0;
}
.component-body {
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  width: 100%;
  box-sizing: border-box;
}

.arrow-down {
  width: 100%;
  text-align: center;
  font-size: 24px;
  color: var(--arrow-color);
  margin: 5px 0;
}

.matrix-wrapper {
    position: relative;
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    vertical-align: middle;
}

/* Side-label logic for transformer-explorer */
.matrix-wrapper .matrix-label-side { display: none; }
.matrix-wrapper .matrix-label-container { display: flex; }
.matrix-wrapper > .matrix-label {
    display: flex;
    justify-content: center;
    margin-top: 8px;
}

.matrix-wrapper.side-label,
.viz-formula-row.vertical .matrix-wrapper,
.viz-formula-row > .matrix-wrapper:only-child,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper,
.component-body > .matrix-wrapper
{
    flex-direction: row;
    align-items: center;
    gap: 12px;
}

.matrix-wrapper.side-label .matrix-label-side,
.viz-formula-row.vertical .matrix-wrapper .matrix-label-side,
.viz-formula-row > .matrix-wrapper:only-child .matrix-label-side,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper .matrix-label-side,
.component-body > .matrix-wrapper .matrix-label-side {
    display: flex;
}

.matrix-wrapper.side-label .matrix-label-container,
.matrix-wrapper.side-label > .matrix-label,
.viz-formula-row.vertical .matrix-wrapper .matrix-label-container,
.viz-formula-row.vertical .matrix-wrapper > .matrix-label,
.viz-formula-row > .matrix-wrapper:only-child .matrix-label-container,
.viz-formula-row > .matrix-wrapper:only-child > .matrix-label,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper .matrix-label-container,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper > .matrix-label,
.component-body > .matrix-wrapper .matrix-label-container,
.component-body > .matrix-wrapper > .matrix-label {
    display: none;
}

.matrix-container {
  display: inline-block;
  border: 1px solid #ccc;
  padding: 5px;
  border-radius: 4px;
  background-color: #f9f9f9;
}
.matrix-grid {
  display: grid;
  gap: 3px;
}

.matrix-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
  z-index: 2;
  font-weight: normal;
}

.matrix-ellipsis {
    width: 45px;
    height: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #aaa;
    font-size: 1.2em;
    font-family: monospace;
}

.matrix-element:hover {
  transform: scale(1.1);
  border-color: #007bff;
  box-shadow: 0 0 5px rgba(0,123,255,0.5);
  z-index: 5;
}

.matrix-element.source {
  background-color: var(--highlight-source-bg);
  color: var(--highlight-source-color);
  border: 1.5px solid var(--highlight-source-border);
}
.matrix-element.target {
  background-color: var(--highlight-target-bg);
  color: var(--highlight-target-color);
  border: 1.5px solid var(--highlight-target-border);
}

.matrix-element.prob-max {
    box-shadow: 0 0 8px 2px var(--highlight-target-border);
    font-weight: bold;
    transform: scale(1.15);
    z-index: 6;
}

.matrix-element.destination {
  background-color: var(--highlight-formula-bg);
  border: 1px solid var(--highlight-formula-border);
}

.matrix-label-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}

.matrix-label {
  text-align: center;
  font-weight: bold;
  font-family: monospace;
  font-size: 1.1em;
  margin: 0;
}

.matrix-symbol-tag {
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    font-size: 1.1em;
    border: 1px solid #ced4da;
    line-height: 1;
    font-family: 'Times New Roman', serif;
}

.op-symbol {
    font-size: 1.6em; /* [MODIFIED] Reduced size */
    font-weight: bold;
    color: #909399;
    align-self: center;
    margin: 0 5px; /* [MODIFIED] Reduced margin */
}

.matrix-header-item, .symbolic-header-item {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5;
    color: #909399;
    font-family: monospace;
    font-size: 0.8em;
    font-weight: bold;
    border-radius: 2px;
    padding: 2px;
    box-sizing: border-box;
    min-height: 15px;
}
.symbolic-header-item {
    background-color: transparent;
}


.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block.active {
  border-color: var(--highlight-formula-border) !important;
  box-shadow: 0 0 30px var(--highlight-bg) !important;
  transform: scale(1.01);
  background-color: var(--highlight-formula-bg);
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li, .math-block h5 {
    line-height: 1.7;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.math-block h5 {
    font-size: 1.1em;
    margin-top: 1.5em;
    margin-bottom: 0.5em;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

.formula-display {
    display: flex;
    justify-content: center; /* [MODIFIED] Changed from flex-start to center */
    align-items: center;
    gap: 15px;
    overflow-x: auto;
    margin: 20px 0;
    padding: 15px 10px;
    background-color: rgba(0,0,0,0.02);
    border-radius: 8px;
    flex-wrap: wrap;
}
.formula-display > * {
    flex-shrink: 0;
}
.formula-display.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.katex-display {
    margin: 0.5em 0 !important;
}

.matrix-scroll-wrapper {
    overflow-x: auto;
    padding: 5px;
    flex-shrink: 0;
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.symbolic-matrix-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.symbolic-matrix-grid {
    display: grid;
    gap: 2px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f9f9f9;
}
.symbolic-element, .symbolic-ellipsis {
    min-width: 60px;
    min-height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9em;
    border-radius: 2px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    transition: all 0.2s ease-in-out;
}
.symbolic-ellipsis {
    border-style: dashed;
    color: #aaa;
}
.symbolic-element.source {
  background-color: var(--highlight-source-bg);
  border-color: var(--highlight-source-border);
}
.symbolic-element.target {
  background-color: var(--highlight-target-bg);
  border-color: var(--highlight-target-border);
}
.symbolic-element.destination {
    background-color: var(--highlight-formula-bg);
    border-color: var(--highlight-formula-border);
}

.viz-formula-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    padding: 15px 10px;
    border: 1px solid #eef;
    border-radius: 8px;
    background-color: rgba(0,0,0,0.015);
    gap: 5px;
    box-sizing: border-box;
}
.viz-formula-group > * {
    flex-shrink: 0;
}
.viz-formula-row {
    display: flex;
    align-items: center;
    gap: 15px;
    justify-content: center;
    width: max-content;
    padding: 0 5px;
    flex-wrap: nowrap;
}
.viz-formula-row.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.viz-formula-row > * {
    flex-shrink: 0;
}

.viz-step-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #606266;
    margin-top: 10px;
    margin-bottom: 5px;
    font-size: 0.9em;
    border-bottom: 1px solid #eef;
    padding-bottom: 5px;
}
.viz-formula-group .viz-step-title {
    margin-top: -5px;
    margin-bottom: 10px;
}

.residual-block {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px 10px;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #fcfcfc;
}
.residual-block:hover {
    border-color: var(--highlight-formula-border);
    background-color: var(--highlight-formula-bg);
}
.residual-icon {
    font-size: 1.6em;
    font-weight: bold;
    color: var(--arrow-color);
    line-height: 1;
}
.residual-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
}
.residual-matrix-symbol {
    font-size: 1.2em;
}
.residual-matrix-dims {
    font-size: 0.8em;
    color: #666;
    font-family: monospace;
}
.residual-block.active {
    border-color: var(--highlight-formula-border);
    border-style: solid;
    box-shadow: 0 0 15px var(--highlight-formula-bg);
    transform: scale(1.05);
}
.residual-block.active .residual-icon {
    color: var(--highlight-formula-border);
}

.add-norm-component-body {
    flex-direction: column;
}

.add-norm-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
}

.token-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 5px;
    cursor: pointer;
    border-radius: 4px;
    border: 2px solid transparent;
    transition: all 0.2s ease-in-out;
}
.token-container:hover {
    transform: scale(1.05);
    background-color: rgba(0,0,0,0.02);
}
.token-container.target {
    border-color: var(--highlight-target-border);
    background-color: var(--highlight-target-bg);
}
.token-container.source {
    border-color: var(--highlight-source-border);
    background-color: var(--highlight-source-bg);
}
.token-text {
    padding: 4px 8px;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-family: monospace;
    font-size: 1.05em;
    min-width: 25px;
    text-align: center;
}
.token-id {
    padding: 2px 6px;
    background-color: #e9ecef;
    border: 1px solid #ced4da;
    border-radius: 10px;
    font-size: 0.8em;
    color: #495057;
}

.token-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
}

.decoding-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
}
.decoding-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
}

.embedding-lookup-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
    width: 100%;
    position: relative;
    padding: 10px;
    box-sizing: border-box;
}
.embedding-lookup-container.vertical {
    flex-direction: column;
}
.embedding-lookup-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}
.embedding-lookup-svg path {
    fill: none;
    stroke-width: 2px;
    stroke: var(--arrow-color);
    stroke-dasharray: 5 5;
    transition: all 0.3s ease;
}
.embedding-lookup-svg path.highlighted {
    stroke: var(--highlight-target-border);
    stroke-width: 3px;
    stroke-dasharray: none;
}
.embedding-lookup-column {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
    flex-shrink: 0;
}
.embedding-lookup-vocab {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    min-width: 0;
}


/* Upgraded Calculation Tooltip Styles */
.calculation-tooltip {
    /* [MODIFIED] max-width removed to allow wide content */
    width: auto;
    font-size: 0.95em;
    /* Other properties like position, z-index, etc., are inherited from .resizable-panel in App.css */
}
.tooltip-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #eee;
    padding: 8px 15px;
    margin: 0;
    cursor: default;
}
.tooltip-title {
    font-weight: bold;
    font-size: 1.1em;
}
.tooltip-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}
.tooltip-toggle-btn, .tooltip-close-btn {
    background: none;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
    color: #999;
    padding: 0 5px;
    line-height: 1;
}
.tooltip-toggle-btn:hover, .tooltip-close-btn:hover {
    color: #333;
}
.tooltip-content-wrapper {
    transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
    max-height: 500px;
    overflow: hidden;
}
.calculation-tooltip.collapsed .tooltip-content-wrapper {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
}
.tooltip-body {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 15px;
}
.tooltip-vector-group {
    display: flex;
    align-items: center;
    gap: 8px;
}
.tooltip-symbol {
    font-family: 'Times New Roman', serif;
    font-weight: bold;
    font-size: 1.2em;
}
.tooltip-vector {
    display: flex;
    gap: 4px;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 2px 4px;
    background-color: #f9f9f9;
    overflow-x: auto;
}
.tooltip-element {
    padding: 2px 4px;
    background-color: #fff;
    border-radius: 2px;
    font-family: monospace;
    transition: all 0.2s ease;
}
.tooltip-element.highlight {
    background-color: var(--highlight-formula-bg);
    border: 1px solid var(--highlight-formula-border);
    transform: scale(1.1);
}
.tooltip-op-symbol {
    font-size: 1.5em;
    font-weight: bold;
    padding: 0 10px;
}
.tooltip-result-line {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1.1em;
}
.tooltip-result {
    padding: 2px 6px;
    border-radius: 4px;
    background-color: var(--highlight-target-bg);
    border: 1px solid var(--highlight-target-border);
    color: var(--highlight-target-color);
    font-weight: bold;
}
.tooltip-calculation-detail {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #eee;
}
.tooltip-calc-title {
    font-weight: bold;
    font-size: 0.9em;
    color: #333;
    margin-bottom: 8px;
    font-family: sans-serif;
}
.tooltip-calc-equation, .tooltip-calc-equation-multi {
    font-family: monospace;
    font-size: 0.95em;
    color: #555;
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto;
    white-space: pre-wrap;
}
.tooltip-calc-equation .op {
    color: #c0392b;
    font-weight: bold;
}
.tooltip-calc-equation .result {
    font-weight: bold;
    color: var(--highlight-target-color);
}
.tooltip-calc-term {
    transition: background-color 0.2s ease;
    border-radius: 3px;
    padding: 1px 3px;
}
.tooltip-calc-term.highlight {
    background-color: var(--highlight-formula-bg);
}
.tooltip-calc-equation-multi {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

/* [REVISED] Modernized styles for Controls panel */
.controls-container {
    display: flex;
    flex-direction: column;
    gap: 18px; /* More vertical space */
    padding: 20px;
    flex-grow: 1;
    overflow-y: auto;
}

.control-group {
    display: flex;
    justify-content: space-between; /* Label on left, input on right */
    align-items: center;
    width: 100%;
}

.control-group label {
    font-size: 0.95em;
    color: #495057; /* Darker, more professional gray */
    font-weight: 500; /* Medium weight */
    flex-shrink: 0;
    padding-right: 15px; /* Space between label and input */
}

/* Common styles for number inputs and the d_k display */
.control-group input[type="number"],
.control-group .d_k-value {
    width: 80px; /* Align the number inputs and the d_k value */
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px; /* Slightly more rounded */
    font-size: 1em;
    text-align: center;
    box-sizing: border-box;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

/* Specific style for text input */
.control-group input[type="text"] {
    flex-grow: 1; /* Allow text input to fill remaining space */
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 1em;
    box-sizing: border-box;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

/* Specific focus state for all interactive inputs */
.control-group input:focus {
    outline: none;
    border-color: #409eff; /* Accent color on focus */
    box-shadow: 0 0 0 3px rgba(64, 158, 255, 0.2); /* Subtle glow */
}

/* Style for the read-only d_k value */
.d_k-value {
    font-weight: 600; /* Bolder */
    background-color: #f0f2f5; /* Subtle background */
    color: #303133;
    border-color: #e4e7ed;
}
/* END OF FILE: src/topics/transformer-explorer/TransformerExplorerTopic.css */


================================================================================
### 文件路径: src/topics/transformer-explorer/TransformerExplorerTopic.tsx
================================================================================

// FILE: src/topics/transformer-explorer/TransformerExplorerTopic.tsx
import React, { useState, useCallback, useEffect, useRef } from 'react';
import './TransformerExplorerTopic.css';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { CalculationTooltip } from './components/CalculationTooltip';
import { useTransformer } from './hooks/useTransformer';
import { useSplitPane } from '../../hooks/useSplitPane';
import { ElementIdentifier, HighlightSource, HighlightState, TransformerData, TooltipState, Matrix, CalculationComponent } from './types';
import { MATRIX_NAMES } from './config/matrixNames';
import { getSymbolParts } from './config/symbolMapping';


// ============================================================================
// [COPIED] 从旧 App.tsx 复制过来的辅助函数
// ============================================================================

const getLayerAndHeadIndices = (name: string): [number, number] => {
    const layerIdxMatch = name.match(/\.(encoder|decoder)\.(\d+)/);
    const layerIdx = layerIdxMatch ? parseInt(layerIdxMatch[2], 10) : 0;
    const headIdxMatch = name.match(/\.h(\d+)\./);
    const headIdx = headIdxMatch ? parseInt(headIdxMatch[1], 10) : 0;
    return [layerIdx, headIdx];
};

const getMatrixByName = (name: string, data: TransformerData, l: number, h: number): Matrix | undefined => {
    const LNe = MATRIX_NAMES.layer(l);
    const HNe = MATRIX_NAMES.head(l, h);
    const LNd = MATRIX_NAMES.decoderLayer(l);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(l, h);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(l, h);

    if (name === MATRIX_NAMES.inputEmbeddings) return data.inputEmbeddings;
    if (name === MATRIX_NAMES.posEncodings) return data.posEncodings;
    if (name === MATRIX_NAMES.outputEmbeddings) return data.outputEmbeddings;
    if (name === MATRIX_NAMES.decoderPosEncodings) return data.decoderPosEncodings;
    if (name === MATRIX_NAMES.finalEncoderOutput) return data.finalEncoderOutput;
    if (name === MATRIX_NAMES.logits) return data.logits;
    if (name === MATRIX_NAMES.outputProbabilities) return data.outputProbabilities;
    if (name === MATRIX_NAMES.finalLinear) return data.finalLinear;

    const encLayer = data.encoderLayers[l];
    if (encLayer) {
        if (name === LNe.encoder_input) return encLayer.encoder_input;
        if (name === LNe.mha_output) return encLayer.mha_output;
        if (name === LNe.Wo) return encLayer.mha.Wo;
        if (name === LNe.add_norm_1_output) return encLayer.add_norm_1_output;
        if (name === LNe.ffn_output) return encLayer.ffn_output;
        if (name === LNe.add_norm_2_output) return encLayer.add_norm_2_output;
        if (name === LNe.Intermediate) return encLayer.ffn.Intermediate;
        if (name === LNe.Activated) return encLayer.ffn.Activated;
        if (name === LNe.W1) return encLayer.ffn.W1;
        if (name === LNe.b1) return [encLayer.ffn.b1];
        if (name === LNe.W2) return encLayer.ffn.W2;
        if (name === LNe.b2) return [encLayer.ffn.b2];
        const encHead = encLayer.mha.heads[h];
        if (encHead) {
            if (name === HNe.Wq) return encHead.Wq;
            if (name === HNe.Wk) return encHead.Wk;
            if (name === HNe.Wv) return encHead.Wv;
            if (name === HNe.Q) return encHead.Q;
            if (name === HNe.K) return encHead.K;
            if (name === HNe.V) return encHead.V;
            if (name === HNe.Scores) return encHead.Scores;
            if (name === HNe.ScaledScores) return encHead.ScaledScores;
            if (name === HNe.AttentionWeights) return encHead.AttentionWeights;
            if (name === HNe.HeadOutput) return encHead.HeadOutput;
        }
    }

    const decLayer = data.decoderLayers[l];
    if (decLayer) {
        if (name === LNd.decoder_input) return decLayer.decoder_input;
        if (name === LNd.masked_mha_output) return decLayer.masked_mha_output;
        if (name === LNd.Wo_masked) return decLayer.masked_mha.Wo;
        if (name === LNd.add_norm_1_output) return decLayer.add_norm_1_output;
        if (name === LNd.enc_dec_mha_output) return decLayer.enc_dec_mha.output;
        if (name === LNd.Wo_enc_dec) return decLayer.enc_dec_mha.Wo;
        if (name === LNd.add_norm_2_output) return decLayer.add_norm_2_output;
        if (name === LNd.ffn_output) return decLayer.ffn_output;
        if (name === LNd.add_norm_3_output) return decLayer.add_norm_3_output;
        if (name === LNd.Intermediate) return decLayer.ffn.Intermediate;
        if (name === LNd.Activated) return decLayer.ffn.Activated;
        if (name === LNd.W1) return decLayer.ffn.W1;
        if (name === LNd.b1) return [decLayer.ffn.b1];
        if (name === LNd.W2) return decLayer.ffn.W2;
        if (name === LNd.b2) return [decLayer.ffn.b2];
        const maskedMhaHead = decLayer.masked_mha.heads[h];
        if (maskedMhaHead) {
            if (name === HNd_masked.Wq) return maskedMhaHead.Wq;
            if (name === HNd_masked.Wk) return maskedMhaHead.Wk;
            if (name === HNd_masked.Wv) return maskedMhaHead.Wv;
            if (name === HNd_masked.Q) return maskedMhaHead.Q;
            if (name === HNd_masked.K) return maskedMhaHead.K;
            if (name === HNd_masked.V) return maskedMhaHead.V;
            if (name === HNd_masked.Scores) return maskedMhaHead.Scores;
            if (name === HNd_masked.ScaledScores) return maskedMhaHead.ScaledScores;
            if (name === HNd_masked.AttentionWeights) return maskedMhaHead.AttentionWeights;
            if (name === HNd_masked.HeadOutput) return maskedMhaHead.HeadOutput;
        }
        const encDecMhaHead = decLayer.enc_dec_mha.heads[h];
        if (encDecMhaHead) {
            if (name === HNd_encdec.Wq) return encDecMhaHead.Wq;
            if (name === HNd_encdec.Wk) return encDecMhaHead.Wk;
            if (name === HNd_encdec.Wv) return encDecMhaHead.Wv;
            if (name === HNd_encdec.Q) return encDecMhaHead.Q;
            if (name === HNd_encdec.K) return encDecMhaHead.K;
            if (name === HNd_encdec.V) return encDecMhaHead.V;
            if (name === HNd_encdec.Scores) return encDecMhaHead.Scores;
            if (name === HNd_encdec.ScaledScores) return encDecMhaHead.ScaledScores;
            if (name === HNd_encdec.AttentionWeights) return encDecMhaHead.AttentionWeights;
            if (name === HNd_encdec.HeadOutput) return encDecMhaHead.HeadOutput;
        }
    }
    return undefined;
}

const generateTooltipData = (element: ElementIdentifier, transformerData: TransformerData, sources: HighlightSource[]): TooltipState | null => {
    const { name, row, col, isInternal } = element;
    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    let opType: TooltipState['opType'] = 'info';
    let steps: TooltipState['steps'] = [];

    const baseName = isInternal ? name.replace('.internal', '') : name;
    const targetMatrix = getMatrixByName(baseName, transformerData, layerIdx, headIdx);
    const targetValue = targetMatrix?.[row]?.[col] ?? 0;

    const matmulSourceRow = sources.find(s => s.highlightRow && !s.highlightCol);
    const matmulSourceCol = sources.find(s => s.highlightCol && !s.highlightRow);
    const addSources = sources.filter(s => !s.highlightRow && !s.highlightCol);

    // Wx+b Check (e.g., FFN layers)
    if (matmulSourceRow && matmulSourceCol && addSources.length > 0) {
        opType = 'add'; // The final operation is an add
        const matmulMatrixA = getMatrixByName(matmulSourceRow.name, transformerData, layerIdx, headIdx);
        const matmulMatrixB = getMatrixByName(matmulSourceCol.name, transformerData, layerIdx, headIdx);
        const biasSource = addSources[0];
        const biasMatrix = getMatrixByName(biasSource.name, transformerData, layerIdx, headIdx);

        if (matmulMatrixA && matmulMatrixB && biasMatrix) {
            // Step 1: Matmul
            const vecA = matmulMatrixA[matmulSourceRow.row];
            const vecB = matmulMatrixB.map(r => r[matmulSourceCol.col]);
            const matmulResult = vecA.reduce((sum, val, i) => sum + val * vecB[i], 0);
            const components: CalculationComponent[] = vecA.map((val, i) => ({ a: val, b: vecB[i] }));
            steps.push({ title: "Step 1: Matmul", a: vecA, b: vecB, op: '·', result: matmulResult, aSymbolInfo: getSymbolParts(matmulSourceRow.name), bSymbolInfo: getSymbolParts(matmulSourceCol.name), components });

            // Step 2: Add bias
            const biasValue = biasMatrix[biasSource.row][biasSource.col];
            steps.push({ title: "Step 2: Add Bias", a: [matmulResult], b: [biasValue], op: '+', result: targetValue, aSymbolInfo: {base:"Matmul Result"}, bSymbolInfo: getSymbolParts(biasSource.name) });
        }
    // Pure Matmul Check
    } else if (matmulSourceRow && matmulSourceCol) {
        opType = 'matmul';
        const matrixA = getMatrixByName(matmulSourceRow.name, transformerData, layerIdx, headIdx);
        const matrixB = getMatrixByName(matmulSourceCol.name, transformerData, layerIdx, headIdx);
        if (matrixA && matrixB) {
            const vecA = matrixA[matmulSourceRow.row];
            const vecB = matrixB.map(r => r[matmulSourceCol.col]);
            const components: CalculationComponent[] = vecA.map((val, i) => ({ a: val, b: vecB[i] }));
            steps.push({ a: vecA, b: vecB, op: '·', result: targetValue, aSymbolInfo: getSymbolParts(matmulSourceRow.name), bSymbolInfo: getSymbolParts(matmulSourceCol.name), components });
        }
    // Pure Element-wise Add Check (e.g., Residual connections)
    } else if (addSources.length >= 2) {
        opType = 'add';
        const vals = addSources.map(s => getMatrixByName(s.name, transformerData, layerIdx, headIdx)?.[s.row]?.[s.col] ?? 0);
        if(vals.length >= 2) {
             steps.push({ a: [vals[0]], b: [vals[1]], op: '+', result: targetValue, aSymbolInfo: getSymbolParts(addSources[0].name), bSymbolInfo: getSymbolParts(addSources[1].name) });
        }
    // Internal Element-wise Op Check (Softmax/ReLU)
    } else if (isInternal) {
         const sourceName = sources[0].name;
         const sourceMatrix = getMatrixByName(sourceName, transformerData, layerIdx, headIdx);
         if (sourceMatrix) {
            const vecA = sourceMatrix[row];
            if (baseName.includes('AttentionWeights')) {
                opType = 'softmax';
                steps.push({ a: vecA, b: [], op: 'softmax', result: targetValue, aSymbolInfo: getSymbolParts(sourceName), bSymbolInfo: { base: '' } });
            } else if (baseName.includes('Activated')) {
                opType = 'relu';
                steps.push({ a: vecA, b: [], op: 'relu', result: targetValue, aSymbolInfo: getSymbolParts(sourceName), bSymbolInfo: { base: '' } });
            }
         }
    }

    if (steps.length === 0) return null;

    const symbol = getSymbolParts(baseName);
    element.symbol = `${symbol.base}${symbol.subscript ? `_{${symbol.subscript}}` : ''}${symbol.superscript ? `^{${symbol.superscript}}` : ''}`;

    return {
        target: element,
        opType,
        steps,
        title: `Calculation for ${element.symbol}[${row},${col}]`,
        initialPosition: { x: 0, y: 0 }
    };
};

const createBackwardHighlight = (element: ElementIdentifier, transformerData: TransformerData, dims: any): { highlight: HighlightState } => {
    const { name, row, col, isInternal } = element;
    let newSources: HighlightSource[] = [];
    let newTarget: ElementIdentifier | null = element;
    let activeComponent: string | null = null;
    let activeResidual: string | null = null;

    if (name.startsWith('residual.')) {
        const [, resId] = name.split('.');
        activeResidual = resId;
        const layerIdx = parseInt(resId.match(/l(\d+)/)?.[1] || '0', 10);
        const part = parseInt(resId.match(/(\d+)$/)?.[1] || '1', 10);
        if (resId.includes('-d')) {
            const LN = MATRIX_NAMES.decoderLayer(layerIdx);
            if (part === 1) { activeComponent = 'add_norm_1_dec'; newSources.push({ name: LN.decoder_input, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.masked_mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2_dec'; newSources.push({ name: LN.add_norm_1_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.enc_dec_mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 3) { activeComponent = 'add_norm_3_dec'; newSources.push({ name: LN.add_norm_2_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.ffn_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
        } else {
            const LN = MATRIX_NAMES.layer(layerIdx);
            if (part === 1) { activeComponent = 'add_norm_1'; newSources.push({ name: LN.encoder_input, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2'; newSources.push({ name: LN.add_norm_1_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.ffn_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
        }
        return { highlight: { target: null, sources: newSources, activeComponent, activeResidual, destinations: [] } };
    }

    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    const LNe = MATRIX_NAMES.layer(layerIdx);
    const HNe = MATRIX_NAMES.head(layerIdx, headIdx);
    const LNd = MATRIX_NAMES.decoderLayer(layerIdx);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIdx, headIdx);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(layerIdx, headIdx);
    const baseName = isInternal ? name.replace('.internal', '') : name;

    if (name.startsWith('encoder')) {
        if (Object.values(HNe).includes(baseName) || [LNe.mha_output, LNe.Wo, LNe.encoder_input].includes(baseName)) activeComponent = 'mha';
        else if ([LNe.add_norm_1_output].includes(baseName)) activeComponent = 'add_norm_1';
        else if ([LNe.add_norm_2_output].includes(baseName)) activeComponent = 'add_norm_2';
        else if (baseName.includes('.ffn.')) activeComponent = 'ffn';
    } else if (name.startsWith('decoder')) {
        if (Object.values(HNd_masked).includes(baseName) || [LNd.masked_mha_output, LNd.Wo_masked, LNd.decoder_input].includes(baseName)) activeComponent = 'masked_mha';
        else if (Object.values(HNd_encdec).includes(baseName) || [LNd.enc_dec_mha_output, LNd.Wo_enc_dec, LNd.add_norm_1_output, MATRIX_NAMES.finalEncoderOutput].includes(baseName)) activeComponent = 'enc_dec_mha';
        else if (baseName === LNd.add_norm_1_output) activeComponent = 'add_norm_1_dec';
        else if (baseName === LNd.add_norm_2_output) activeComponent = 'add_norm_2_dec';
        else if (baseName === LNd.add_norm_3_output) activeComponent = 'add_norm_3_dec';
        else if (baseName.includes('.ffn.')) activeComponent = 'ffn_dec';
    } else if (name === 'inputToken' || name === 'embeddingMatrix' || name === 'inputEmbeddings') {
        activeComponent = 'token_embed';
    } else if ([MATRIX_NAMES.posEncodings, MATRIX_NAMES.encoderInput].includes(baseName) || baseName === LNe.encoder_input) {
        activeComponent = 'input_embed';
    } else if ([MATRIX_NAMES.outputEmbeddings, MATRIX_NAMES.decoderPosEncodings, MATRIX_NAMES.decoderInput].includes(baseName) || baseName === LNd.decoder_input) {
        activeComponent = 'output_embed';
    } else if ([MATRIX_NAMES.finalLinear, MATRIX_NAMES.logits].includes(baseName)) {
        activeComponent = 'final_output';
    } else if (name === MATRIX_NAMES.outputProbabilities || name === 'outputToken') {
        activeComponent = 'decoding';
    }

    if (isInternal) {
        newTarget = { name, row, col, isInternal: true };
        if (baseName.includes('AttentionWeights')) {
            const scaledScoresName = baseName.includes('masked_mha') ? HNd_masked.ScaledScores : baseName.includes('enc_dec_mha') ? HNd_encdec.ScaledScores : HNe.ScaledScores;
            newSources.push({ name: scaledScoresName, row, col: -1, highlightRow: true });
        } else if (baseName.includes('Activated')) {
            const intermediateName = baseName.includes('decoder') ? LNd.Intermediate : LNe.Intermediate;
            newSources.push({ name: intermediateName, row, col });
        }
    }
    else if (name === 'inputToken') { newSources.push({ name: MATRIX_NAMES.inputEmbeddings, row, col: -1, highlightRow: true }) }
    else if (name === MATRIX_NAMES.inputEmbeddings) { newSources.push({ name: 'inputToken', row, col: -1 }); newSources.push({ name: 'embeddingMatrix', row: transformerData.tokenizedInput[row], col: -1, highlightRow: true }) }
    else if (name === LNe.encoder_input) {
        if (layerIdx === 0) {
            newSources.push({ name: MATRIX_NAMES.inputEmbeddings, row, col });
            newSources.push({ name: MATRIX_NAMES.posEncodings, row, col });
        } else {
            newSources.push({ name: MATRIX_NAMES.layer(layerIdx - 1).add_norm_2_output, row, col });
        }
    }
    else if (name === HNe.Q || name === HNe.K || name === HNe.V) { const type = name.split('.').pop()!; newSources.push({ name: LNe.encoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: HNe[`W${type.toLowerCase()}` as 'Wq' | 'Wk' | 'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNe.Scores) { newSources.push({ name: HNe.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNe.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNe.ScaledScores) { newSources.push({ name: HNe.Scores, row, col }); }
    else if (name === HNe.AttentionWeights) { newSources.push({ name: HNe.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNe.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNe.HeadOutput) { newSources.push({ name: HNe.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNe.V, row: -1, col, highlightCol: true }); }
    else if (name === LNe.mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.head(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.Wo, row: -1, col, highlightCol: true }); }
    else if (name === LNe.add_norm_1_output) { newSources.push({ name: LNe.encoder_input, row, col }); newSources.push({ name: LNe.mha_output, row, col }); }
    else if (name === LNe.Intermediate) { newSources.push({ name: LNe.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.W1, row: -1, col, highlightCol: true }); newSources.push({ name: LNe.b1, row: 0, col }); }
    else if (name === LNe.Activated) { newSources.push({ name: LNe.Intermediate, row, col }); newSources.push({ name: `${LNe.Activated}.internal`, row, col, isInternal: true }); }
    else if (name === LNe.ffn_output) { newSources.push({ name: LNe.Activated, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.W2, row: -1, col, highlightCol: true }); newSources.push({ name: LNe.b2, row: 0, col }); }
    else if (name === LNe.add_norm_2_output) { newSources.push({ name: LNe.add_norm_1_output, row, col }); newSources.push({ name: LNe.ffn_output, row, col }); }
    else if (name === LNd.decoder_input) {
        if (layerIdx === 0) {
            newSources.push({ name: MATRIX_NAMES.outputEmbeddings, row, col });
            newSources.push({ name: MATRIX_NAMES.decoderPosEncodings, row, col });
        } else {
            newSources.push({ name: MATRIX_NAMES.decoderLayer(layerIdx - 1).add_norm_3_output, row, col });
        }
    }
    else if (name === HNd_masked.Q || name === HNd_masked.K || name === HNd_masked.V) { const type = name.split('.').pop()!; newSources.push({ name: LNd.decoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked[`W${type.toLowerCase()}` as 'Wq' | 'Wk' | 'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNd_masked.Scores) { newSources.push({ name: HNd_masked.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNd_masked.ScaledScores) { newSources.push({ name: HNd_masked.Scores, row, col }); }
    else if (name === HNd_masked.AttentionWeights) { newSources.push({ name: HNd_masked.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNd_masked.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNd_masked.HeadOutput) { newSources.push({ name: HNd_masked.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked.V, row: -1, col, highlightCol: true }); }
    else if (name === LNd.masked_mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.maskedMhaHead(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.Wo_masked, row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_1_output) { newSources.push({ name: LNd.decoder_input, row, col }); newSources.push({ name: LNd.masked_mha_output, row, col }); }
    else if (name === HNd_encdec.Q) { newSources.push({ name: LNd.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_encdec.Wq, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.K) { newSources.push({ name: MATRIX_NAMES.finalEncoderOutput, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: HNd_encdec.Wk, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.V) { newSources.push({ name: MATRIX_NAMES.finalEncoderOutput, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: HNd_encdec.Wv, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.Scores) { newSources.push({ name: HNd_encdec.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_encdec.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNd_encdec.ScaledScores) { newSources.push({ name: HNd_encdec.Scores, row, col }); }
    else if (name === HNd_encdec.AttentionWeights) { newSources.push({ name: HNd_encdec.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNd_encdec.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNd_encdec.HeadOutput) { newSources.push({ name: HNd_encdec.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_encdec.V, row: -1, col, highlightCol: true }); }
    else if (name === LNd.enc_dec_mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.encDecMhaHead(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.Wo_enc_dec, row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_2_output) { newSources.push({ name: LNd.add_norm_1_output, row, col }); newSources.push({ name: LNd.enc_dec_mha_output, row, col }); }
    else if (name === LNd.Intermediate) { newSources.push({ name: LNd.add_norm_2_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.W1, row: -1, col, highlightCol: true }); newSources.push({ name: LNd.b1, row: 0, col }); }
    else if (name === LNd.Activated) { newSources.push({ name: LNd.Intermediate, row, col }); newSources.push({ name: `${LNd.Activated}.internal`, row, col, isInternal: true }); }
    else if (name === LNd.ffn_output) { newSources.push({ name: LNd.Activated, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.W2, row: -1, col, highlightCol: true }); newSources.push({ name: LNd.b2, row: 0, col }); }
    else if (name === LNd.add_norm_3_output) { newSources.push({ name: LNd.add_norm_2_output, row, col }); newSources.push({ name: LNd.ffn_output, row, col }); }
    else if (name === MATRIX_NAMES.logits) { newSources.push({ name: MATRIX_NAMES.decoderLayer(dims.n_layers - 1).add_norm_3_output, row, col: -1, highlightRow: true }); newSources.push({ name: MATRIX_NAMES.finalLinear, row: -1, col, highlightCol: true }) }
    else if (name === MATRIX_NAMES.outputProbabilities) { newSources.push({ name: MATRIX_NAMES.logits, row, col: -1, highlightRow: true }) }
    else if (name === 'outputToken') { newSources.push({ name: MATRIX_NAMES.outputProbabilities, row, col: -1, highlightRow: true, highlightProbCol: true }) }

    const highlight = { target: newTarget, sources: newSources, activeComponent, activeResidual, destinations: [] };
    return { highlight };
};


export const TransformerExplorerTopic: React.FC = () => {
    const [dims, setDims] = useState({ d_model: 8, h: 2, seq_len: 2, n_layers: 1, d_ff: 32 });
    const [inputText, setInputText] = useState("I am a student");
    const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [], destinations: [], activeComponent: null, activeResidual: null });
    const [tooltip, setTooltip] = useState<TooltipState | null>(null);

    const { primarySize, separatorProps, containerProps } = useSplitPane(window.innerWidth * 0.55);

    const transformerData: TransformerData | null = useTransformer(inputText, dims);

    useEffect(() => {
        if (highlight.activeComponent) {
          const explanationEl = document.getElementById(`math_${highlight.activeComponent}`);
          if (explanationEl) {
              setTimeout(() => {
                  explanationEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }, 100);
          }
        }
      }, [highlight.activeComponent]);

    const handleInteraction = useCallback((element: ElementIdentifier, event: React.MouseEvent) => {
        if (!transformerData) return;
        const { highlight: newHighlight } = createBackwardHighlight(element, transformerData, dims);
        setHighlight(newHighlight);

        const newTooltip = generateTooltipData(element, transformerData, newHighlight.sources);
        setTooltip(newTooltip);
    }, [transformerData, dims]);

    const handleComponentClick = useCallback((componentId: string) => {
      setHighlight(prev => ({
          target: null, sources: [], destinations: [], activeComponent: componentId, activeResidual: null
      }));
      setTooltip(null);
    }, []);

    const closeTooltip = useCallback(() => setTooltip(null), []);

    if (!transformerData) {
        return <div style={{padding: "20px", textAlign: "center"}}>正在加载或维度设置无效... (d_model 必须能被 h 整除)</div>
    }

    const explanationDims = {
      ...dims,
      encoder_seq_len: transformerData.encoderInput.length,
      decoder_seq_len: transformerData.decoderInput.length,
      vocab_size: Object.keys(transformerData.vocab).length
  };

    return (
        <div className="main-layout" {...containerProps} style={{padding: '0', gap: '0', height: '100%'}}>
            {tooltip && <CalculationTooltip tooltip={tooltip} onClose={closeTooltip} />}
            <Controls dims={dims} setDims={setDims} inputText={inputText} setInputText={setInputText}/>
            <div className="column left-column" style={{width: primarySize, flex: 'none', borderRadius: '0', boxShadow: 'none'}}>
                <div className="column-content">
                    <h2>模型结构与数据流</h2>
                    <p style={{textAlign: 'center', margin: '-10px 0 15px 0', fontSize: '0.9em', color: '#555'}}>
                        提示: 点击任何计算结果 (红色高亮) 的单元格,即可查看其详细计算过程.
                    </p>
                    <Viz
                        data={transformerData}
                        highlight={highlight}
                        onElementClick={handleInteraction}
                        onComponentClick={handleComponentClick}
                    />
                </div>
            </div>
            <div className="split-pane-separator" {...separatorProps} />
            <div className="column right-column" style={{flex: 1, borderRadius: '0', boxShadow: 'none'}}>
                <div className="column-content">
                    <h2>数学原理详解</h2>
                    <Explanation
                        dims={explanationDims}
                        highlight={highlight}
                        onSymbolClick={handleInteraction}
                    />
                </div>
            </div>
        </div>
    );
}

// END OF FILE: src/topics/transformer-explorer/TransformerExplorerTopic.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/types.ts
================================================================================

// FILE: src/topics/transformer-explorer/types.ts
import { SymbolInfo as GenericSymbolInfo } from '../../components/visualizers/types';

export type SymbolInfo = GenericSymbolInfo;
export type Matrix = number[][];
export type Vector = number[];

export interface ElementIdentifier {
  name: string; // e.g., "encoder.0.mha.h0.Q" or "residual.res1.start"
  row: number;
  col: number;
  isInternal?: boolean; // True if it's part of an internal calculation visualization
  matrixSymbol?: string; // e.g., "Z"
  matrixDims?: string; // e.g., "3x8"
  tokenId?: number; // e.g., 10 for "I"
  tokenStr?: string; // e.g., "I"
  probValue?: number; // For decoding, the probability of the chosen token
  symbol?: string; // The mathematical symbol for the tooltip title
}

export interface HighlightSource extends ElementIdentifier {
  highlightRow?: boolean;
  highlightCol?: boolean;
  highlightProbCol?: boolean;
}

export interface HighlightState {
  activeComponent: string | null; // e.g., "mha", "ffn"
  activeResidual: string | null; // e.g., "res1"
  target: ElementIdentifier | null;
  sources: HighlightSource[];
  destinations?: HighlightSource[]; // For forward tracing
}

export interface CalculationComponent {
    a: number;
    b: number;
}

export interface CalculationStep {
    title?: string; // Optional title for multi-step calculations
    a: Vector;
    b: Vector;
    op: string; // e.g., '·', '+', '...'
    result: number;
    aSymbolInfo: SymbolInfo;
    bSymbolInfo: SymbolInfo;
    components?: CalculationComponent[];
}

export interface TooltipState {
    target: ElementIdentifier;
    opType: 'matmul' | 'add' | 'info' | 'softmax' | 'relu';
    steps: CalculationStep[];
    title: string;
    initialPosition: { x: number, y: number };
}

export interface AttentionHeadData {
  Wq: Matrix;
  Wk: Matrix;
  Wv: Matrix;
  Q: Matrix;
  K: Matrix;
  V: Matrix;
  Scores: Matrix;
  ScaledScores: Matrix;
  AttentionWeights: Matrix;
  HeadOutput: Matrix;
}

export interface MultiHeadAttentionData {
    heads: AttentionHeadData[];
    Wo: Matrix;
    output: Matrix;
}

export interface FFNData {
    W1: Matrix;
    b1: Vector; // bias is part of FFN data
    Intermediate: Matrix;
    Activated: Matrix;
    W2: Matrix;
    b2: Vector; // bias is part of FFN data
    Output: Matrix;
}

export interface EncoderLayerData {
    encoder_input: Matrix;
    mha: MultiHeadAttentionData;
    mha_output: Matrix;

    add_norm_1_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;

    add_norm_2_output: Matrix;
}

export interface DecoderLayerData {
    decoder_input: Matrix;
    masked_mha: MultiHeadAttentionData;
    masked_mha_output: Matrix;
    add_norm_1_output: Matrix;

    enc_dec_mha: MultiHeadAttentionData;
    enc_dec_mha_output: Matrix;
    add_norm_2_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;
    add_norm_3_output: Matrix;
}

export interface TransformerData {
    // Input Stage
    inputText: string[];
    tokenizedInput: number[];
    embeddingMatrix: Matrix;
    vocab: { [key: number]: string };

    // Encoder
    inputEmbeddings: Matrix;
    posEncodings: Matrix;
    encoderInput: Matrix;
    encoderLayers: EncoderLayerData[];
    finalEncoderOutput: Matrix;

    // Decoder
    outputEmbeddings: Matrix;
    decoderPosEncodings: Matrix;
    decoderInput: Matrix;
    decoderLayers: DecoderLayerData[];
    finalDecoderOutput: Matrix;
    finalLinear: Matrix; // Weights for the final linear layer
    logits: Matrix;
    outputProbabilities: Matrix;

    // Output Stage
    decodedTokens: number[];
    outputText: string[];
}
// END OF FILE: src/topics/transformer-explorer/types.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/components/AddNorm.tsx
================================================================================

// FILE: src/components/AddNorm.tsx
import React from 'react';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { ResidualBlock } from './ResidualBlock';

interface AddNormProps {
    residualInput: MatrixType; // [MODIFIED] Pass the full residual input matrix
    residualInputName: string; // [MODIFIED] Name of the residual input matrix
    inputSublayer: MatrixType;
    output: MatrixType;
    sublayerMatrixName: string;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    activeId: string;
    residualId: string;
    residualMatrixSymbol: string;
    residualMatrixDims: string;
}

export const AddNorm: React.FC<AddNormProps> = ({
    residualInput,
    residualInputName,
    inputSublayer,
    output,
    sublayerMatrixName,
    outputMatrixName,
    highlight,
    onElementClick,
    onComponentClick,
    activeId,
    residualId,
    residualMatrixSymbol,
    residualMatrixDims,
}) => {
    const isActive = highlight.activeComponent === activeId;

    return (
         <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick(activeId)}>Add & LayerNorm</div>
            <div className="component-body add-norm-component-body">
                <div className="add-norm-inputs">
                    {/* [MODIFIED] Show the full matrix for the residual connection */}
                    <Matrix name={residualInputName} data={residualInput} highlight={highlight} onElementClick={onElementClick} />
                    <ResidualBlock
                        id={residualId}
                        type="end"
                        highlight={highlight}
                        onElementClick={(el, e) => onElementClick(el, e)}
                        matrixSymbol={residualMatrixSymbol}
                        matrixDims={residualMatrixDims}
                    />
                    <div className="op-symbol">+</div>
                    <Matrix name={sublayerMatrixName} data={inputSublayer} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down"><InlineMath math="\xrightarrow{\text{LayerNorm}}" /></div>

                <Matrix name={outputMatrixName} data={output} highlight={highlight} onElementClick={onElementClick} />
            </div>
        </div>
    );
};
// END OF FILE: src/components/AddNorm.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/CalculationTooltip.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/CalculationTooltip.tsx
import React, { useState, useEffect, useRef } from 'react';
import { TooltipState } from '../types';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';
import { MatMulVisualizer } from '../../../components/visualizers/MatMulVisualizer';
import { InteractiveMatMulVisualizer } from '../../../components/visualizers/InteractiveMatMulVisualizer';
import { InlineMath } from 'react-katex';

interface CalculationTooltipProps {
  tooltip: TooltipState;
  onClose: () => void;
}

const formatNumber = (num: number, precision = 4) => {
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '+∞';
    const fixed = num.toFixed(precision);
    return parseFloat(fixed).toString();
};

export const CalculationTooltip: React.FC<CalculationTooltipProps> = ({ tooltip, onClose }) => {
    const [isCollapsed, setIsCollapsed] = useState(true);
    const [viewMode, setViewMode] = useState<'compact' | 'detailed'>('compact');
    const [hoveredComponentIndex, setHoveredComponentIndex] = useState<number | null>(null);
    const panelRef = useRef<HTMLDivElement>(null);

    const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
        x: 20,
        y: 20,
        width: 650,
        height: 500,
    }, panelRef);

    useEffect(() => {
        setIsCollapsed(false);
        setViewMode('compact');
        setHoveredComponentIndex(null);
    }, [tooltip]);

    const renderVector = (vec: number[], symbolInfo: TooltipState['steps'][0]['aSymbolInfo'], direction: 'row' | 'column' = 'row', focusIndex: number = -1) => {
        const visibleIndices = getVisibleIndices(vec.length, focusIndex, 1, 4);

        let mathSymbol = symbolInfo.base;
        if (symbolInfo.subscript) mathSymbol += `_{${symbolInfo.subscript}}`;
        if (symbolInfo.superscript) mathSymbol += `^{${symbolInfo.superscript}}`;

        return (
            <div className="tooltip-vector-group">
                <span className="tooltip-symbol"><InlineMath>{mathSymbol}</InlineMath> =</span>
                <div className={`tooltip-vector ${direction}`}>
                    {visibleIndices.map((idx, i) => {
                         if (idx === ELLIPSIS) {
                            return <span key={`ellipsis-${i}`} className="tooltip-element">...</span>;
                        }
                        return (
                            <span
                                key={idx}
                                className={`tooltip-element source`}
                            >
                                {formatNumber(vec[idx], 2)}
                            </span>
                        );
                    })}
                </div>
            </div>
        );
    };

    const renderBody = () => {
        if (!tooltip.steps || tooltip.steps.length === 0) return null;

        return tooltip.steps.map((step, stepIndex) => {
            let content = <></>;
            const focusIndex = tooltip.target.col;

            switch(tooltip.opType) {
                case 'matmul':
                    if (step.components) {
                        return (
                             <div className="tooltip-step-container" key={stepIndex}>
                                {step.title && <h4 className="tooltip-step-title">{step.title}</h4>}
                                {viewMode === 'compact' ? (
                                    <InteractiveMatMulVisualizer
                                        vectorA={step.a}
                                        vectorB={step.b}
                                        symbolAInfo={step.aSymbolInfo}
                                        symbolBInfo={step.bSymbolInfo}
                                        result={step.result}
                                        components={step.components}
                                        hoveredComponentIndex={hoveredComponentIndex}
                                        setHoveredComponentIndex={setHoveredComponentIndex}
                                    />
                                ) : (
                                    <MatMulVisualizer vectorA={step.a} vectorB={step.b} />
                                )}
                            </div>
                        )
                    }
                    content = <div>Matmul visualization requires components data.</div>
                    break;
                case 'add':
                    content = (
                        <div className="tooltip-calculation-detail" style={{borderTop: stepIndex > 0 ? '1px solid #eee' : 'none', paddingTop: stepIndex > 0 ? '12px' : '0'}}>
                            <div className="tooltip-calc-title">逐元素加法 (Element-wise Addition):</div>
                            <div className="tooltip-calc-equation">
                                <span>{formatNumber(step.a[0], 2)} (<InlineMath>{`${step.aSymbolInfo.base}_{...}`}</InlineMath>)</span>
                                <span className="op"> + </span>
                                <span>{formatNumber(step.b[0], 2)} (<InlineMath>{`${step.bSymbolInfo.base}_{...}`}</InlineMath>)</span>
                                <span> = <span className="result">{formatNumber(step.result, 2)}</span></span>
                            </div>
                        </div>
                    );
                    break;
                case 'softmax':
                    const maxVal = Math.max(...step.a.filter(isFinite));
                    const exps = step.a.map(v => isFinite(v) ? Math.exp(v - maxVal) : 0);
                    const sumExps = exps.reduce((a, b) => a + b, 0);
                    content = (
                        <>
                            {renderVector(step.a, step.aSymbolInfo, 'row', focusIndex)}
                            <div className="tooltip-calculation-detail">
                                <div className="tooltip-calc-title">Softmax 计算分解 (for {tooltip.target.symbol}[{tooltip.target.row}, {tooltip.target.col}]):</div>
                                <div className="tooltip-calc-equation-multi">
                                    <div>1. 减去最大值 (Subtract Max for stability): <span>max(...) = {formatNumber(maxVal, 2)}</span></div>
                                    <div>2. 计算指数 (Exponentiate): <span>e^({formatNumber(step.a[tooltip.target.col], 2)} - {formatNumber(maxVal, 2)}) = {formatNumber(exps[tooltip.target.col], 4)}</span></div>
                                    <div>3. 计算所有指数之和 (Sum Exponentials): <span>Σ e^(...) = {formatNumber(sumExps, 4)}</span></div>
                                    <div>4. 归一化 (Normalize): <span>{formatNumber(exps[tooltip.target.col], 4)} / {formatNumber(sumExps, 4)} = <span className="result">{formatNumber(step.result, 4)}</span></span></div>
                                </div>
                            </div>
                        </>
                    );
                    break;
                case 'relu':
                    content = (
                        <>
                            {renderVector(step.a, step.aSymbolInfo, 'row', focusIndex)}
                            <div className="tooltip-calculation-detail">
                                <div className="tooltip-calc-title">ReLU 计算:</div>
                                <div className="tooltip-calc-equation">
                                    <span>max(0, {formatNumber(step.a[tooltip.target.col], 2)}) = <span className="result">{formatNumber(step.result, 2)}</span></span>
                                </div>
                            </div>
                        </>
                    );
                    break;
                default:
                    content = <div>未知操作类型</div>
            }
            return (
                <div className="tooltip-step-container" key={stepIndex}>
                    {step.title && <h4 className="tooltip-step-title">{step.title}</h4>}
                    {content}
                </div>
            )
        });
    };

    const panelStyle: React.CSSProperties = {
        top: position.y,
        left: position.x,
        width: size.width,
        height: typeof size.height === 'number' && !isCollapsed ? size.height : 'auto',
    };

    const showViewToggle = tooltip.opType === 'matmul' && tooltip.steps[0]?.components;

    return (
        <div ref={panelRef} style={panelStyle} className={`calculation-tooltip ${isCollapsed ? 'collapsed' : ''} resizable-panel`}>
            <div className="panel-header" {...dragHandleProps}>
                <span className="panel-title">{tooltip.title}</span>
                <div className="tooltip-controls">
                    {showViewToggle && (
                        <button
                            className="view-toggle-btn"
                            onClick={(e) => {
                                e.stopPropagation();
                                setViewMode(prev => prev === 'compact' ? 'detailed' : 'compact');
                            }}>
                            {viewMode === 'compact' ? '动画视图' : '交互视图'}
                        </button>
                    )}
                    <button onClick={() => setIsCollapsed(!isCollapsed)} className="tooltip-toggle-btn">
                        {isCollapsed ? '⊕' : '⊖'}
                    </button>
                    <button onClick={onClose} className="tooltip-close-btn">&times;</button>
                </div>
            </div>
            <div className="tooltip-content-wrapper">
                <div className="tooltip-body">
                    <div className="calculation-content-container">
                        {renderBody()}
                    </div>
                </div>
            </div>
            <div className="resize-handle br" {...resizeHandleProps.br}></div>
            <div className="resize-handle t" {...resizeHandleProps.t}></div>
            <div className="resize-handle r" {...resizeHandleProps.r}></div>
            <div className="resize-handle b" {...resizeHandleProps.b}></div>
            <div className="resize-handle l" {...resizeHandleProps.l}></div>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/CalculationTooltip.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Controls.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/Controls.tsx
import React, { useState, useRef } from 'react';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';

interface ControlsProps {
  dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
  setDims: (dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number }) => void;
  inputText: string;
  setInputText: (text: string) => void;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims, inputText, setInputText }) => {
  const [isCollapsed, setIsCollapsed] = useState(true);
  const panelRef = useRef<HTMLDivElement>(null); // Create a ref
  const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
    x: window.innerWidth - 450, // Initial position top-right
    y: 90,
    width: 420,
    height: 300,
  }, panelRef); // Pass the ref to the hook


  const handleDimChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    let newDims = { ...dims, [id]: parseInt(value, 10) || 1 };

    if (id === 'h') {
        if (newDims.d_model % newDims.h !== 0) {
             newDims.d_model = Math.max(newDims.h, Math.ceil(newDims.d_model / newDims.h) * newDims.h);
        }
    }
    if (id === 'd_model') {
         if (newDims.d_model % newDims.h !== 0) {
             let best_h = 1;
             for (let i = 1; i <= newDims.d_model; i++) {
                 if (newDims.d_model % i === 0) {
                    if (Math.abs(i - newDims.h) < Math.abs(best_h - newDims.h)) {
                       best_h = i;
                    }
                 }
             }
             newDims.h = best_h;
         }
    }

    if(id === 'd_model') {
        newDims.d_ff = newDims.d_model * 4;
    }

    setDims(newDims);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      setInputText(e.target.value);
  }

  const d_k = dims.d_model % dims.h === 0 ? dims.d_model / dims.h : 'N/A';

  const panelStyle: React.CSSProperties = {
    position: 'absolute', // Changed from fixed to absolute
    top: position.y,
    left: position.x,
    width: isCollapsed ? 50 : size.width,
    height: isCollapsed ? 50 : size.height,
  };

  return (
    <div ref={panelRef} style={panelStyle} className={`controls-panel ${isCollapsed ? 'collapsed' : ''} resizable-panel`}>
      <div className="panel-header" {...dragHandleProps}>
        <button className="panel-toggle-btn" onClick={() => setIsCollapsed(!isCollapsed)}>
          {isCollapsed ? '⚙️' : '×'}
        </button>
        {!isCollapsed && <span className="panel-title">Controls</span>}
      </div>
      {!isCollapsed && (
          <div className="controls-container">
            <div className="control-group">
              <label htmlFor="inputText">输入文本 (Encoder Input)</label>
              <input type="text" id="inputText" value={inputText} onChange={handleInputChange} />
            </div>
            <div className="control-group">
              <label htmlFor="seq_len">解码器长度 (Decoder Len)</label>
              <input type="number" id="seq_len" value={dims.seq_len} onChange={handleDimChange} min="1" max="4" />
            </div>
            <div className="control-group">
              <label htmlFor="d_model">模型维度 (d_model)</label>
              <input type="number" id="d_model" value={dims.d_model} onChange={handleDimChange} step={1} min={2} max="16"/>
            </div>
            <div className="control-group">
              <label htmlFor="h">注意力头数 (h)</label>
              <input type="number" id="h" value={dims.h} onChange={handleDimChange} min="1" max={dims.d_model}/>
            </div>
            <div className="control-group">
              <label htmlFor="n_layers">层数 (N)</label>
              <input type="number" id="n_layers" value={dims.n_layers} onChange={handleDimChange} min="1" max="3"/>
            </div>
            <div className="control-group">
              <label>键/查询维度 (d_k)</label>
              <div className="d_k-value">{d_k}</div>
            </div>
          </div>
      )}
        <div className="resize-handle br" {...resizeHandleProps.br}></div>
        <div className="resize-handle t" {...resizeHandleProps.t}></div>
        <div className="resize-handle r" {...resizeHandleProps.r}></div>
        <div className="resize-handle b" {...resizeHandleProps.b}></div>
        <div className="resize-handle l" {...resizeHandleProps.l}></div>
    </div>
  );
};
// END OF FILE: src/topics/transformer-explorer/components/Controls.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/DecoderLayer.tsx
================================================================================

// FILE: src/components/DecoderLayer.tsx
import React from 'react';
import { DecoderLayerData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../config/symbolMapping';
import { Matrix } from './Matrix';
import { MaskedMultiHeadAttention } from './MaskedMultiHeadAttention';
import { EncoderDecoderAttention } from './EncoderDecoderAttention';

interface DecoderLayerProps {
  layerIndex: number;
  data: DecoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  onComponentClick: (componentId: string) => void;
  finalEncoderOutput: MatrixType; // [ADDED]
}

export const DecoderLayer: React.FC<DecoderLayerProps> = ({ layerIndex, data, highlight, onElementClick, onComponentClick, finalEncoderOutput }) => {
  const baseName = `decoder.${layerIndex}`;
  const LN = MATRIX_NAMES.decoderLayer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.decoder_input);
  const dimsRes1 = `${data.decoder_input.length}x${data.decoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  const symbolRes3 = getSymbolParts(LN.add_norm_2_output);
  const dimsRes3 = `${data.add_norm_2_output.length}x${data.add_norm_2_output[0].length}`;
  const mathSymbolRes3 = symbolRes3.base + (symbolRes3.subscript ? `_{${symbolRes3.subscript}}` : '') + (symbolRes3.superscript ? `^{${symbolRes3.superscript}}` : '');

  return (
    <div className="decoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#d1c4e9', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#ede7f6'}}>解码器层 (Decoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- Masked MHA Sub-layer --- */}
                <Matrix name={LN.decoder_input} data={data.decoder_input} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-d1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MaskedMultiHeadAttention
                    baseName={`${baseName}.masked_mha`}
                    data={data.masked_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.decoder_input}
                    residualInputName={LN.decoder_input}
                    inputSublayer={data.masked_mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.masked_mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_1_dec"
                    residualId={`res-l${layerIndex}-d1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />
                <div className="arrow-down">↓</div>

                {/* --- Encoder-Decoder Attention Sub-layer --- */}
                <ResidualBlock id={`res-l${layerIndex}-d2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <EncoderDecoderAttention
                    baseName={`${baseName}.enc_dec_mha`}
                    data={data.enc_dec_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    finalEncoderOutput={finalEncoderOutput}
                />
                <AddNorm
                    residualInput={data.add_norm_1_output}
                    residualInputName={LN.add_norm_1_output}
                    inputSublayer={data.enc_dec_mha_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.enc_dec_mha_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_2_dec"
                    residualId={`res-l${layerIndex}-d2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />
                <div className="arrow-down">↓</div>

                {/* --- FFN Sub-layer --- */}
                <ResidualBlock id={`res-l${layerIndex}-d3`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes3} matrixDims={dimsRes3} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_2_output}
                    inputName={LN.add_norm_2_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.add_norm_2_output}
                    residualInputName={LN.add_norm_2_output}
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_3_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_3_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_3_dec"
                    residualId={`res-l${layerIndex}-d3`}
                    residualMatrixSymbol={mathSymbolRes3}
                    residualMatrixDims={dimsRes3}
                />
            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/DecoderLayer.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Decoding.tsx
================================================================================

// FILE: src/components/Decoding.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { EmbeddingLookup } from './EmbeddingLookup';

interface DecodingProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    isActive: boolean;
}

export const Decoding: React.FC<DecodingProps> = ({ data, highlight, onElementClick, onComponentClick, isActive }) => {
    // Create a list of ElementIdentifier for the output tokens
    const outputTokensForLookup: ElementIdentifier[] = data.outputText.map((token, i) => {
        const correspondingProbRow = data.outputProbabilities[i];
        const maxProb = Math.max(...correspondingProbRow);
        return {
            name: "outputToken",
            row: i,
            col: -1, // Not a cell in a matrix
            tokenId: data.decodedTokens[i],
            tokenStr: token,
            probValue: maxProb
        };
    });

    const shouldBreak = (data.embeddingMatrix[0]?.length || 0) > 10;

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('decoding')}>Output: Decoding Probabilities to Text</div>
            <div className="component-body">

                <div className="decoding-step">
                    <div className="viz-step-title">1. Find Index of Max Probability per Row (Argmax)</div>
                    <p style={{textAlign: 'center', margin: '0 0 10px 0', fontSize: '0.9em', color: '#555'}}>Click a row in the probability matrix to see which token it generates.</p>
                     <Matrix name="outputProbabilities" data={data.outputProbabilities} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down">↓</div>

                <div className="decoding-step">
                     <div className="viz-step-title">2. Use Token IDs to Lookup Text from Vocabulary</div>
                     <EmbeddingLookup
                        mode="id-to-token"
                        tokens={outputTokensForLookup}
                        embeddingMatrix={data.embeddingMatrix}
                        vocab={data.vocab}
                        matrixName="embeddingMatrix"
                        highlight={highlight}
                        onElementClick={onElementClick}
                        shouldBreak={shouldBreak}
                     />
                </div>

            </div>
        </div>
    );
};
// END OF FILE: src/components/Decoding.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Element.tsx
================================================================================

// FILE: src/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isProbMax?: boolean; // [NEW] To specifically highlight the argmax result
}

export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick, isProbMax = false }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col && !highlight.target.isInternal;

  const isSource = highlight.sources.some(s => {
    if (s.name !== name || s.isInternal) return false;
    if (s.highlightRow) return s.row === row;
    if (s.highlightCol) return s.col === col;
    return s.row === row && s.col === col;
  });

  const isDestination = highlight.destinations?.some(d => {
    if (d.name !== name || d.isInternal) return false;
    if (d.highlightRow) return d.row === row;
    if (d.highlightCol) return d.col === col;
    return d.row === row && d.col === col;
  });

  const classNames = ['matrix-element'];
  if (isTarget) classNames.push('target');
  if (isSource) classNames.push('source');
  if (isDestination) classNames.push('destination');
  if (isProbMax) classNames.push('prob-max');

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({ name, row, col }, event);
  };

  const displayValue = () => {
      if (value === -Infinity) return '-∞';
      if (value === Infinity) return '+∞';
      return value.toFixed(2);
  }

  return (
    <div className={classNames.join(' ')} onClick={handleClick}>
      {displayValue()}
    </div>
  );
});
// END OF FILE: src/components/Element.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/ElementwiseCalculation.tsx
================================================================================

// FILE: src/components/ElementwiseCalculation.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier, HighlightState } from '../types';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface ElementwiseCalculationProps {
  opType: 'softmax' | 'relu';
  inputRow: number[];
  outputRow: number[];
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  baseName: string; // e.g., "encoder.0.mha.h0.AttentionWeights"
  rowIndex: number;
}

const formatNumber = (num: number, precision = 2) => num.toFixed(precision);

export const ElementwiseCalculation: React.FC<ElementwiseCalculationProps> = ({
  opType,
  inputRow,
  outputRow,
  highlight,
  onElementClick,
  baseName,
  rowIndex,
}) => {
  const targetCol = highlight.target?.isInternal && highlight.target.row === rowIndex ? highlight.target.col : -1;
  const visibleCols = getVisibleIndices(inputRow.length, targetCol);

  const handleClick = (event: React.MouseEvent, colIndex: number) => {
    onElementClick({
      name: `${baseName}.internal`, // Special name for internal calculation
      row: rowIndex,
      col: colIndex,
      isInternal: true,
    }, event);
  };

  const isSource = (colIndex: number) => {
      return highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === colIndex);
  }
  const isTarget = (colIndex: number) => {
      return highlight.target?.isInternal && highlight.target.row === rowIndex && highlight.target.col === colIndex;
  }


  const renderVisibleElements = (data: (number | string)[], type: 'input' | 'output' | 'exp' | 'sum') => {
    return visibleCols.map((col, i) => {
      if (col === ELLIPSIS) {
        return <div key={`ellipsis-${i}`} className="elementwise-op-element symbolic-ellipsis">...</div>;
      }
      const value = data[col];
      const className = `elementwise-op-element ${isSource(col) ? 'source' : ''} ${isTarget(col) ? 'target' : ''}`;
      return (
        <div key={`${type}-${col}`} className={className} onClick={(e) => handleClick(e, col)}>
          {typeof value === 'number' ? formatNumber(value) : value}
        </div>
      );
    });
  };

  const renderSoftmax = () => {
    const maxVal = Math.max(...inputRow);
    const exps = inputRow.map(val => Math.exp(val - maxVal));
    const sumExps = exps.reduce((a, b) => a + b, 0);

    const fullSumIsSource = highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === -1); // -1 indicates whole row/sum

    return (
      <>
        {/* Step 1: exp(x - max(x)) */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(x_i - \text{max}(\mathbf{x}))" /></div>
          <div className="elementwise-op-row">
            {renderVisibleElements(exps.map(v => Number(formatNumber(v, 4))), 'exp')}
          </div>
        </div>
        {/* Step 2: Sum */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\sum \text{exp}(\dots)" /></div>
          <div className={`elementwise-op-element sum ${fullSumIsSource ? 'source' : ''}`} onClick={(e) => handleClick(e, -1)}>
            {formatNumber(sumExps, 4)}
          </div>
        </div>
        {/* Step 3: Division */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(\dots) / \sum" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };

  const renderReLU = () => {
    return (
      <>
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{max}(0, x_i)" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };


  return (
    <div className="elementwise-calc-container">
        {opType === 'softmax' ? renderSoftmax() : renderReLU()}
    </div>
  );
};
// END OF FILE: src/components/ElementwiseCalculation.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/ElementwiseOperation.tsx
================================================================================

// FILE: src/components/ElementwiseOperation.tsx
import React from 'react';
import { Matrix, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { ElementwiseCalculation } from './ElementwiseCalculation';

interface ElementwiseOperationProps {
    opType: 'softmax' | 'relu';
    inputMatrix: Matrix;
    inputMatrixName: string; // [FIXED] Added required prop
    outputMatrix: Matrix;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    layerIndex: number;
    headIndex?: number;
}

export const ElementwiseOperation: React.FC<ElementwiseOperationProps> = ({
    opType,
    inputMatrix,
    inputMatrixName, // [FIXED] Destructure prop
    outputMatrix,
    outputMatrixName,
    highlight,
    onElementClick,
    layerIndex,
    headIndex,
}) => {
    let targetRowIndex = 0;

    // [FIXED] Use the passed inputMatrixName for correct highlight detection
    if (highlight.target) {
        if (highlight.target.name === inputMatrixName || highlight.target.name === outputMatrixName) {
            targetRowIndex = highlight.target.row;
        } else if (highlight.target.isInternal && highlight.target.name.startsWith(outputMatrixName)) {
            targetRowIndex = highlight.target.row;
        }
    }

    const inputRow = inputMatrix[targetRowIndex] || [];
    const outputRow = outputMatrix[targetRowIndex] || [];

    const opName = opType.charAt(0).toUpperCase() + opType.slice(1);
    const opFunction = opType === 'relu' ? 'max(0, x)' : 'softmax(x_i)';

    return (
        <div className="elementwise-op-container">
            <div className="elementwise-op-label">
                <InlineMath math={`\\text{Detailed Calculation: } ${opName}(x_i) = ${opFunction}`} />
            </div>
            <p style={{margin: '0', fontSize: '0.8em', color: '#666'}}>* Showing calculation for Row {targetRowIndex}</p>
            <ElementwiseCalculation
                opType={opType}
                inputRow={inputRow}
                outputRow={outputRow}
                highlight={highlight}
                onElementClick={onElementClick}
                baseName={outputMatrixName}
                rowIndex={targetRowIndex}
            />
        </div>
    );
};
// END OF FILE: src/components/ElementwiseOperation.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/EmbeddingLookup.tsx
================================================================================

// FILE: src/components/EmbeddingLookup.tsx
import React, { useRef, useEffect, useState } from 'react';
import { TransformerData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { Token } from './Token';

interface EmbeddingLookupProps {
    mode: 'token-to-vector' | 'id-to-token';
    tokens: ElementIdentifier[];
    embeddingMatrix: MatrixType;
    matrixName: string;
    vocab?: TransformerData['vocab']; // For id-to-token mode
    outputVectors?: MatrixType; // For token-to-vector mode
    outputMatrixName?: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    shouldBreak: boolean; // [ADDED] Prop to control layout
}

export const EmbeddingLookup: React.FC<EmbeddingLookupProps> = ({
    mode,
    tokens,
    embeddingMatrix,
    matrixName,
    vocab,
    outputVectors,
    outputMatrixName,
    highlight,
    onElementClick,
    shouldBreak,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [lines, setLines] = useState<any[]>([]);

    useEffect(() => {
        const calculateLines = () => {
            if (!containerRef.current) return;

            const newLines: any[] = [];
            const tokenElements = Array.from(containerRef.current.querySelectorAll('.token-container'));
            const matrixRowElements = Array.from(containerRef.current.querySelectorAll(`.matrix-grid[data-name="${matrixName}"] .matrix-element`));
            const outputElements = Array.from(containerRef.current.querySelectorAll(mode === 'token-to-vector' ? `.matrix-wrapper[data-name="${outputMatrixName}"]` : '.token-container.output-token'));

            const matrixGridEl = containerRef.current.querySelector(`.matrix-wrapper[data-name="${matrixName}"]`);
            if (!matrixGridEl) return;
            const matrixRect = matrixGridEl.getBoundingClientRect();
            const containerRect = containerRef.current.getBoundingClientRect();

            tokens.forEach((token, index) => {
                const tokenId = token.tokenId!;
                const isHighlighted = highlight.sources.some(s => s.name === 'inputToken' && s.row === index) ||
                                      highlight.target?.name === 'inputToken' && highlight.target?.row === index ||
                                      highlight.sources.some(s => s.name === 'outputProbabilities' && s.row === index) ||
                                      highlight.target?.name === 'outputToken' && highlight.target?.row === index;

                const tokenEl = tokenElements[index];

                // Find the corresponding matrix row element (might be virtualized)
                // Added null check for containerRef.current here to satisfy TypeScript
                const matrixRowEl = containerRef.current?.querySelector(`.matrix-element[data-row="${tokenId}"]`);
                const outputEl = outputElements[index];

                if (tokenEl && matrixRowEl && outputEl) {
                    const tokenRect = tokenEl.getBoundingClientRect();
                    const matrixRowRect = matrixRowEl.getBoundingClientRect();
                    const outputRect = outputEl.getBoundingClientRect();

                    let path1, path2;

                    if (shouldBreak) { // Vertical layout paths
                        const startX1 = tokenRect.left + tokenRect.width / 2 - containerRect.left;
                        const startY1 = tokenRect.bottom - containerRect.top;
                        const endX1 = matrixRect.left + matrixRect.width / 2 - containerRect.left;
                        const endY1 = matrixRect.top - containerRect.top;
                        path1 = `M ${startX1} ${startY1} C ${startX1} ${startY1 + 40} ${endX1} ${endY1 - 40} ${endX1} ${endY1}`;

                        const startX2 = endX1;
                        const startY2 = matrixRect.bottom - containerRect.top;
                        const endX2 = outputRect.left + outputRect.width / 2 - containerRect.left;
                        const endY2 = outputRect.top - containerRect.top;
                        path2 = `M ${startX2} ${startY2} C ${startX2} ${startY2 + 40} ${endX2} ${endY2 - 40} ${endX2} ${endY2}`;
                    } else { // Horizontal layout paths
                        const startX1 = tokenRect.right - containerRect.left;
                        const startY1 = tokenRect.top + tokenRect.height / 2 - containerRect.top;
                        const endX1 = matrixRect.left - containerRect.left;
                        const endY1 = matrixRowRect.top + matrixRowRect.height / 2 - containerRect.top;
                        path1 = `M ${startX1} ${startY1} C ${startX1 + 50} ${startY1} ${endX1 - 50} ${endY1} ${endX1} ${endY1}`;

                        const startX2 = matrixRect.right - containerRect.left;
                        const startY2 = endY1; // Same Y as the matrix row
                        const endX2 = outputRect.left - containerRect.left;
                        const endY2 = outputRect.top + outputRect.height / 2 - containerRect.top;
                        path2 = `M ${startX2} ${startY2} C ${startX2 + 50} ${startY2} ${endX2 - 50} ${endY2} ${endX2} ${endY2}`;
                    }

                    newLines.push({ id: `line-${index}`, path1, path2, highlighted: isHighlighted });
                }
            });
            setLines(newLines);
        };
        calculateLines();
        const resizeObserver = new ResizeObserver(calculateLines);
        if (containerRef.current) {
            resizeObserver.observe(containerRef.current);
        }
        return () => resizeObserver.disconnect();
    }, [highlight, tokens, matrixName, outputMatrixName, mode, shouldBreak]);


    return (
        <div className={`embedding-lookup-container ${shouldBreak ? 'vertical' : ''}`} ref={containerRef}>
            <svg className="embedding-lookup-svg">
                {lines.map(line => (
                    <React.Fragment key={line.id}>
                        <path d={line.path1} className={line.highlighted ? 'highlighted' : ''} />
                        <path d={line.path2} className={line.highlighted ? 'highlighted' : ''} />
                    </React.Fragment>
                ))}
            </svg>

            {/* Input Column */}
            <div className="embedding-lookup-column">
                {tokens.map((token, i) => (
                    mode === 'token-to-vector'
                        ? <Token key={i} tokenStr={token.tokenStr!} tokenId={token.tokenId!} position={i} name={token.name} highlight={highlight} onElementClick={onElementClick} />
                        : <div key={i} style={{height: '59px', display: 'flex', alignItems: 'center', fontFamily: 'monospace'}}>ID: {token.tokenId}</div> // Placeholder for IDs
                ))}
            </div>

            {shouldBreak && <div className="arrow-down">↓</div>}

            {/* Vocabulary Matrix Column */}
            <div className="embedding-lookup-vocab" data-name={matrixName}>
                 <Matrix name={matrixName} data={embeddingMatrix} highlight={highlight} onElementClick={onElementClick} />
            </div>

            {shouldBreak && <div className="arrow-down">↓</div>}

            {/* Output Column */}
            <div className="embedding-lookup-column">
                 {mode === 'token-to-vector' && outputVectors && outputMatrixName ? (
                    <Matrix name={outputMatrixName} data={outputVectors} highlight={highlight} onElementClick={onElementClick} />
                 ) : (
                    tokens.map((token, i) => (
                         <Token key={i} tokenStr={token.tokenStr!} tokenId={token.tokenId!} position={i} name={token.name} highlight={highlight} onElementClick={onElementClick} />
                    ))
                 )}
            </div>
        </div>
    );
};
// END OF FILE: src/components/EmbeddingLookup.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/EncoderDecoderAttention.tsx
================================================================================

// FILE: src/components/EncoderDecoderAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface EncDecAttentionProps {
    baseName: string; // e.g., decoder.0.enc_dec_mha
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    finalEncoderOutput: MatrixType; // [ADDED]
}

export const EncoderDecoderAttention: React.FC<EncDecAttentionProps> = ({ baseName, data, highlight, onElementClick, onComponentClick, finalEncoderOutput }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Assume we visualize head 0
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'enc_dec_mha';
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.encDecMhaHead(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        if (numHeads > 2) {
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.encDecMhaHead(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.encDecMhaHead(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('enc_dec_mha')}>Encoder-Decoder Attention</div>
            <div className="component-body">
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Prepare Inputs</div>
                     <div className="viz-formula-row">
                        <div style={{display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px'}}>
                           <span style={{fontWeight: 'bold'}}>Q Input (from Decoder)</span>
                           <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).add_norm_1_output} data={finalEncoderOutput} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                        <div style={{display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px'}}>
                           <span style={{fontWeight: 'bold'}}>K & V Input (from Encoder)</span>
                           <Matrix name={MATRIX_NAMES.finalEncoderOutput} data={finalEncoderOutput} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Generate Q, K, V (Head 1)</div>
                     <div className="viz-formula-row">
                       <span>(Q Input) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(K Input) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(V Input) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Scaled Dot-Product Attention (Head 1)</div>
                     <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        inputMatrixName={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).ScaledScores}
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">4. Concat & Final Projection</div>
                     <div className="viz-formula-row">
                        {renderConcatHeads()}
                     </div>
                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).Wo_enc_dec} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).enc_dec_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/EncoderDecoderAttention.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/EncoderLayer.tsx
================================================================================

// FILE: src/components/EncoderLayer.tsx
import React from 'react';
import { EncoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { MultiHeadAttention } from './MultiHeadAttention';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../config/symbolMapping';
import { Matrix } from './Matrix';

interface EncoderLayerProps {
  layerIndex: number;
  data: EncoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  onComponentClick: (componentId: string) => void;
}

export const EncoderLayer: React.FC<EncoderLayerProps> = ({ layerIndex, data, highlight, onElementClick, onComponentClick }) => {
  const baseName = `encoder.${layerIndex}`;
  const LN = MATRIX_NAMES.layer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.encoder_input);
  const dimsRes1 = `${data.encoder_input.length}x${data.encoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  return (
    <div className="encoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#e3f2fd', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#e3f2fd'}}>编码器层 (Encoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- MHA Sub-layer with Residual Connection --- */}
                <ResidualBlock id={`res-l${layerIndex}-1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MultiHeadAttention
                    baseName={`${baseName}.mha`}
                    data={data.mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.encoder_input}
                    residualInputName={LN.encoder_input}
                    inputSublayer={data.mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_1"
                    residualId={`res-l${layerIndex}-1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />

                {/* --- FFN Sub-layer with Residual Connection --- */}
                <div className="arrow-down">↓</div>
                <ResidualBlock id={`res-l${layerIndex}-2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_1_output}
                    inputName={LN.add_norm_1_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.add_norm_1_output}
                    residualInputName={LN.add_norm_1_output}
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_2"
                    residualId={`res-l${layerIndex}-2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />

            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/EncoderLayer.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Explanation.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/Explanation.tsx
import React from 'react';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import { InteractiveSymbolicVector } from './InteractiveSymbolicVector';
import { HighlightState, ElementIdentifier } from '../types';
import { MATRIX_NAMES } from '../config/matrixNames';

interface ExplanationProps {
    dims: { d_model: number; h: number, n_layers: number, d_ff: number, encoder_seq_len: number, decoder_seq_len: number, vocab_size: number };
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

interface MathBlockProps {
    id: string;
    title: string;
    children: React.ReactNode;
    highlight: HighlightState;
}

const MathBlock: React.FC<MathBlockProps> = ({ id, title, children, highlight }) => {
    const isActive = highlight.activeComponent === id;
    return (
        <div id={`math_${id}`} className={`math-block ${isActive ? 'active' : ''}`}>
            <h3>{title}</h3>
            {children}
        </div>
    );
};

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight, onSymbolClick }) => {
    const LNe = MATRIX_NAMES.layer(0);
    const FinalLNe = MATRIX_NAMES.layer(dims.n_layers - 1);
    const HNe = MATRIX_NAMES.head(0, 0);
    const LNd = MATRIX_NAMES.decoderLayer(0);
    const FinalLNd = MATRIX_NAMES.decoderLayer(dims.n_layers - 1);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(0, 0);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(0, 0);
    const d_k = dims.d_model / dims.h;

    const shouldBreakAddNorm = dims.d_model > 8;
    const shouldBreakMhaProj = dims.d_model > 8;
    const shouldBreakFFN1 = dims.d_model + dims.d_ff > 8;
    const shouldBreakFFN2 = dims.d_ff + dims.d_model > 8;
    const shouldBreakFinalOutput = dims.d_model + dims.vocab_size > 8;

    // [FIXED] Specific breaking logic for Enc-Dec Attention
    const shouldBreakEncDecScores = d_k + dims.encoder_seq_len > 8;
    const shouldBreakEncDecHeadOutput = dims.encoder_seq_len + d_k > 8;


    return (
        <div>
            <div className="math-block">
                <h3>Transformer 架构概览</h3>
                <p>Transformer 模型由两个核心部分组成:<b>编码器 (Encoder)</b> 和 <b>解码器 (Decoder)</b>. 它的出现革命性地解决了传统循环神经网络(RNN)在处理长序列时难以并行计算和捕捉长期依赖的问题。</p>
                <p><b>编码器的任务</b>是“理解”输入的整个句子(例如,"I am a student"),并将其转化为一组富含上下文信息的数字表示(向量). 这好比一位翻译官在动笔前，完整地阅读并消化了整个原文的含义。</p>
                <p><b>解码器的任务</b>是利用这些数字表示,并结合已经生成的内容,一次一个词地生成目标句子(例如,“我 是 一个 学生”). 这就像翻译官在理解了原文后，开始逐字逐句地写出译文。</p>
                <p>在2017年的原始论文《Attention Is All You Need》中,编码器和解码器都由 N 个相同的层堆叠而成. 这种堆叠结构允许模型在不同层次上学习从简单到复杂的抽象特征。此可视化工具将带您深入探索其内部的数据流动和数学原理。</p>
            </div>

            {/* --- ENCODER EXPLANATIONS --- */}
            <h2 style={{textAlign: 'center', margin: '30px 0'}}>编码器 (Encoder)</h2>
             <MathBlock id="token_embed" title="编码器第0步:分词与词嵌入" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将您在上方控件中输入的自然语言文本,转换为模型可以处理的数值矩阵. 这是所有后续计算的起点,是连接人类语言与机器世界的桥梁。</p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>分词 (Tokenization):</b> 使用简单的空格分词器,将输入句子分解为一个个独立的词元(Token). 真实世界的模型（如BERT, GPT）会使用更复杂的分词算法（如WordPiece, BPE）来处理未知词和构词法。</li>
                    <li><b>ID映射 (ID Mapping):</b> 使用一个预先构建好的词汇表(Vocabulary),将每个词元映射到一个唯一的整数ID. 任何未知的词汇都会被映射为 <code>[UNK]</code> (Unknown). 这个词汇表是在模型训练前通过扫描海量文本语料库构建的。</li>
                    <li><b>词嵌入 (Embedding Lookup):</b> 使用一个巨大的、可学习的“查询表”(Embedding Matrix),根据每个词元的ID,从中“提取”出对应的向量. 这个向量就是该词元的初始数值表示。</li>
                </ol>
                <h5>深入理解:从文本到向量的“魔法”</h5>
                <p>您可能会问:“一个词(比如'student')是如何变成一长串数字(向量)的？” 关键在于那块巨大的 <b>词嵌入矩阵 (Embedding Matrix)</b>. </p>
                <p>您可以把这个矩阵想象成一本**模型在训练中自己学会编写的“超级词典”**:</p>
                <ul>
                    <li><b>词条编号 (Token ID):</b> 词汇表中的每个词都有一个独一无二的ID,比如 `student` 的ID是 `6`. 这就像是词典里的页码或词条号. </li>
                    <li><b>词条释义 (Embedding Vector):</b> 矩阵中**第 `6` 行**的那一整行向量,就是 `student` 这个词的“释义”. 这个释义不是用人类语言写的,而是用一串数字(例如一个长度为 {dims.d_model} 的向量)来定义的。这个向量捕捉了 `student` 这个词的丰富语义信息——它和 `school`、`learn` 在语义空间中比较接近,但和 `apple`、`sky` 比较疏远。这种将离散的词语映射到连续向量空间的过程，使得模型能够理解和利用词语之间的语义关系。</li>
                </ul>
                <p>所以,整个过程并不是“计算”出一个向量,而是一个高效的**“查词典”**的过程. 模型通过海量数据的训练,学会了如何为每个词编写最精准的、富含信息的“数字释义”,我们在这里只是根据ID去查询而已. </p>
            </MathBlock>
            <MathBlock id="input_embed" title="编码器第1步:输入预处理" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将输入的文本序列(一串文字)转换为模型可以处理的、包含“词义”和“位置”信息的数值向量矩阵. 当前输入序列长度为 {dims.encoder_seq_len},模型维度 <InlineMath math={`d_{model}=${dims.d_model}`}/>. </p>
                <h5>为什么需要位置编码?</h5>
                <p>Transformer的核心机制——自注意力(Self-Attention)，在处理输入时是“无视顺序”的。也就是说，打乱输入句子中词的顺序，自注意力的计算结果不会改变。但这显然不符合自然语言的规律（“学生是我”和“我是学生”含义完全不同）。因此，我们需要一种方法告诉模型每个词在句子中的位置。<b>位置编码 (Positional Encoding)</b> 就是为了解决这个问题而生的。</p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>词嵌入 (Token Embedding):</b> 从上一步获得的矩阵,代表了每个词的“词义”. </li>
                    <li><b>位置编码 (Positional Encoding):</b> 为模型注入关于序列顺序的绝对位置信息. 这是一个固定的、根据三角函数(sine 和 cosine)生成的矩阵。这种设计允许模型轻易地学习到相对位置关系，并且理论上可以扩展到比训练时更长的序列。</li>
                    <li><b>逐元素相加:</b> 将词义信息和位置信息相加，得到编码器最终的输入表示 <InlineMath math="Z"/>. </li>
                </ol>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.inputEmbeddings} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.posEncodings} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="mha" title="编码器子层1:多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此机制的核心目的是计算句子中每个词与其他所有词的“关注度”或“相关性”,并根据这个关注度重新计算每个词的向量表示,从而让每个词的向量都融入其上下文信息。例如，在句子 "The animal didn't cross the street because it was too tired" 中，自注意力能帮助模型理解 "it" 指的是 "animal" 而不是 "street"。</p>
                <h5>输入矩阵 (Input Matrix)</h5>
                <div className="formula-display">
                    <InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false} sideLabel={true} />
                </div>
                <h5>计算流程 (以单个注意力头为例)</h5>
                 <p>输入矩阵 <InlineMath math="Z"/> 被并行地送入 {dims.h} 个独立的注意力头. 每个头都拥有三块自己专属、可学习的权重矩阵. 通过矩阵乘法,将输入 <InlineMath math="Z"/> 投影到三个新的矩阵:查询 (Query, <InlineMath math="Q"/>), 键 (Key, <InlineMath math="K"/>), 和 值 (Value, <InlineMath math="V"/>)。这可以类比于一个信息检索系统：</p>
                 <ul>
                    <li><b>Query (Q):</b> 代表当前词为了更好地理解自己，向其他词发出的“查询请求”。例如，"it" 这个词的Query向量可能在问：“句子中谁可能是疲惫的？”</li>
                    <li><b>Key (K):</b> 代表句子中每个词用于被检索的“标签”或“索引”。例如，"animal" 这个词的Key向量会表明：“我是一个名词，一个生物。”</li>
                    <li><b>Value (V):</b> 代表每个词实际携带的“内容”或“信息”。</li>
                 </ul>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.Q} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>然后计算注意力分数, 进行缩放和Softmax得到权重, 最后加权求和。 <InlineMath math="Q"/> 和 <InlineMath math="K"/> 的点积计算了每个词的“查询”与所有词的“标签”之间的相似度。除以 <InlineMath math="\sqrt{d_k}"/> 是为了在训练中保持梯度稳定。Softmax则将这些原始的相似度分数转换成一个和为1的概率分布，即“注意力权重”。最后，将这些权重与 <InlineMath math="V"/> 相乘，相当于对所有词的信息进行加权求和，得到一个融合了全句上下文信息的新向量。</p>
                <BlockMath math={`A = \\text{Softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)`} />
                <BlockMath math={`H = A V`} />
                 <div className="formula-display vertical">
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNe.AttentionWeights} rows={dims.encoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.HeadOutput} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <h5>拼接与最终投影</h5>
                <p>“多头”的“多”体现在这里。{dims.h} 个头并行地执行上述计算，每个头都可能关注到输入关系的不同方面（比如有的头关注语法关系，有的头关注语义关系）。最后，将所有 {dims.h} 个头的输出矩阵 <InlineMath math="H_i"/> 拼接 (Concatenate) 起来, 然后通过一个最终的投影权重矩阵 <InlineMath math="W^O"/> 将其维度变回 <InlineMath math="d_{model}"/>，得到该子层的最终输出 <InlineMath math="M"/>。</p>
                 <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNe.Wo} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNe.mha_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_1" title="组件:残差连接与层归一化 (1)" highlight={highlight}>
                <p>在每个子层之后,都会跟随一个“Add & Norm”模块. 它包含两个关键步骤:<b>残差连接 (Residual Connection)</b> 和 <b>层归一化 (Layer Normalization)</b>。这是训练深度神经网络的关键技巧。</p>
                <ul>
                    <li><b>残差连接:</b> 将子层的输入与输出直接相加。这创建了一条信息的“高速公路”，允许梯度在反向传播时直接流过，极大地缓解了深度网络中的梯度消失问题，使得训练更深的模型成为可能。它也保证了即使子层（如注意力）的输出为零，原始信息也能得以保留。</li>
                    <li><b>层归一化:</b> 对残差连接后的结果进行归一化，使其均值为0，方差为1。这有助于稳定每一层的输入分布，减少所谓的“内部协变量偏移”(Internal Covariate Shift)，从而加速训练过程并提高模型的泛化能力。</li>
                </ul>
                <BlockMath math={`Z' = \\text{LayerNorm}(Z + \\text{MultiHeadAttention}(Z))`} />
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.mha_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="ffn" title="编码器子层2:位置前馈网络" highlight={highlight}>
                <p>前馈网络 (FFN) 对每个位置的向量独立地进行一次复杂的非线性变换,极大地增加了模型的表达能力。如果说自注意力层是负责在不同词之间“交流和汇总信息”，那么FFN层就是每个词在接收了上下文信息后，进行独立的“深入思考和加工”。</p>
                <p>它由两个线性层和一个ReLU激活函数组成。第一个线性层将维度从 <InlineMath math="d_{model}"/> 扩展到 <InlineMath math="d_{ff}"/> (通常是 <InlineMath math="4 \times d_{model}"/>), ReLU引入非线性，然后第二个线性层再将其投影回 <InlineMath math="d_{model}"/> 维度。这种“扩展-激活-压缩”的结构被证明在增强模型表示能力方面非常有效。</p>
                <BlockMath math={`F = \\text{ReLU}(Z' W_1 + b_1) W_2 + b_2`} />
                <h5>第一次线性变换 & ReLU</h5>
                <div className={`formula-display ${shouldBreakFFN1 ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNe.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                 <div className="formula-display vertical">
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Intermediate} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Activated} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                </div>
                <h5>第二次线性变换</h5>
                <div className={`formula-display ${shouldBreakFFN2 ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Activated} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.W2} rows={dims.d_ff} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNe.b2} data={Array(dims.d_model).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="="/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.ffn_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_2" title="组件:残差连接与层归一化 (2)" highlight={highlight}>
                <p>与第一个 "Add & Norm" 层完全相同,此步骤将 FFN 子层的输出与输入结合,产生该编码器层的最终输出。经过这一步，一个完整的编码器层就完成了它的使命：接收一组向量表示，并通过自注意力和前馈网络对其进行信息提炼和加工，最终输出一组包含了更丰富上下文信息的新向量表示。这个输出将作为下一个编码器层的输入，或者在最后一层，成为整个编码器的最终输出。</p>
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.ffn_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_2_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>

            {/* --- DECODER EXPLANATIONS --- */}
            <h2 style={{textAlign: 'center', margin: '30px 0'}}>解码器 (Decoder)</h2>
            <MathBlock id="output_embed" title="解码器第1步:输出预处理" highlight={highlight}>
                 <h5>做什么？</h5>
                <p>此步骤与编码器输入预处理类似,但作用于目标语言序列(即解码器要生成的内容). 它将目标序列(通常是已经生成的词加上一个起始符 <code>&lt;SOS&gt;</code>)转换为模型可以处理的数值向量矩阵。在推理（生成）阶段，解码器的输入是它上一步自己生成的词。</p>
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputEmbeddings} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.decoderPosEncodings} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.decoder_input} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="masked_mha" title="解码器子层1:带掩码的多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是解码器的第一个关键子层. 它与编码器的自注意力机制几乎完全相同,但有一个至关重要的区别:<b>前瞻遮罩 (Look-Ahead Mask)</b>. </p>
                <h5>设计思路</h5>
                <p>在生成任务中,模型在预测第 <code>i</code> 个词时,只能看到第 <code>i</code> 个词之前(包括第 <code>i</code> 个词)的内容,绝不能“偷看”未来的词。这模拟了人类说话或写作时，无法预知下一个要说什么词的自然过程。为了在并行的矩阵运算中实现这一点,我们在计算注意力分数后,会应用一个遮罩. 这个遮罩将分数矩阵 <InlineMath math="S"/> 的上三角部分(代表未来位置)设置为一个非常大的负数(-∞). 这样,在经过 Softmax 运算后,这些位置的注意力权重将变为0,从而确保了模型无法关注未来的信息. 这就是所谓的“自回归”(Auto-regressive)特性。</p>
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_masked.Scores} rows={dims.decoder_seq_len} cols={dims.decoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math={`\\xrightarrow{\\text{Mask}}`} />
                    <p>上三角区域被设为-∞</p>
                </div>
                 <h5>计算流程</h5>
                <p>除了应用掩码外,后续计算与编码器自注意力完全相同.</p>
                <BlockMath math={`H = \\text{Softmax}\\left(\\text{Mask}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)\\right) V`} />
                 <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNd.Wo_masked} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNd.masked_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_1_dec" title="解码器组件:残差连接与层归一化 (1)" highlight={highlight}>
                <p>此模块接收解码器输入 <InlineMath math="Y"/> 和带掩码自注意力子层的输出 <InlineMath math="M_{mmha}"/>,将它们相加后进行层归一化。其原理和作用与编码器中的 Add & Norm 模块完全一致，旨在稳定训练并保留信息。</p>
                <BlockMath math={`Y' = \\text{LayerNorm}(Y + \\text{Masked-MHA}(Y))`} />
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.decoder_input} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.masked_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
             <MathBlock id="enc_dec_mha" title="解码器子层2:编码器-解码器注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是连接编码器和解码器的桥梁,也是 Transformer 架构的精髓所在. 在这一层,解码器会“审视”编码器的全部输出,并判断输入序列中的哪些部分对于生成当前目标词最重要。这也被称为“交叉注意力”(Cross-Attention)。</p>
                 <h5>输入矩阵</h5>
                 <div className="formula-display vertical">
                    <div>
                        <p style={{textAlign: 'center', marginBottom: '5px'}}>Query Input (from Decoder):</p>
                        <InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false} sideLabel={true}/>
                    </div>
                     <div style={{marginTop: '15px'}}>
                        <p style={{textAlign: 'center', marginBottom: '5px'}}>Key/Value Input (from Encoder):</p>
                        <InteractiveSymbolicMatrix name={FinalLNe.add_norm_2_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false} sideLabel={true}/>
                    </div>
                 </div>
                 <h5>计算流程 (以单个注意力头为例)</h5>
                <ol>
                    <li><b>Query (<InlineMath math="Q"/>)</b>: 来自解码器前一层的输出 (<InlineMath math="Y'"/>). 它代表了“我当前需要什么信息来生成下一个词？”。这个查询是基于解码器已经生成的内容。</li>
                    <li><b>Key (<InlineMath math="K"/>) 和 Value (<InlineMath math="V"/>)</b>: <b>均来自编码器的最终输出 (<InlineMath math="Z_{final}"/>)</b>. 它们代表了整个输入序列的、经过深度处理的上下文信息。</li>
                </ol>
                 <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="Y'" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z_{final}" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z_{final}" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>通过计算 <InlineMath math="Q_{dec} \cdot K_{enc}^T"/>,解码器能够评估其当前的生成需求与输入序列中每个词的相关性,然后利用这个相关性(注意力权重)从 <InlineMath math="V_{enc}"/> 中加权提取最需要的信息来辅助生成。例如，在将 "I am a student" 翻译成中文时，当解码器准备生成“学生”时，它的 Query 会与编码器输出中 "student" 对应的 Key 产生很高的相似度，从而更多地关注 "student" 的 Value 信息。</p>
                <h5>注意力计算与输出</h5>
                <div className={`formula-display ${shouldBreakEncDecScores ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} transpose={true}/></div>
                    <BlockMath math="\xrightarrow{\text{Scale + Softmax}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.AttentionWeights} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                 <div className={`formula-display ${shouldBreakEncDecHeadOutput ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.AttentionWeights} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.HeadOutput} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                 <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNd.Wo_enc_dec} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNd.enc_dec_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_2_dec" title="解码器组件:残差连接与层归一化 (2)" highlight={highlight}>
                <p>此步骤结合了编码器-解码器注意力子层的输入 (<InlineMath math="Y'"/>) 与其输出 (<InlineMath math="M_{ed}"/>),并进行层归一化,以稳定训练过程并融合来自编码器的信息。这是解码器层中信息融合的关键一步。</p>
                 <BlockMath math={`Y'' = \\text{LayerNorm}(Y' + \\text{Enc-Dec-MHA}(Y', Z_{final}))`} />
                  <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.enc_dec_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="ffn_dec" title="解码器子层3:前馈网络" highlight={highlight}>
                <p>与编码器中的 FFN 类似,解码器中的前馈网络 (FFN) 也对每个位置的向量 (<InlineMath math="Y''"/>) 独立地进行一次复杂的非线性变换,进一步增强模型的表达能力,为最终的输出预测做准备。在这一步，模型对融合了自身历史信息和编码器上下文信息的新向量进行深入的、非线性的“思考”。</p>
                <BlockMath math={`F = \\text{ReLU}(Y'' W_1 + b_1) W_2 + b_2`} />
                 <div className="formula-display vertical">
                     <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                    <BlockMath math="\times"/>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="viz-formula-row"><InteractiveSymbolicVector name={LNd.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.Activated} rows={dims.decoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_3_dec" title="解码器组件:残差连接与层归一化 (3)" highlight={highlight}>
                 <p>这是解码器层中的最后一个 Add & Norm 步骤,它将 FFN 的输入 (<InlineMath math="Y''"/>) 与其输出 (<InlineMath math="F"/>) 相结合,产生该解码器层的最终输出 <InlineMath math="Y_{final}"/>. 这个输出将作为下一个解码器层的输入，或者在最后一层，将进入最终的预测阶段。</p>
                 <BlockMath math={`Y_{final} = \\text{LayerNorm}(Y'' + \\text{FFN}(Y''))`} />
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.ffn_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_3_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
             <MathBlock id="final_output" title="最终输出层:线性层与Softmax" highlight={highlight}>
                <h5>做什么？</h5>
                <p>在经过所有解码器层的处理后,我们得到一个最终的输出矩阵。此步骤将其转换为每个位置上词汇表中所有单词的概率分布，将模型内部的抽象表示映射回人类可理解的词汇空间。</p>
                 <h5>计算流程</h5>
                <ol>
                    <li><b>线性层 (Linear Layer):</b> 将解码器输出矩阵通过一个大的线性投影层,将其维度从 <InlineMath math="d_{model}"/> 扩展到词汇表大小 (<InlineMath math="V_{size}"/>). 这会为每个位置生成一个分数向量,称为 Logits。这个Logits向量的每个元素对应词汇表中的一个词，其数值代表模型认为该词是下一个正确词的“置信度分数”，分数越高，可能性越大。</li>
                    <li><b>Softmax:</b> 对 Logits 矩阵的每一行应用 Softmax 函数,将其转换为规范的概率分布。转换后，每一行的所有元素和为1，每个元素代表对应单词的出现概率。</li>
                </ol>
                 <div className={`formula-display ${shouldBreakFinalOutput ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={FinalLNd.add_norm_3_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.finalLinear} rows={dims.d_model} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                 </div>
                 <div className="formula-display">
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.logits} rows={dims.decoder_seq_len} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                    <BlockMath math="\xrightarrow{\text{Softmax}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputProbabilities} rows={dims.decoder_seq_len} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                </div>
                 <p>现在,矩阵 <InlineMath math="P"/> 中的每一行都是一个概率分布,代表了在那个位置上生成词汇表中任何一个单词的可能性. </p>
            </MathBlock>
            <MathBlock id="decoding" title="最终解码:Argmax 与文本生成" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是生成过程的最后一步,将代表概率的数字变回人类可读的文本. </p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>Argmax:</b> 对概率矩阵 <InlineMath math="P"/> 的每一行,找到其中概率值最大的那个元素的<b>索引 (index)</b>. 这个索引就对应了词汇表中该位置最有可能的词元ID. 这个过程通常被称为“贪心解码 (Greedy Decoding)”. </li>
                    <li><b>ID到文本映射:</b> 将得到的词元ID序列,通过反向查询词汇表,映射回原始的文本词元. </li>
                </ol>
                <h5>深入理解:从向量到文本的“翻译”</h5>
                <p>这里是“魔法”发生逆转的地方. 我们手上有一个 <b>概率矩阵</b> <code>P</code>,它告诉我们在每个输出位置上,词汇表里每个单词的可能性. </p>
                <p>以第一个输出位置为例,我们关注矩阵 <code>P</code> 的<b>第一行</b> (下标为0的那一行). 这一行是一个概率向量,其长度等于整个词汇表的大小. 向量中第 <code>j</code> 个位置的数值,就代表词汇表中 ID 为 <code>j</code> 的单词是正确答案的概率. </p>
                <p><b>Argmax</b> 函数的作用非常简单:它会扫描这一整行,找到那个最大的概率值,然后返回它的<b>位置索引</b>. 这个索引就是模型预测出的 <b>Token ID！</b></p>
                <p>虽然贪心解码简单高效，但它只关注当前步的最优选择，可能会错失全局最优解。更高级的解码策略，如<b>集束搜索 (Beam Search)</b>，会同时保留多个最可能的候选序列，在生成结束时选择整体概率最高的序列，通常能产生更流畅、更合理的文本。</p>
                <p>最后一步,我们拿着这个ID,去反查我们的“超级词典”(词汇表),就能找到ID对应的单词. 于是,模型就成功地将一串概率数字“翻译”回了人类能懂的单词. 对每一行都重复这个过程,就能生成整个句子. </p>
            </MathBlock>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/Explanation.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/FeedForward.tsx
================================================================================

// FILE: src/components/FeedForward.tsx
import React from 'react';
import { FFNData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface FFNProps {
    baseName: string;
    input: MatrixType;
    inputName: string;
    data: FFNData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const FeedForward: React.FC<FFNProps> = ({ baseName, input, inputName, data, highlight, onElementClick, onComponentClick }) => {
    const isEncoder = baseName.includes('encoder');
    const componentId = isEncoder ? 'ffn' : 'ffn_dec';
    const isActive = highlight.activeComponent === componentId;
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const LN = isEncoder ? MATRIX_NAMES.layer(layerIndex) : MATRIX_NAMES.decoderLayer(layerIndex);

    // --- Layout Breaking Logic ---
    const inputCols1 = input[0]?.length || 0;
    const w1Cols = data.W1[0]?.length || 0;
    const breakStep1 = inputCols1 > 8 || w1Cols > 8 || (inputCols1 + w1Cols > 15);

    const activatedCols = data.Activated[0]?.length || 0;
    const w2Cols = data.W2[0]?.length || 0;
    const breakStep2 = activatedCols > 8 || w2Cols > 8 || (activatedCols + w2Cols > 15);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick(componentId)}>Feed-Forward Network</div>
            <div className="component-body">
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. First Linear Layer & ReLU</div>
                     <div className={`viz-formula-row ${breakStep1 ? 'vertical' : ''}`}>
                         <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                         <span className="op-symbol">×</span>
                         <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b1} data={[data.b1]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.Intermediate} data={data.Intermediate} highlight={highlight} onElementClick={onElementClick} />
                    </div>

                    <ElementwiseOperation
                        opType="relu"
                        inputMatrix={data.Intermediate}
                        inputMatrixName={LN.Intermediate} // [FIXED] Pass the input matrix name
                        outputMatrix={data.Activated}
                        outputMatrixName={LN.Activated}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Second Linear Layer</div>
                    <div className={`viz-formula-row ${breakStep2 ? 'vertical' : ''}`}>
                        <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                        <span className="op-symbol">×</span>
                        <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b2} data={[data.b2]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LN.ffn_output} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/FeedForward.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicElement.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicElement.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { HighlightState } from '../types';
import { useHighlighting } from '../hooks/useHighlighting';

interface InteractiveSymbolicElementProps {
  name: string; // [ADDED] Pass the full matrix name for the hook
  base: string;
  subscript?: string;
  row?: number;
  col?: number;
  highlight: HighlightState; // [ADDED] Pass the full highlight state
  onClick: (event: React.MouseEvent) => void;
}

export const InteractiveSymbolicElement: React.FC<InteractiveSymbolicElementProps> = React.memo(({ name, base, subscript, row, col, highlight, onClick }) => {
  // [MODIFIED] Centralized highlighting logic by using the new hook.
  // We handle undefined row/col for vectors.
  // [FIXED] Removed the 5th argument 'true' which caused the compilation error.
  const { isTarget, isSource, isDestination } = useHighlighting(name, row ?? 0, col ?? 0, highlight);

  const elementBase = base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
  const subscriptContent = [subscript, row, col].filter(s => s !== undefined && s !== null).join(',');
  const mathString = `${elementBase}_{${subscriptContent}}`;

  const className = `symbolic-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''} ${isDestination ? 'destination' : ''}`;

  return (
    <div className={className} onClick={onClick} style={{cursor: 'pointer'}}>
      <InlineMath math={mathString} />
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicElement.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicMatrix.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/InteractiveSymbolicMatrix.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicMatrixProps {
  name: string;
  rows: number;
  cols: number;
  highlight: HighlightState;
  transpose?: boolean;
  truncate?: boolean;
  onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  sideLabel?: boolean; // For explicit override
}

export const InteractiveSymbolicMatrix: React.FC<InteractiveSymbolicMatrixProps> = React.memo(({ name, rows, cols, highlight, transpose = false, truncate = true, onSymbolClick, sideLabel = false }) => {
  const displayRows = transpose ? cols : rows;
  const displayCols = transpose ? rows : cols;
  const symbol = getSymbolParts(name);

  let focusRow = -1;
  let focusCol = -1;

  if (highlight.target?.name === name) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const highlightedTarget = (highlight.target?.name === name) ? highlight.target : null;

  const visibleRowIndices = truncate ? getVisibleIndices(displayRows, transpose ? focusCol : focusRow) : Array.from({ length: displayRows }, (_, i) => i);
  const visibleColIndices = truncate ? getVisibleIndices(displayCols, transpose ? focusRow : focusCol) : Array.from({ length: displayCols }, (_, i) => i);

  const isTargetMatrix = !!highlightedTarget;

  const gridStyle: React.CSSProperties = {
      gridTemplateColumns: isTargetMatrix
          ? `auto repeat(${visibleColIndices.length}, auto)`
          : `repeat(${visibleColIndices.length}, auto)`,
  };


  let mathSymbol = symbol.base;
  if (symbol.superscript) mathSymbol += `^{${symbol.superscript}}`;
  if (transpose) mathSymbol += '^T';

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`${rows} \\times ${cols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;

  const matrixGrid = (
      <div className="symbolic-matrix-grid" style={gridStyle}>
        {isTargetMatrix && <div key="corner" />}
        {isTargetMatrix && visibleColIndices.map((c, cIdx) => (
            <div key={`ch-${cIdx}`} className="symbolic-header-item">{c}</div>
        ))}
        {visibleRowIndices.map((r, rIdx) => (
            <React.Fragment key={`row-frag-${rIdx}`}>
                {isTargetMatrix && <div className="symbolic-header-item">{r}</div>}
                {visibleColIndices.map((c, cIdx) => {
                     if (r === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                     if (c === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
                    const originalRow = transpose ? c : r;
                    const originalCol = transpose ? r : c;
                    return (
                        <InteractiveSymbolicElement
                            key={`elem-r${r}-c${c}`}
                            name={name}
                            base={symbol.base}
                            subscript={symbol.subscript}
                            row={originalRow}
                            col={originalCol}
                            highlight={highlight}
                            onClick={(event) => onSymbolClick({ name, row: originalRow, col: originalCol }, event)}
                        />
                    );
                })}
            </React.Fragment>
        ))}
      </div>
  );

  return (
    <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`}>
        <div className="matrix-label-side"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
        <div className="symbolic-matrix-container">
            {matrixGrid}
        </div>
        <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
    </div>
  );
});
// END OF FILE: src/topics/transformer-explorer/components/InteractiveSymbolicMatrix.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicVector.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/InteractiveSymbolicVector.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { Vector as VectorType } from '../types';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicVectorProps {
  name: string;
  data: VectorType;
  highlight: HighlightState;
  onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  sideLabel?: boolean; // For explicit override
}

export const InteractiveSymbolicVector: React.FC<InteractiveSymbolicVectorProps> = React.memo(({ name, data, highlight, onSymbolClick, sideLabel = false }) => {
  const displayCols = data.length;
  const symbol = getSymbolParts(name);

  let focusCol = -1;
  if (highlight.target?.name === name) {
    focusCol = highlight.target.col;
  }

  const visibleColIndices = getVisibleIndices(displayCols, focusCol);

  const gridElements = visibleColIndices.map((c, cIdx) => {
    if (c === ELLIPSIS) {
        return <div key={`ellipsis-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
    }

    return (
        <InteractiveSymbolicElement
            key={`elem-${c}`}
            name={name}
            base={symbol.base}
            subscript={symbol.subscript}
            col={c}
            highlight={highlight}
            onClick={(event) => onSymbolClick({ name, row: 0, col: c }, event)}
        />
    );
  });

  let mathSymbol = symbol.base;

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`1 \\times ${displayCols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;

  const matrixGrid = (
      <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${gridElements.length}, auto)` }}>
        {gridElements}
      </div>
  );

  return (
    <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`}>
        <div className="matrix-label-side"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
        <div className="symbolic-matrix-container">
            {matrixGrid}
        </div>
        <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
    </div>
  );
});
// END OF FILE: src/topics/transformer-explorer/components/InteractiveSymbolicVector.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/MaskedMultiHeadAttention.tsx
================================================================================

// FILE: src/components/MaskedMultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface MHAProps {
    baseName: string; // e.g., decoder.0.masked_mha
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MaskedMultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick, onComponentClick }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Assume we visualize head 0
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'masked_mha';
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('masked_mha')}>Masked Multi-Head Attention</div>
            <div className="component-body">
                {/* Visualizations for Q, K, V generation */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={HNd_masked.Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={HNd_masked.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={HNd_masked.Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNd_masked.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={HNd_masked.Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNd_masked.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                {/* Scaled Dot-Product Attention */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={HNd_masked.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">= (Scores)</div>
                    <div className="arrow-down" style={{fontSize: '1em', color: '#e63946', fontWeight: 'bold'}}>Apply Look-Ahead Mask</div>
                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        inputMatrixName={HNd_masked.ScaledScores} // [FIXED] Pass the input matrix name
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={HNd_masked.AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={HNd_masked.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                {/* Final Projection */}
                 <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                    <div className="viz-formula-row">
                       <InlineMath math="\text{Concat}(H_0, \dots, H_{N})" />
                     </div>
                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).Wo_masked} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).masked_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

            </div>
        </div>
    );
};
// END OF FILE: src/components/MaskedMultiHeadAttention.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Matrix.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isTransposed?: boolean;
  sideLabel?: boolean; // For explicit override
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, isTransposed = false, sideLabel = false }) => {

  const maxProbCols = React.useMemo(() => {
    const maxCols: { [key: number]: number } = {};
    if (!data) return maxCols;

    const probSources = highlight.sources.filter(s => s.name === name && s.highlightProbCol);
    for (const source of probSources) {
        if (source.row !== -1 && data[source.row]) {
            const rowData = data[source.row];
            const maxVal = Math.max(...rowData);
            maxCols[source.row] = rowData.indexOf(maxVal);
        }
    }
    return maxCols;
  }, [highlight.sources, name, data]);

  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const numRows = data.length;
  const numCols = data[0].length;

  const displayRows = isTransposed ? numCols : numRows;
  const displayCols = isTransposed ? numRows : numCols;

  let focusRow = -1;
  let focusCol = -1;

  if(highlight.target?.name === name && !highlight.target.isInternal) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const relevantSource = highlight.sources.find(s => s.name === name && !s.isInternal);
  if (relevantSource) {
      focusRow = relevantSource.row === -1 ? focusRow : relevantSource.row;
      focusCol = relevantSource.col === -1 ? focusCol : relevantSource.col;
  }

  const relevantDestination = highlight.destinations?.find(d => d.name === name && !d.isInternal);
    if (relevantDestination) {
        focusRow = relevantDestination.row === -1 ? focusRow : relevantDestination.row;
        focusCol = relevantDestination.col === -1 ? focusCol : relevantDestination.col;
    }

  const visibleRowIndices = getVisibleIndices(displayRows, isTransposed ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, isTransposed ? focusRow : focusCol);

  const symbolParts = getSymbolParts(name);
  let mathSymbol = symbolParts.base;
  if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
  if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;
  if(isTransposed) mathSymbol = `${mathSymbol}^T`;

  const isTargetMatrix = highlight.target?.name === name && !highlight.target.isInternal;

   const gridContainerStyle: React.CSSProperties = {
      gridTemplateColumns: isTargetMatrix
          ? `auto repeat(${visibleColIndices.length}, auto)`
          : `repeat(${visibleColIndices.length}, auto)`,
  };

  const matrixGrid = (
      <div className="matrix-container">
        <div className="matrix-grid" data-name={name} style={gridContainerStyle}>
            {isTargetMatrix && <div key="corner" />}
            {isTargetMatrix && visibleColIndices.map((c, cIdx) => (
                <div key={`ch-${cIdx}`} className="matrix-header-item">{c}</div>
            ))}
            {visibleRowIndices.map((r, rIdx) => (
                <React.Fragment key={`row-frag-${rIdx}`}>
                    {isTargetMatrix && <div className="matrix-header-item">{r}</div>}
                    {visibleColIndices.map((c, cIdx) => {
                        if (r === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                        if (c === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">…</div>;
                        const originalRow = isTransposed ? c : r;
                        const originalCol = isTransposed ? r : c;
                        return (
                            <Element
                                key={`${name}-${originalRow}-${originalCol}`}
                                name={name}
                                row={originalRow}
                                col={originalCol}
                                value={data[originalRow][originalCol]}
                                highlight={highlight}
                                onElementClick={onElementClick}
                                isProbMax={maxProbCols[originalRow] === originalCol}
                            />
                        );
                    })}
                </React.Fragment>
            ))}
        </div>
      </div>
  );

  return (
    <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`} data-name={name}>
        <div className="matrix-label-side">
            <div className="matrix-symbol-tag"><InlineMath>{mathSymbol}</InlineMath></div>
        </div>
        {matrixGrid}
        <div className="matrix-label-container">
            <div className="matrix-symbol-tag"><InlineMath>{mathSymbol}</InlineMath></div>
        </div>
    </div>
  );
};
// END OF FILE: src/topics/transformer-explorer/components/Matrix.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/MultiHeadAttention.tsx
================================================================================

// FILE: src/components/MultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface MHAProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick, onComponentClick }) => {
    const headData = data.heads[0];
    const headBaseName = `${baseName}.h0`;
    const isActive = highlight.activeComponent === 'mha';

    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Visualizing head 0
    const LN = MATRIX_NAMES.layer(layerIndex);
    const HNe = MATRIX_NAMES.head(layerIndex, headIndex);
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        // First head
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.head(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);

        if (numHeads > 2) {
             // Middle ellipsis
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            // Last head
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.head(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            // Second head
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.head(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };


    // --- Layout Breaking Logic ---
    const inputCols = data.heads[0].Wq.length;
    const wqCols = headData.Wq[0]?.length || 0;
    const breakQ = inputCols > 8 || wqCols > 8 || (inputCols + wqCols > 15);

    const wkCols = headData.Wk[0]?.length || 0;
    const breakK = inputCols > 8 || wkCols > 8 || (inputCols + wkCols > 15);

    const wvCols = headData.Wv[0]?.length || 0;
    const breakV = inputCols > 8 || wvCols > 8 || (inputCols + wvCols > 15);

    const qCols = headData.Q[0]?.length || 0;
    const kTransposedCols = headData.K.length;
    const breakScores = qCols > 8 || kTransposedCols > 8 || (qCols + kTransposedCols > 15);

    const attnWeightsCols = headData.AttentionWeights[0]?.length || 0;
    const vCols = headData.V[0]?.length || 0;
    const breakHeadOutput = attnWeightsCols > 8 || vCols > 8 || (attnWeightsCols + vCols > 15);

    const headOutputCols = headData.HeadOutput[0]?.length || 0;
    const woCols = data.Wo[0]?.length || 0;
    const breakFinalProj = (headOutputCols * numHeads) > 8 || woCols > 8 || ((headOutputCols * numHeads) + woCols > 15);


    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('mha')}>Multi-Head Attention</div>
            <div className="component-body">

                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                    <div className={`viz-formula-row ${breakQ ? 'vertical' : ''}`}>
                       <span>(Input) ×</span>
                       <Matrix name={HNe.Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={HNe.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className={`viz-formula-row ${breakK ? 'vertical' : ''}`}>
                       <span>(Input) ×</span>
                       <Matrix name={HNe.Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNe.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className={`viz-formula-row ${breakV ? 'vertical' : ''}`}>
                       <span>(Input) ×</span>
                       <Matrix name={HNe.Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNe.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    <div className={`viz-formula-row ${breakScores ? 'vertical' : ''}`}>
                        <Matrix name={HNe.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={HNe.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        inputMatrixName={HNe.ScaledScores} // [FIXED] Pass the input matrix name
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={HNe.AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                        <Matrix name={HNe.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className={`viz-formula-row ${breakHeadOutput ? 'vertical' : ''}`}>
                        <Matrix name={HNe.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={HNe.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                    <div className="viz-formula-row">
                       <InlineMath math="\text{Concat}(" />
                        {renderConcatHeads()}
                       <InlineMath math=")" />
                     </div>

                     <div className={`viz-formula-row ${breakFinalProj ? 'vertical' : ''}`}>
                       <span>(Concatenated) ×</span>
                       <Matrix name={LN.Wo} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={LN.mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/MultiHeadAttention.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/ResidualBlock.tsx
================================================================================

// FILE: src/components/ResidualBlock.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';
import { InlineMath } from 'react-katex';

interface ResidualBlockProps {
  id: string; // e.g., "res1"
  type: 'start' | 'end';
  matrixSymbol: string;
  matrixDims: string;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const ResidualBlock: React.FC<ResidualBlockProps> = ({ id, type, matrixSymbol, matrixDims, highlight, onElementClick }) => {
  const isActive = highlight.activeResidual === id;
  const isStart = type === 'start';
  const icon = isStart ? '↓' : '←'; // [MODIFIED] Changed end icon to left arrow

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({
      name: `residual.${id}.${type}`,
      row: -1,
      col: -1,
      matrixSymbol,
      matrixDims,
    }, event);
  };

  return (
    <div
      className={`residual-block ${isActive ? 'active' : ''}`}
      onClick={handleClick}
      title={`Residual Connection (${matrixSymbol})`}
    >
      <div className="residual-icon">{icon}</div>
      <div className="residual-info">
          <div className="residual-matrix-symbol"><InlineMath math={matrixSymbol} /></div>
          <div className="residual-matrix-dims">{matrixDims}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/ResidualBlock.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Token.tsx
================================================================================

// FILE: src/components/Token.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';

interface TokenProps {
  tokenStr: string;
  tokenId: number;
  position: number;
  name: string; // "inputToken" or "outputToken"
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const Token: React.FC<TokenProps> = ({
  tokenStr,
  tokenId,
  position,
  name,
  highlight,
  onElementClick,
}) => {
  const isTarget =
    highlight.target?.name === name && highlight.target?.row === position;
  const isSource = highlight.sources.some(
    (s) => s.name === name && s.row === position
  );

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({ name, row: position, col: -1, tokenStr, tokenId }, event);
  };

  const className = `token-container ${isTarget ? 'target' : ''} ${
    isSource ? 'source' : ''
  }`;

  return (
    <div className={className} onClick={handleClick}>
      <div className="token-text">{tokenStr}</div>
      <div className="token-id">ID: {tokenId}</div>
    </div>
  );
};
// END OF FILE: src/components/Token.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/TokenizationEmbedding.tsx
================================================================================

// FILE: src/components/TokenizationEmbedding.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EmbeddingLookup } from './EmbeddingLookup';

interface TokenizationEmbeddingProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    isActive: boolean;
}

export const TokenizationEmbedding: React.FC<TokenizationEmbeddingProps> = ({ data, highlight, onElementClick, onComponentClick, isActive }) => {
    // Create a list of ElementIdentifier for the input tokens
    const inputTokensForLookup: ElementIdentifier[] = data.inputText.map((token, i) => ({
        name: "inputToken",
        row: i,
        col: -1, // Not a cell in a matrix
        tokenId: data.tokenizedInput[i],
        tokenStr: token
    }));

    const shouldBreak = (data.embeddingMatrix[0]?.length || 0) > 10;

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('token_embed')}>Input: Tokenization & Embedding Lookup</div>
            <div className="component-body">
                <div className="viz-step-title">1. Text is tokenized, then each Token ID looks up its vector in the Embedding Matrix</div>
                <p style={{textAlign: 'center', margin: '0 0 10px 0', fontSize: '0.9em', color: '#555'}}>Click a Token to see its corresponding row in the Embedding Matrix.</p>
                <EmbeddingLookup
                    mode="token-to-vector"
                    tokens={inputTokensForLookup}
                    embeddingMatrix={data.embeddingMatrix}
                    matrixName="embeddingMatrix"
                    outputVectors={data.inputEmbeddings}
                    outputMatrixName="inputEmbeddings"
                    highlight={highlight}
                    onElementClick={onElementClick}
                    shouldBreak={shouldBreak}
                />
            </div>
        </div>
    );
};
// END OF FILE: src/components/TokenizationEmbedding.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Viz.tsx
================================================================================

// FILE: src/components/Viz.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EncoderLayer } from './EncoderLayer';
import { DecoderLayer } from './DecoderLayer';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { TokenizationEmbedding } from './TokenizationEmbedding';
import { Decoding } from './Decoding';
import { MATRIX_NAMES } from '../config/matrixNames';

interface VizProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const Viz: React.FC<VizProps> = ({ data, highlight, onElementClick, onComponentClick }) => {
    const isTokenEmbedActive = highlight.activeComponent === 'token_embed';
    const isInputEmbedActive = highlight.activeComponent === 'input_embed';
    const isOutputEmbedActive = highlight.activeComponent === 'output_embed';
    const isFinalOutputActive = highlight.activeComponent === 'final_output';
    const isDecodingActive = highlight.activeComponent === 'decoding';

    const cols = data.inputEmbeddings[0]?.length || 0;
    const shouldBreak = cols > 15;

    return (
        <div style={{ position: 'relative' }}>
            {/* Tooltip is now managed in App.tsx to sit on top of the entire layout */}

            {/* --- Input Stage --- */}
            <TokenizationEmbedding
                data={data}
                highlight={highlight}
                onElementClick={onElementClick}
                onComponentClick={onComponentClick}
                isActive={isTokenEmbedActive}
            />

            <div className="arrow-down">↓</div>

            {/* --- Encoder Side --- */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('input_embed')}>Positional Encoding Addition</div>
                <div className="component-body">
                    {shouldBreak ? (
                         <>
                            <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                            <div className="op-symbol">+</div>
                            <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                         </>
                    ) : (
                        <div className="viz-formula-row">
                             <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                             <div className="op-symbol">+</div>
                             <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                </div>
            </div>

            <div className="arrow-down">↓</div>

            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                 <div className="component-header" onClick={() => onComponentClick('input_embed')}>Encoder Input (<InlineMath math="Z" />)</div>
                <div className="component-body">
                     <Matrix name={MATRIX_NAMES.layer(0).encoder_input} data={data.encoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.encoderLayers.map((layer, i) => (
                <EncoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
            ))}

            {/* --- Decoder Side --- */}
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`} style={{marginTop: '30px'}}>
                <div className="component-header" onClick={() => onComponentClick('output_embed')}>Decoder Input & Positional Encoding</div>
                <div className="component-body">
                     <div className="viz-formula-row">
                         <Matrix name="outputEmbeddings" data={data.outputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                         <div className="op-symbol">+</div>
                         <Matrix name="decoderPosEncodings" data={data.decoderPosEncodings} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
            <div className="arrow-down">↓</div>
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('output_embed')}>Decoder Input (<InlineMath math="Y" />)</div>
                <div className="component-body">
                     <Matrix name={MATRIX_NAMES.decoderLayer(0).decoder_input} data={data.decoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.decoderLayers.map((layer, i) => (
                <DecoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    finalEncoderOutput={data.finalEncoderOutput}
                />
            ))}

            {/* --- Final Output --- */}
            <div className="arrow-down">↓</div>
             <div className={`diagram-component ${isFinalOutputActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('final_output')}>Final Linear & Softmax</div>
                <div className="component-body">
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.decoderLayer(data.decoderLayers.length - 1).add_norm_3_output} data={data.finalDecoderOutput} highlight={highlight} onElementClick={onElementClick} />
                         <div className="op-symbol">×</div>
                         <Matrix name="finalLinear" data={data.finalLinear} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">= (Logits)</div>
                    <Matrix name="logits" data={data.logits} highlight={highlight} onElementClick={onElementClick} />
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Softmax}}" /></div>
                    <Matrix name="outputProbabilities" data={data.outputProbabilities} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {/* --- Decoding Stage --- */}
            <div className="arrow-down">↓</div>
            <Decoding
                data={data}
                highlight={highlight}
                onElementClick={onElementClick}
                onComponentClick={onComponentClick}
                isActive={isDecodingActive}
            />

        </div>
    );
};
// END OF FILE: src/components/Viz.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/config/matrixNames.ts
================================================================================

// FILE: src/config/matrixNames.ts
// This file is the single source of truth for all matrix and vector names.

const generateHeadNames = (base: string) => ({
    Wq: `${base}.Wq`, Wk: `${base}.Wk`, Wv: `${base}.Wv`,
    Q: `${base}.Q`, K: `${base}.K`, V: `${base}.V`,
    Scores: `${base}.Scores`, ScaledScores: `${base}.ScaledScores`,
    AttentionWeights: `${base}.AttentionWeights`, HeadOutput: `${base}.HeadOutput`,
});

export const MATRIX_NAMES = {
    // Input
    inputEmbeddings: 'inputEmbeddings',
    posEncodings: 'posEncodings',
    encoderInput: 'encoderInput', // Deprecated, use layer(0).encoder_input
    finalEncoderOutput: 'finalEncoderOutput',

    // Encoder Layer
    layer: (layerIndex: number) => ({
        encoder_input: `encoder.${layerIndex}.encoder_input`,
        mha_output: `encoder.${layerIndex}.mha.output`,
        Wo: `encoder.${layerIndex}.mha.Wo`,
        add_norm_1_output: `encoder.${layerIndex}.add_norm_1_output`,
        W1: `encoder.${layerIndex}.ffn.W1`, b1: `encoder.${layerIndex}.ffn.b1`,
        Intermediate: `encoder.${layerIndex}.ffn.Intermediate`, Activated: `encoder.${layerIndex}.ffn.Activated`,
        W2: `encoder.${layerIndex}.ffn.W2`, b2: `encoder.${layerIndex}.ffn.b2`,
        ffn_output: `encoder.${layerIndex}.ffn.output`,
        add_norm_2_output: `encoder.${layerIndex}.add_norm_2_output`,
    }),

    // Encoder Head
    head: (layerIndex: number, headIndex: number) => generateHeadNames(`encoder.${layerIndex}.mha.h${headIndex}`),
    concatOutput: (layerIndex: number) => `encoder.${layerIndex}.mha.ConcatOutput`,

    // Decoder Input
    outputEmbeddings: 'outputEmbeddings',
    decoderPosEncodings: 'decoderPosEncodings',
    decoderInput: 'decoderInput', // Deprecated, use decoderLayer(0).decoder_input

    // Decoder Layer
    decoderLayer: (layerIndex: number) => ({
        decoder_input: `decoder.${layerIndex}.decoder_input`,

        masked_mha_output: `decoder.${layerIndex}.masked_mha.output`,
        Wo_masked: `decoder.${layerIndex}.masked_mha.Wo`,
        add_norm_1_output: `decoder.${layerIndex}.add_norm_1_output`,

        enc_dec_mha_output: `decoder.${layerIndex}.enc_dec_mha.output`,
        Wo_enc_dec: `decoder.${layerIndex}.enc_dec_mha.Wo`,
        add_norm_2_output: `decoder.${layerIndex}.add_norm_2_output`,

        W1: `decoder.${layerIndex}.ffn.W1`, b1: `decoder.${layerIndex}.ffn.b1`,
        Intermediate: `decoder.${layerIndex}.ffn.Intermediate`, Activated: `decoder.${layerIndex}.ffn.Activated`,
        W2: `decoder.${layerIndex}.ffn.W2`, b2: `decoder.${layerIndex}.ffn.b2`,
        ffn_output: `decoder.${layerIndex}.ffn.output`,
        add_norm_3_output: `decoder.${layerIndex}.add_norm_3_output`,
    }),

    // Decoder Heads
    maskedMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.masked_mha.h${headIndex}`),
    encDecMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.enc_dec_mha.h${headIndex}`),

    // Final Output
    finalLinear: 'finalLinear',
    logits: 'logits',
    outputProbabilities: 'outputProbabilities',
};
// END OF FILE: src/config/matrixNames.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/config/symbolMapping.ts
================================================================================

// FILE: src/config/symbolMapping.ts

// This file is the single source of truth for mapping a matrix's unique name
// to its mathematical symbol parts for consistent rendering.

interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

const SYMBOL_CONFIG: { [key: string]: SymbolParts } = {
    // Input
    inputEmbeddings: { base: 'E' },
    posEncodings: { base: 'PE' },
    encoderInput: { base: 'Z' }, // Z_0
    encoder_input: { base: 'Z' },

    // MHA Weights
    Wq: { base: 'W', superscript: 'Q' },
    Wk: { base: 'W', superscript: 'K' },
    Wv: { base: 'W', superscript: 'V' },
    Wo: { base: 'W', superscript: 'O' },

    // MHA Tensors
    Q: { base: 'Q' },
    K: { base: 'K' },
    V: { base: 'V' },
    Scores: { base: 'S' },
    ScaledScores: { base: "S'" },
    AttentionWeights: { base: 'A' },
    HeadOutput: { base: 'H' },
    ConcatOutput: { base: 'H', subscript: 'cat'},
    output: { base: 'M' },
    mha_output: { base: 'M' },

    // Add & Norm (Context-dependent, see getSymbolParts)
    add_norm_1_output: { base: "Z'" }, // Default for Encoder
    add_norm_2_output: { base: "Z''" }, // Default for Encoder
    add_norm_3_output: { base: "Y", subscript: "final" }, // Default for Decoder

    // FFN
    W1: { base: 'W', subscript: '1' },
    b1: { base: 'b', subscript: '1' },
    Intermediate: { base: 'H', subscript: 'ffn' },
    Activated: { base: 'H', subscript: 'act' },
    W2: { base: 'W', subscript: '2' },
    b2: { base: 'b', subscript: '2' },
    ffn_output: { base: 'F' },

    // --- Decoder Specific ---
    outputEmbeddings: { base: 'E', subscript: 'out' },
    decoderPosEncodings: { base: 'PE', subscript: 'dec' },
    decoderInput: { base: 'Y' }, // Y_0
    decoder_input: { base: 'Y' },

    masked_mha_output: { base: 'M', subscript: 'mmha' },
    Wo_masked: { base: 'W', superscript: 'O' },

    enc_dec_mha_output: { base: 'M', subscript: 'ed' },
    Wo_enc_dec: { base: 'W', superscript: 'O' },

    // Final Output
    finalLinear: { base: 'W', subscript: 'proj' },
    logits: { base: 'L' },
    outputProbabilities: { base: 'P' },
};

/**
 * Gets the consistent mathematical symbol parts for a given matrix name.
 * @param name The full, unique name of the matrix (e.g., "encoder.0.add_norm_1_output").
 * @returns An object with base, superscript, and subscript parts.
 */
export const getSymbolParts = (name: string): SymbolParts => {
    const conceptualName = name.split('.').pop() || '';
    const isDecoderContext = name.includes('decoder');

    // [MODIFIED] Handle context-sensitive Add & Norm symbols
    if (isDecoderContext) {
        if (conceptualName === 'add_norm_1_output') return { base: "Y'" };
        if (conceptualName === 'add_norm_2_output') return { base: "Y''" };
        if (conceptualName === 'add_norm_3_output') return { base: "Y", subscript: "final" };
    } else { // Encoder context
        if (conceptualName === 'add_norm_1_output') return { base: "Z'" };
        if (conceptualName === 'add_norm_2_output') return { base: "Z", subscript: "final" };
    }

    if (conceptualName.startsWith('Wq') || conceptualName.startsWith('Wk') || conceptualName.startsWith('Wv') || conceptualName.startsWith('Wo')) {
        return SYMBOL_CONFIG[conceptualName.substring(0,2)];
    }
    return SYMBOL_CONFIG[conceptualName] || { base: 'X' }; // Default to 'X' if not found
};
// END OF FILE: src/config/symbolMapping.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/hooks/useHighlighting.ts
================================================================================

// FILE: src/hooks/useHighlighting.ts
import { useMemo } from 'react';
import { HighlightState } from '../types';

/**
 * A centralized hook to determine the highlight status of an element.
 * This prevents logic duplication and ensures consistent highlighting behavior
 * across the entire application (e.g., in Viz.tsx and Explanation.tsx).
 *
 * @param name - The unique name of the component's matrix/vector.
 * @param row - The row index of the element.
 * @param col - The column index of the element.
 * @param highlight - The global highlight state object.
 * @returns An object { isTarget, isSource, isDestination } indicating the element's highlight status.
 */
export const useHighlighting = (
  name: string,
  row: number,
  col: number,
  highlight: HighlightState
) => {
  return useMemo(() => {
    const { target, sources, destinations } = highlight;

    // Check if this element is the primary target
    const isTarget =
      !!target &&
      target.name === name &&
      target.row === row &&
      target.col === col &&
      !target.isInternal;

    // Check if this element is a source
    const isSource = sources.some(s => {
      if (s.name !== name || s.isInternal) return false;

      // [FIXED] Correctly handle row, column, and single-cell highlighting.
      if (s.highlightRow && s.highlightCol) {
          // This case means the entire matrix is a source, e.g., for residual connections.
          return true;
      }
      if (s.highlightRow) {
          return s.row === row;
      }
      if (s.highlightCol) {
          return s.col === col;
      }
      // Default to single-cell check if no specific highlight type is given
      return s.row === row && s.col === col;
    });

    // Check if this element is a destination
    const isDestination = (destinations || []).some(d => {
       if (d.name !== name || d.isInternal) return false;

       if (d.highlightRow && d.highlightCol) {
          return true;
       }
       if (d.highlightRow) {
           return d.row === row;
       }
       if (d.highlightCol) {
           return d.col === col;
       }
       return d.row === row && d.col === col;
    });

    return { isTarget, isSource, isDestination };
  // The dependency array is correct as we are only using props passed to the hook.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [name, row, col, highlight]);
};
// END OF FILE: src/hooks/useHighlighting.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/hooks/useTransformer.ts
================================================================================

// FILE: src/hooks/useTransformer.ts
import { useMemo } from 'react';
import { TransformerData } from '../types';
import { calculateTransformer } from '../lib/transformer';

// --- Main Hook ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number; // Decoder sequence length
    n_layers: number;
    d_ff: number;
}

/**
 * A React hook that calculates the entire state of a Transformer model.
 * It uses a deterministic calculation function from `lib/transformer` and
 * memoizes the result to avoid re-computation on every render.
 *
 * @param inputText - The input sentence for the encoder.
 * @param dims - The dimensions of the Transformer model.
 * @returns A `TransformerData` object containing all intermediate matrices,
 *          or `null` if the dimensions are invalid or a calculation error occurs.
 */
export const useTransformer = (inputText: string, dims: Dims): TransformerData | null => {
  return useMemo(() => {
    if (!inputText.trim()) {
        return null; // Return null if input is empty to avoid calculation errors
    }
    try {
      // The core logic is now delegated to a pure function.
      // This makes the hook cleaner and separates concerns.
      // The heavy computation is in `calculateTransformer`.
      const transformerData = calculateTransformer(inputText, dims);
      return transformerData;
    } catch (e) {
      console.error("Error during transformer calculation:", e);
      // If any error occurs during the complex calculation,
      // return null to indicate failure to the UI.
      return null;
    }
  }, [inputText, dims]); // The hook will only re-run if the dimensions or input text change.
};
// END OF FILE: src/hooks/useTransformer.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/lib/fixedWeights.ts
================================================================================

// FILE: lib/fixedWeights.ts
// This file provides a deterministic set of weights for the Transformer model.
// All values are hardcoded to ensure the visualization is reproducible.
// This replaces the previous random number generation.

interface Dims {
    d_model: number;
    h: number;
    seq_len: number;
    n_layers: number;
    d_ff: number;
}

// A simple seeding function for pseudo-random but deterministic numbers.
const createSeededRandom = (seed: number) => {
    let state = seed;
    return () => {
        state = (state * 9301 + 49297) % 233280;
        return (state / 233280.0) * 2 - 1; // Return value between -1 and 1
    };
};

const createFixedMatrix = (rows: number, cols: number, seed: number): number[][] => {
    const random = createSeededRandom(seed);
    return Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => random())
    );
};

const createFixedVector = (size: number, seed: number): number[] => {
    const random = createSeededRandom(seed);
    return Array.from({ length: size }, () => random());
};

export const fixedWeights = (dims: Dims) => {
    const { d_model, h, n_layers, d_ff, seq_len } = dims;
    const d_k = d_model / h;

    const VOCAB_SIZE = 16;
    const vocab: { [key: number]: string } = {
        0: '<PAD>', 1: '<SOS>', 2: '<EOS>', 3: 'I', 4: 'am', 5: 'a', 6: 'student',
        7: '我', 8: '是', 9: '一个', 10: '学生', 11: 'he', 12: 'she', 13: 'is',
        14: 'good', 15: '[UNK]'
    };

    const embeddingMatrix = createFixedMatrix(VOCAB_SIZE, d_model, 1);
    const posEncodings = Array.from({ length: 10 }, (_, pos) => // Max seq_len of 10
      Array.from({ length: d_model }, (_, i) =>
        i % 2 === 0
          ? Math.sin(pos / (10000 ** (i / d_model)))
          : Math.cos(pos / (10000 ** ((i - 1) / d_model)))
      )
    );

    const encoderLayers = Array.from({ length: n_layers }, (_, l) => ({
        mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 150 + l),
        },
        ffn: {
            W1: createFixedMatrix(d_model, d_ff, 200 + l * 2 + 0),
            b1: createFixedVector(d_ff, 201 + l * 2 + 0),
            W2: createFixedMatrix(d_ff, d_model, 200 + l * 2 + 1),
            b2: createFixedVector(d_model, 201 + l * 2 + 1),
        },
    }));

    const decoderLayers = Array.from({ length: n_layers }, (_, l) => ({
        masked_mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 350 + l),
        },
        enc_dec_mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 450 + l),
        },
        ffn: {
            W1: createFixedMatrix(d_model, d_ff, 500 + l * 2 + 0),
            b1: createFixedVector(d_ff, 501 + l * 2 + 0),
            W2: createFixedMatrix(d_ff, d_model, 500 + l * 2 + 1),
            b2: createFixedVector(d_model, 501 + l * 2 + 1),
        },
    }));

    const finalLinear = createFixedMatrix(d_model, VOCAB_SIZE, 999);

    return {
        vocab,
        embeddingMatrix,
        posEncodings,
        encoderLayers,
        decoderLayers,
        finalLinear,
    };
};
// END OF FILE: lib/fixedWeights.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/lib/tokenizer.ts
================================================================================

// FILE: src/lib/tokenizer.ts
/**
 * A simple whitespace tokenizer.
 * Splits text by spaces and removes empty strings.
 * @param text The input string.
 * @returns An array of tokens.
 */
export const whitespaceTokenizer = (text: string): string[] => {
    return text.trim().split(/\s+/).filter(Boolean);
};

// END OF FILE: src/lib/tokenizer.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/lib/transformer.ts
================================================================================

// FILE: lib/transformer.ts
import { Matrix, TransformerData, EncoderLayerData, FFNData, MultiHeadAttentionData, AttentionHeadData, Vector, DecoderLayerData } from '../types';
import { fixedWeights } from './fixedWeights';
import { whitespaceTokenizer } from './tokenizer';

// --- Utility Functions ---

const createMatrixFrom2DArray = (data: number[][]): Matrix => {
    return data.map(row => row.slice());
};

const createVectorFrom1DArray = (data: number[]): Vector => {
    return data.slice();
};

const addMatrices = (A: Matrix, B: Matrix): Matrix => {
  return A.map((row, i) =>
    row.map((val, j) => val + B[i][j])
  );
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
  const rowsA = A.length;
  if (rowsA === 0) return [];
  const colsA = A[0].length;
  if (colsA === 0) return A.map(() => []);
  const colsB = B[0]?.length ?? 0;
  if (colsB === 0) return A.map(() => []);

  const result: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));

  for (let i = 0; i < rowsA; i++) {
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      result[i][j] = sum;
    }
  }
  return result;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => {
    return A.map(row => row.map(val => val / scalar));
}

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row.filter(v => isFinite(v)));
        const exps = row.map(val => isFinite(val) ? Math.exp(val - maxVal) : 0);
        const sumExps = exps.reduce((a, b) => a + b, 0);
        if (sumExps === 0) return row.map(() => 1 / row.length); // Avoid division by zero
        return exps.map(exp => exp / sumExps);
    });
}

const layerNorm = (A: Matrix): Matrix => {
    if (A.length === 0 || A[0].length === 0) return [];
    return A.map(row => {
        const mean = row.reduce((a,b) => a+b, 0) / row.length;
        const variance = row.map(x => (x - mean) ** 2).reduce((a,b) => a+b,0) / row.length;
        const std = Math.sqrt(variance + 1e-5);
        return row.map(x => (x - mean) / std);
    });
}

const applyReLU = (A: Matrix): Matrix => {
    return A.map(row => row.map(val => Math.max(0, val)));
}

const addBias = (A: Matrix, b: Vector): Matrix => {
    return A.map(row => row.map((val, j) => val + b[j]));
}

const applyMask = (A: Matrix, maskValue = -Infinity): Matrix => {
    return A.map((row, i) =>
        row.map((val, j) => (j > i ? maskValue : val))
    );
};

// --- Main Calculation Function ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number; // Decoder sequence length
    n_layers: number;
    d_ff: number;
}

export const calculateTransformer = (inputText: string, dims: Dims): TransformerData | null => {
    const { d_model, h, seq_len: decoder_seq_len, n_layers, d_ff } = dims;
    if (d_model % h !== 0) return null;
    const d_k = d_model / h;

    const weights = fixedWeights(dims);
    const vocab = weights.vocab;
    const UNK_TOKEN_ID = 15;

    // --- INPUT STAGE (DYNAMIC) ---
    const tokenizedText = whitespaceTokenizer(inputText);
    const tokenizedInput = tokenizedText.map(t => {
        const entry = Object.entries(vocab).find(([id, word]) => word === t);
        return entry ? parseInt(entry[0], 10) : UNK_TOKEN_ID;
    });
    const encoder_seq_len = tokenizedInput.length;
    if (encoder_seq_len === 0) return null; // Handle empty input after tokenization

    // --- ENCODER ---
    const embeddingMatrix = createMatrixFrom2DArray(weights.embeddingMatrix);
    const inputEmbeddings = tokenizedInput.map(token_id => embeddingMatrix[token_id]);

    const posEncodings: Matrix = createMatrixFrom2DArray(weights.posEncodings).slice(0, encoder_seq_len);
    const encoderInput = addMatrices(inputEmbeddings, posEncodings);

    let currentEncoderInput = encoderInput;
    const encoderLayers: EncoderLayerData[] = [];

    for (let i = 0; i < n_layers; i++) {
        const encoder_input = currentEncoderInput;
        const heads: AttentionHeadData[] = [];
        const headOutputs: Matrix[] = [];
        for(let j=0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wv);
            const Q = multiplyMatrices(encoder_input, Wq);
            const K = multiplyMatrices(encoder_input, Wk);
            const V = multiplyMatrices(encoder_input, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: encoder_seq_len }, (_, c) => K[c][r]));
            const Scores = multiplyMatrices(Q, K_T);
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            headOutputs.push(HeadOutput);
        }
        const ConcatOutput = headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(encoder_seq_len).fill(0).map(() => []));
        const Wo = createMatrixFrom2DArray(weights.encoderLayers[i].mha.Wo);
        const mha_output = multiplyMatrices(ConcatOutput, Wo);
        const mha: MultiHeadAttentionData = { heads, Wo, output: mha_output };
        const add_norm_1_output = layerNorm(addMatrices(encoder_input, mha_output));
        const W1 = createMatrixFrom2DArray(weights.encoderLayers[i].ffn.W1);
        const b1 = createVectorFrom1DArray(weights.encoderLayers[i].ffn.b1);
        const Intermediate = addBias(multiplyMatrices(add_norm_1_output, W1), b1);
        const Activated = applyReLU(Intermediate);
        const W2 = createMatrixFrom2DArray(weights.encoderLayers[i].ffn.W2);
        const b2 = createVectorFrom1DArray(weights.encoderLayers[i].ffn.b2);
        const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
        const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
        const add_norm_2_output = layerNorm(addMatrices(add_norm_1_output, ffn_output));
        encoderLayers.push({ encoder_input, mha, mha_output, add_norm_1_output, ffn, ffn_output, add_norm_2_output });
        currentEncoderInput = add_norm_2_output;
    }
    const finalEncoderOutput = currentEncoderInput;

    // --- DECODER ---
    const tokenizedDecoderInput = ["<SOS>", "我", "是", "学生"].slice(0, decoder_seq_len).map(t => Object.keys(vocab).find(k => vocab[parseInt(k)] === t)!).map(Number);
    const outputEmbeddings = tokenizedDecoderInput.map(token_id => embeddingMatrix[token_id]);
    const decoderPosEncodings = createMatrixFrom2DArray(weights.posEncodings).slice(0, decoder_seq_len);
    const decoderInput = addMatrices(outputEmbeddings, decoderPosEncodings);

    let currentDecoderInput = decoderInput;
    const decoderLayers: DecoderLayerData[] = [];

    for (let i = 0; i < n_layers; i++) {
        const decoder_input = currentDecoderInput;
        const decWeights = weights.decoderLayers[i];

        const masked_mha_heads: AttentionHeadData[] = [];
        const masked_mha_headOutputs: Matrix[] = [];
        for (let j = 0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wv);
            const Q = multiplyMatrices(decoder_input, Wq);
            const K = multiplyMatrices(decoder_input, Wk);
            const V = multiplyMatrices(decoder_input, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: decoder_seq_len }, (_, c) => K[c][r]));
            const Scores = applyMask(multiplyMatrices(Q, K_T));
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            masked_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            masked_mha_headOutputs.push(HeadOutput);
        }
        const masked_ConcatOutput = masked_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(decoder_seq_len).fill(0).map(() => []));
        const masked_Wo = createMatrixFrom2DArray(decWeights.masked_mha.Wo);
        const masked_mha_output = multiplyMatrices(masked_ConcatOutput, masked_Wo);
        const masked_mha: MultiHeadAttentionData = { heads: masked_mha_heads, Wo: masked_Wo, output: masked_mha_output };
        const dec_add_norm_1_output = layerNorm(addMatrices(decoder_input, masked_mha_output));

        const enc_dec_mha_heads: AttentionHeadData[] = [];
        const enc_dec_mha_headOutputs: Matrix[] = [];
         for (let j = 0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wv);
            const Q = multiplyMatrices(dec_add_norm_1_output, Wq);
            const K = multiplyMatrices(finalEncoderOutput, Wk);
            const V = multiplyMatrices(finalEncoderOutput, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: encoder_seq_len }, (_, c) => K[c][r]));
            const Scores = multiplyMatrices(Q, K_T);
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            enc_dec_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            enc_dec_mha_headOutputs.push(HeadOutput);
        }
        const enc_dec_ConcatOutput = enc_dec_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(decoder_seq_len).fill(0).map(() => []));
        const enc_dec_Wo = createMatrixFrom2DArray(decWeights.enc_dec_mha.Wo);
        const enc_dec_mha_output = multiplyMatrices(enc_dec_ConcatOutput, enc_dec_Wo);
        const enc_dec_mha: MultiHeadAttentionData = { heads: enc_dec_mha_heads, Wo: enc_dec_Wo, output: enc_dec_mha_output };
        const dec_add_norm_2_output = layerNorm(addMatrices(dec_add_norm_1_output, enc_dec_mha_output));

        const W1 = createMatrixFrom2DArray(decWeights.ffn.W1);
        const b1 = createVectorFrom1DArray(decWeights.ffn.b1);
        const Intermediate = addBias(multiplyMatrices(dec_add_norm_2_output, W1), b1);
        const Activated = applyReLU(Intermediate);
        const W2 = createMatrixFrom2DArray(decWeights.ffn.W2);
        const b2 = createVectorFrom1DArray(decWeights.ffn.b2);
        const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
        const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
        const dec_add_norm_3_output = layerNorm(addMatrices(dec_add_norm_2_output, ffn_output));

        decoderLayers.push({ decoder_input, masked_mha, masked_mha_output, add_norm_1_output: dec_add_norm_1_output, enc_dec_mha, enc_dec_mha_output, add_norm_2_output: dec_add_norm_2_output, ffn, ffn_output, add_norm_3_output: dec_add_norm_3_output });
        currentDecoderInput = dec_add_norm_3_output;
    }
    const finalDecoderOutput = currentDecoderInput;

    const finalLinear = createMatrixFrom2DArray(weights.finalLinear);
    const logits = multiplyMatrices(finalDecoderOutput, finalLinear);
    const outputProbabilities = softmaxByRow(logits);

    // --- DECODING STAGE ---
    const decodedTokens = outputProbabilities.map(row => row.indexOf(Math.max(...row)));
    const outputText = decodedTokens.map(id => vocab[id] || "[UNK]"); // Handle unknown tokens

    return {
        inputText: tokenizedText,
        tokenizedInput,
        embeddingMatrix,
        vocab,
        inputEmbeddings,
        posEncodings,
        encoderInput,
        encoderLayers,
        finalEncoderOutput,
        outputEmbeddings,
        decoderPosEncodings,
        decoderInput,
        decoderLayers,
        finalDecoderOutput,
        finalLinear,
        logits,
        outputProbabilities,
        decodedTokens,
        outputText,
    };
};
// END OF FILE: lib/transformer.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/utils/matrixView.ts
================================================================================

// FILE: src/topics/transformer-explorer/utils/matrixView.ts
export const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12; // e.g., 4 + 3 + 4 + 1 ellipsis = 12

/**
 * Calculates the visible indices for a row or column of a matrix based on a focus point.
 * It always shows the first and last `alwaysShowCount` items.
 * It shows a `windowSize` around the `focusIndex`.
 *
 * @param totalSize - The total number of items (rows or columns).
 * @param focusIndex - The index of the focused item, or -1 if no focus.
 * @param alwaysShowCount - The number of items to always show at the beginning and end.
 * @param windowSize - The size of the focus window around the focusIndex.
 * @returns An array of indices to display, with ELLIPSIS string for gaps.
 */
export const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {

  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }

  const visible = new Set<number>();

  // 1. Add always-visible indices
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }

  // [NEW] Also include the middle index when there's no specific focus
  if (focusIndex === -1 && totalSize >= MIN_SIZE_FOR_TRUNCATION) {
    visible.add(Math.floor((totalSize - 1) / 2));
  }

  // 2. Add focus window indices
  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }

  // 3. Build the final array with ellipses for gaps
  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];

  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }

  return result;
};
// END OF FILE: src/topics/transformer-explorer/utils/matrixView.ts


================================================================================
### 文件路径: public/index.html
================================================================================

<!--# FILE: public/index.html-->

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>终极 Transformer 深度探索器</title>
    <!-- 引入 MathJax 用于渲染 LaTeX 公式 -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

<!--# END OF FILE: public/index.html-->


