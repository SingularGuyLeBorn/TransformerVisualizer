================================================================================
### 文件路径: src/App.css
================================================================================

/* START OF FILE: src/App.css */
/* FILE: src/App.css */
:root {
  --highlight-color: #c0392b;
  --highlight-bg: rgba(192, 57, 43, 0.08);
  --border-color: #dcdfe6;
  --bg-color: #f5f7fa;
  --text-color: #303133;
  --arrow-color: #888;
  --component-bg: #ffffff;
  --component-header-bg: #f8f9fa;
  --residual-bg: #f0f4c3;
  --residual-border: #dce775;

  /* Highlighting */
  --highlight-target-bg: #e63946;
  --highlight-target-color: #ffffff;
  --highlight-source-bg: #1d3557;
  --highlight-source-color: #f1faee;
  /* 调整为半透明橙红色调 */
  --highlight-formula-bg: rgba(252, 163, 17, 0.15); /* 橙红色（#fca311）的15%透明度 */
  --highlight-formula-border: #fca311; /* 橙红色 */
  --highlight-vector-bg: rgba(69, 123, 157, 0.2);
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  background-color: var(--bg-color);
  color: var(--text-color);
  margin: 0;
  font-size: 15px;
}

#root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

h1 {
  text-align: center;
  color: #000;
  margin: 0;
  padding: 20px 0;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; /* Prevent title from shrinking */
}

.main-layout {
  display: flex;
  gap: 20px;
  flex-grow: 1; /* Allow layout to fill remaining space */
  overflow: hidden;
  padding: 20px;
  min-height: 0; /* Important for flex children scrolling */
}

.column {
  flex: 1;
  background: var(--component-bg);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
  overflow-y: auto; /* THIS IS THE KEY FOR SCROLLING */
  min-height: 0;
}

.column-content {
  padding: 20px;
}

.column.left-column {
  flex: 1.4;
}

.column h2 {
  font-size: 1.6em;
  margin: -20px -20px 20px -20px;
  padding: 20px 20px 15px 20px;
  text-align: center;
  color: #000;
  position: sticky;
  top: -21px; /* Adjust to hide top border */
  background: inherit;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
  border-radius: 12px 12px 0 0;
}

/* --- Left Column: Viz --- */
.diagram-component {
  border: 2px solid var(--border-color);
  border-radius: 10px;
  margin-bottom: 15px;
  background-color: #fdfdfd;
  transition: all 0.3s ease;
}
/* 新增：左侧组件激活时的样式 */
.diagram-component.active {
    border-color: var(--highlight-formula-border) !important;
    box-shadow: 0 0 30px var(--highlight-formula-bg) !important;
    transform: scale(1.01);
}

.component-header {
  background-color: var(--component-header-bg);
  padding: 8px 15px;
  font-weight: bold;
  font-size: 1.1em;
  border-bottom: 1px solid var(--border-color);
  border-radius: 8px 8px 0 0;
}
.component-body {
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
}

.arrow-down {
  width: 100%;
  text-align: center;
  font-size: 24px;
  color: var(--arrow-color);
  margin: 5px 0;
}

/* --- Matrix Styles --- */
.matrix-wrapper {
    position: relative;
}
.matrix-container {
  display: inline-block;
  border: 1px solid #ccc;
  padding: 5px;
  border-radius: 4px;
  background-color: #f9f9f9;
  position: relative;
}
.matrix-grid {
  display: grid;
  gap: 3px;
}

.matrix-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
  z-index: 2;
  font-weight: normal; /* 确保不加粗 */
}

.matrix-element:hover {
  transform: scale(1.1);
  border-color: #007bff;
  box-shadow: 0 0 5px rgba(0,123,255,0.5);
  z-index: 5;
}

.matrix-element.source {
  background-color: var(--highlight-source-bg);
  color: var(--highlight-source-color);
  border-color: var(--highlight-source-bg);
  font-weight: normal; /* 确保不加粗 */
}
.matrix-element.target {
  background-color: var(--highlight-target-bg);
  color: var(--highlight-target-color);
  border-color: var(--highlight-target-bg);
  font-weight: normal; /* 确保不加粗 */
}

.vector-highlight-overlay {
    position: absolute;
    background-color: var(--highlight-vector-bg);
    border: 1px solid var(--highlight-source-bg);
    border-radius: 3px;
    z-index: 1;
    pointer-events: none;
    transition: all 0.2s ease;
}

.matrix-label-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}

.matrix-label {
  text-align: center;
  font-weight: bold;
  font-family: monospace;
  font-size: 1.1em;
  margin: 0;
}

.matrix-symbol-tag {
    background-color: #e9ecef;
    color: #6c757d;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.9em;
    border: 1px solid #ced4da;
    line-height: 1;
}


.op-symbol {
    font-size: 2em;
    font-weight: bold;
    color: #909399;
}

/* --- Right Column: Explanation --- */
.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block.active {
  border-color: var(--highlight-formula-border) !important;
  box-shadow: 0 0 30px var(--highlight-bg) !important;
  transform: scale(1.01);
  background-color: var(--highlight-formula-bg);
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li, .math-block h5 {
    line-height: 1.7;
    margin: 1em 0;
}
.math-block h5 {
    font-size: 1.1em;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

.formula-display {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
    margin: 20px 0;
    padding: 10px;
}
.katex-display {
    margin: 0 !important;
}

.matrix-scroll-wrapper {
    overflow-x: auto;
    padding: 10px;
    max-width: 100%;
    background-color: rgba(0,0,0,0.02);
    border-radius: 8px;
    flex-shrink: 1;
    min-width: 0;
}

/* [新增] 右侧符号矩阵的高亮框样式 */
.symbolic-matrix-wrapper {
    padding: 8px;
    border-radius: 6px;
    border: 2px solid transparent;
    transition: all 0.3s ease;
}
.symbolic-matrix-wrapper.target {
    border-color: var(--highlight-target-bg);
    background-color: rgba(230, 57, 70, 0.1); /* 目标色半透明背景 */
}
.symbolic-matrix-wrapper.source {
    border-color: var(--highlight-source-bg);
    background-color: rgba(29, 53, 87, 0.1); /* 来源色半透明背景 */
}


/* Controls */
.controls-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 15px 20px;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  gap: 30px;
  flex-shrink: 0; /* Prevent controls from shrinking */
}
.control-group {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.control-group label {
  font-size: 0.9em;
  margin-bottom: 5px;
  color: #606266;
}
.control-group input {
  width: 60px;
  padding: 6px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  text-align: center;
  font-size: 1em;
}
.d_k-value {
    width: 60px;
    padding: 6px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: center;
    font-size: 1em;
    font-weight: bold;
    background-color: #f0f2f5;
}
/* END OF FILE: src/App.css */


================================================================================
### 文件路径: src/App.tsx
================================================================================

// FILE: src/App.tsx
import React, { useState, useCallback } from 'react';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { useTransformer } from './hooks/useTransformer';
import { ElementIdentifier, HighlightSource, HighlightState, TransformerData } from './types';
import { MATRIX_NAMES } from './config/matrixNames';

function App() {
  const [dims, setDims] = useState({
      d_model: 8,
      h: 2,
      seq_len: 3,
      n_layers: 1,
      d_ff: 32
  });
  const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [], activeComponent: null });

  const transformerData: TransformerData | null = useTransformer(dims);

  const handleElementClick = useCallback((element: ElementIdentifier) => {
      if (!transformerData) return;

      const { name, row, col } = element;
      const parts = name.split('.');

      let newSources: HighlightSource[] = [];
      let newTarget: ElementIdentifier | null = element;

      let activeComponent: string | null = null;
      const layerIdx = parts.length > 1 && parts[0] === 'encoder' ? parseInt(parts[1], 10) : 0;
      const LN = MATRIX_NAMES.layer(layerIdx); // Layer Names
      const HN = MATRIX_NAMES.head(layerIdx, 0); // Head Names for head 0

      // [核心修复] 修正重复的 case 标签，并确保 add_norm_1_output 正确映射
      switch (name) {
          case MATRIX_NAMES.inputEmbeddings:
          case MATRIX_NAMES.posEncodings:
          case MATRIX_NAMES.encoderInput:
              activeComponent = 'input_embed';
              break;
          case LN.encoder_input:
              activeComponent = 'mha';
              break;
          case LN.add_norm_1_output:
              // 如果点击的是 add_norm_1_output, 它既是 AddNorm1 的输出，也是 FFN 的输入
              // 默认激活 AddNorm1，因为它是直接产生者
              activeComponent = 'add_norm_1';
              break;
          case LN.ffn_output:
              activeComponent = 'ffn';
              break;
          case LN.add_norm_2_output:
              activeComponent = 'add_norm_2';
              break;
          default:
              if (name.includes('.mha')) activeComponent = 'mha';
              if (name.includes('.ffn')) activeComponent = 'ffn';
      }

      // 当点击 FFN 内部组件时，确保激活 ffn 区块
      if (name.startsWith(`encoder.${layerIdx}.ffn`)) {
          activeComponent = 'ffn';
      }

      const d_k = dims.d_model / dims.h;

      // --- Backward Tracing Logic ---
      if (name === MATRIX_NAMES.encoderInput) {
          newSources.push({ name: MATRIX_NAMES.inputEmbeddings, row, col });
          newSources.push({ name: MATRIX_NAMES.posEncodings, row, col });
      }
      // --- MHA Component ---
      else if (name === HN.Q || name === HN.K || name === HN.V) {
          const matrixType = name.split('.').pop()!;
          // [核心修复] 修正大小写错误 Wq vs wq
          const weightName = HN[matrixType as 'Q' | 'K' | 'V'];
          for (let k = 0; k < dims.d_model; k++) {
              newSources.push({ name: LN.encoder_input, row, col: k, highlightRow: true });
              newSources.push({ name: weightName.replace(matrixType, `W${matrixType.toLowerCase()}`), row: k, col: col, highlightCol: true });
          }
      } else if (name === HN.Scores) {
          newSources.push({ name: HN.Q, row: row, col: -1, highlightRow: true });
          newSources.push({ name: HN.K, row: col, col: -1, highlightRow: true });
      } else if (name === HN.ScaledScores) {
          newSources.push({ name: HN.Scores, row, col });
      } else if (name === HN.AttentionWeights) {
           for (let k = 0; k < dims.seq_len; k++) {
               newSources.push({ name: HN.ScaledScores, row, col: k, highlightRow: true });
           }
      } else if (name === HN.HeadOutput) {
          for (let k = 0; k < dims.seq_len; k++) {
               newSources.push({ name: HN.AttentionWeights, row, col: k, highlightRow: true });
          }
          for (let k = 0; k < d_k; k++) {
               newSources.push({ name: HN.V, row: -1, col: k, highlightCol: true });
          }
      } else if (name === LN.mha_output) {
          for (let k = 0; k < dims.d_model; k++) {
              const headIdx = Math.floor(k / d_k);
              const headName = MATRIX_NAMES.head(layerIdx, headIdx).HeadOutput;
              newSources.push({ name: headName, row, col: -1, highlightRow: true });
              newSources.push({ name: LN.Wo, row: k, col: col, highlightCol: true });
          }
      }
      // --- Add & Norm 1 ---
      else if (name === LN.add_norm_1_output) {
          newSources.push({ name: LN.encoder_input, row, col });
          newSources.push({ name: LN.mha_output, row, col });
      }
      // --- FFN Component ---
      else if (name === LN.Intermediate || name === LN.Activated) {
           for(let k=0; k < dims.d_model; k++) {
               newSources.push({ name: LN.add_norm_1_output, row, col: k, highlightRow: true });
               newSources.push({ name: LN.W1, row: k, col: col, highlightCol: true });
           }
           // Also add bias as a source
           for(let k=0; k < dims.d_ff; k++) {
               newSources.push({ name: LN.b1, row: 0, col: k, highlightRow: true});
           }
      } else if (name === LN.ffn_output) {
           for(let k=0; k < dims.d_ff; k++) {
               newSources.push({ name: LN.Activated, row, col: k, highlightRow: true });
               newSources.push({ name: LN.W2, row: k, col: col, highlightCol: true });
           }
            // Also add bias as a source
           for(let k=0; k < dims.d_model; k++) {
                newSources.push({ name: LN.b2, row: 0, col: k, highlightRow: true});
           }
      }
      // --- Add & Norm 2 ---
      else if (name === LN.add_norm_2_output) {
          newSources.push({ name: LN.add_norm_1_output, row, col });
          newSources.push({ name: LN.ffn_output, row, col });
      }

      const newHighlightState: HighlightState = { target: newTarget, sources: newSources, activeComponent };
      setHighlight(newHighlightState);

      setTimeout(() => {
          const explanationEl = document.getElementById(`math_${activeComponent}`);
          if (explanationEl) {
              explanationEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
      }, 0);

  }, [transformerData, dims]);

  if (!transformerData) {
      return <div>Loading or Invalid Dimensions... (d_model must be divisible by h)</div>
  }

  return (
    <div className="app-container">
      <h1>终极 Transformer 深度探索器 (极简版)</h1>
      <Controls dims={dims} setDims={setDims} />
      <div className="main-layout">
        <div className="column left-column">
          <div className="column-content">
              <h2>模型结构与数据流</h2>
              <Viz
                data={transformerData}
                highlight={highlight}
                onElementClick={handleElementClick}
              />
          </div>
        </div>
        <div className="column right-column">
           <div className="column-content">
              <h2>数学原理</h2>
              <Explanation
                dims={dims}
                highlight={highlight}
              />
           </div>
        </div>
      </div>
    </div>
  );
}

export default App;
// END OF FILE: src/App.tsx


================================================================================
### 文件路径: src/index.tsx
================================================================================

/* START OF FILE: src/index.tsx */
// FILE: src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
// END OF FILE: src/index.tsx
/* END OF FILE: src/index.tsx */


================================================================================
### 文件路径: src/styles.css
================================================================================

/* START OF FILE: src/styles.css */

/* END OF FILE: src/styles.css */


================================================================================
### 文件路径: src/types.ts
================================================================================

// FILE: src/types.ts
export type Matrix = number[][];
export type Vector = number[];

export interface ElementIdentifier {
  name: string; // e.g., "encoder.0.mha.h0.Q"
  row: number;
  col: number;
}

export interface HighlightSource extends ElementIdentifier {
  highlightRow?: boolean;
  highlightCol?: boolean;
}

export interface HighlightState {
  activeComponent: string | null; // e.g., "encoder.0.mha"
  target: ElementIdentifier | null;
  sources: HighlightSource[];
}

export interface AttentionHeadData {
  Wq: Matrix;
  Wk: Matrix;
  Wv: Matrix;
  Q: Matrix;
  K: Matrix;
  V: Matrix;
  Scores: Matrix;
  ScaledScores: Matrix;
  AttentionWeights: Matrix;
  HeadOutput: Matrix;
}

export interface MultiHeadAttentionData {
    heads: AttentionHeadData[];
    Wo: Matrix;
    Output: Matrix;
}

export interface FFNData {
    W1: Matrix;
    b1: Vector; // bias is part of FFN data
    Intermediate: Matrix;
    Activated: Matrix;
    W2: Matrix;
    b2: Vector; // bias is part of FFN data
    Output: Matrix;
}

export interface EncoderLayerData {
    encoder_input: Matrix;
    mha: MultiHeadAttentionData;
    mha_output: Matrix;

    add_norm_1_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;

    add_norm_2_output: Matrix;
}

export interface TransformerData {
    inputEmbeddings: Matrix;
    posEncodings: Matrix;
    encoderInput: Matrix;
    encoderLayers: EncoderLayerData[];
}
// END OF FILE: src/types.ts


================================================================================
### 文件路径: src/components/AddNorm.tsx
================================================================================

// FILE: src/components/AddNorm.tsx
import React from 'react';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface AddNormProps {
    inputResidual: MatrixType;
    inputSublayer: MatrixType;
    output: MatrixType;
    residualMatrixName: string;
    sublayerMatrixName: string;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
    activeId: 'add_norm_1' | 'add_norm_2';
}

export const AddNorm: React.FC<AddNormProps> = ({ inputResidual, inputSublayer, output, residualMatrixName, sublayerMatrixName, outputMatrixName, highlight, onElementClick, activeId }) => {
    const isActive = highlight.activeComponent === activeId;
    return (
         <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Add & LayerNorm</div>
            <div className="component-body">
                <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                    <Matrix name={residualMatrixName} data={inputResidual} highlight={highlight} onElementClick={onElementClick} />
                    <div className="op-symbol">+</div>
                    <Matrix name={sublayerMatrixName} data={inputSublayer} highlight={highlight} onElementClick={onElementClick} />
                </div>
                <div className="arrow-down"><InlineMath math="\rightarrow \text{LayerNorm} \rightarrow" /></div>
                <Matrix name={outputMatrixName} data={output} highlight={highlight} onElementClick={onElementClick} />
            </div>
        </div>
    );
};
// END OF FILE: src/components/AddNorm.tsx


================================================================================
### 文件路径: src/components/Controls.tsx
================================================================================

/* START OF FILE: src/components/Controls.tsx */
// FILE: src/components/Controls.tsx
import React from 'react';

interface ControlsProps {
  dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
  setDims: (dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number }) => void;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims }) => {

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    let newDims = { ...dims, [id]: parseInt(value, 10) || 1 };

    // Ensure d_model is divisible by h
    if (id === 'h') {
        if (newDims.d_model % newDims.h !== 0) {
             newDims.d_model = Math.max(newDims.h, Math.ceil(newDims.d_model / newDims.h) * newDims.h);
        }
    }
    if (id === 'd_model') {
         if (newDims.d_model % newDims.h !== 0) {
             let best_h = 1;
             for (let i = 1; i <= newDims.d_model; i++) {
                 if (newDims.d_model % i === 0) {
                    if (Math.abs(i - newDims.h) < Math.abs(best_h - newDims.h)) {
                       best_h = i;
                    }
                 }
             }
             newDims.h = best_h;
         }
    }

    // Ensure d_ff is a multiple of d_model
    if(id === 'd_model') {
        newDims.d_ff = newDims.d_model * 4;
    }

    setDims(newDims);
  };

  const d_k = dims.d_model % dims.h === 0 ? dims.d_model / dims.h : 'N/A';

  return (
    <div className="controls-container">
      <div className="control-group">
        <label htmlFor="seq_len">序列长度 (seq_len)</label>
        <input type="number" id="seq_len" value={dims.seq_len} onChange={handleInputChange} min="2" max="5" />
      </div>
      <div className="control-group">
        <label htmlFor="d_model">模型维度 (d_model)</label>
        <input type="number" id="d_model" value={dims.d_model} onChange={handleInputChange} step={1} min={2} max="16"/>
      </div>
      <div className="control-group">
        <label htmlFor="h">注意力头数 (h)</label>
        <input type="number" id="h" value={dims.h} onChange={handleInputChange} min="1" max={dims.d_model}/>
      </div>
      <div className="control-group">
        <label htmlFor="n_layers">层数 (N)</label>
        <input type="number" id="n_layers" value={dims.n_layers} onChange={handleInputChange} min="1" max="3"/>
      </div>
       <div className="control-group">
        <label>键/查询维度 (d_k)</label>
        <div className="d_k-value">{d_k}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Controls.tsx
/* END OF FILE: src/components/Controls.tsx */


================================================================================
### 文件路径: src/components/DecoderLayer.tsx
================================================================================

/* START OF FILE: src/components/DecoderLayer.tsx */
// FILE: src/components/DecoderLayer.tsx
// This file is intentionally left blank for this version,
// as the focus is on a complete and correct Encoder implementation.
export {};
// END OF FILE: src/components/DecoderLayer.tsx
/* END OF FILE: src/components/DecoderLayer.tsx */


================================================================================
### 文件路径: src/components/Element.tsx
================================================================================

/* START OF FILE: src/components/Element.tsx */
// FILE: src/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

// The 'export' keyword here is crucial. It makes this file a module.
export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col;
  const isSource = highlight.sources.some(s => s.name === name && s.row === row && s.col === col);

  const className = `matrix-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''}`;

  const handleClick = () => {
    onElementClick({ name, row, col });
  };

  return (
    <div className={className} onClick={handleClick}>
      {value.toFixed(2)}
    </div>
  );
});
// END OF FILE: src/components/Element.tsx



================================================================================
### 文件路径: src/components/EncoderLayer.tsx
================================================================================

// FILE: src/components/EncoderLayer.tsx
import React from 'react';
import { EncoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { MultiHeadAttention } from './MultiHeadAttention';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';

interface EncoderLayerProps {
  layerIndex: number;
  data: EncoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const EncoderLayer: React.FC<EncoderLayerProps> = ({ layerIndex, data, highlight, onElementClick }) => {
  const baseName = `encoder.${layerIndex}`;
  return (
    <>
        <div className="arrow-down">↓</div>
        <div className="diagram-component">
            <div className="component-header" style={{backgroundColor: '#e3f2fd'}}>Encoder Layer {layerIndex + 1}</div>
            <div className="component-body" style={{padding: '5px'}}>

                <MultiHeadAttention
                    baseName={`${baseName}.mha`}
                    data={data.mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />

                <AddNorm
                    inputResidual={data.encoder_input}
                    inputSublayer={data.mha_output}
                    output={data.add_norm_1_output}
                    residualMatrixName={`${baseName}.encoder_input`}
                    sublayerMatrixName={`${baseName}.mha_output`}
                    outputMatrixName={`${baseName}.add_norm_1_output`}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_1"
                />

                <FeedForward
                    baseName={`${baseName}.ffn`}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />

                <AddNorm
                    inputResidual={data.add_norm_1_output}
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_2_output}
                    residualMatrixName={`${baseName}.add_norm_1_output`}
                    sublayerMatrixName={`${baseName}.ffn_output`}
                    outputMatrixName={`${baseName}.add_norm_2_output`}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_2"
                />
            </div>
        </div>
    </>
  );
};
// END OF FILE: src/components/EncoderLayer.tsx



================================================================================
### 文件路径: src/components/Explanation.tsx
================================================================================

// FILE: src/components/Explanation.tsx
import React from 'react';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { SymbolicMatrix } from './SymbolicMatrix';
import { SymbolicVector } from './SymbolicVector';
import { HighlightState } from '../types';
import { MATRIX_NAMES } from '../config/matrixNames';
import { getSymbolParts } from '../config/symbolMapping';

interface ExplanationProps {
    dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
    highlight: HighlightState;
}

interface MathBlockProps {
    id: string;
    title: string;
    children: React.ReactNode;
    highlight: HighlightState;
}

const MathBlock: React.FC<MathBlockProps> = ({ id, title, children, highlight }) => {
    const isActive = highlight.activeComponent === id;
    return (
        <div id={`math_${id}`} className={`math-block ${isActive ? 'active' : ''}`}>
            <h3>{title}</h3>
            {children}
        </div>
    );
};

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight }) => {
    const LN = MATRIX_NAMES.layer(0);
    const HN = MATRIX_NAMES.head(0, 0);

    // Helper to build KaTeX labels manually for consistency and correctness
    const buildLabel = (name: string, rows: number, cols: number) => {
        const symbol = getSymbolParts(name);
        let label = symbol.base;
        if (symbol.superscript) label += `^{${symbol.superscript}}`;
        const finalSubscript = [symbol.subscript, `${rows}\\times${cols}`].filter(Boolean).join(',');
        if (finalSubscript) label += `_{${finalSubscript}}`;
        return label;
    }

    return (
        <div>
             <MathBlock id="input_embed" title="输入嵌入 (Input Embedding)" highlight={highlight}>
                <p>此步骤将输入的文本序列转换为模型可以处理的、包含位置信息的数值向量。我们以一个序列 (长度={dims.seq_len}) 为例，当前模型维度 <InlineMath math={`d_{model}=${dims.d_model}`} />。</p>
                <BlockMath math={`${getSymbolParts(LN.encoder_input).base} = \\text{Embedding}(X) + \\text{PE}(X)`} />
                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={MATRIX_NAMES.inputEmbeddings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={MATRIX_NAMES.posEncodings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={MATRIX_NAMES.encoderInput} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} /></div>
                </div>
             </MathBlock>

             <MathBlock id="mha" title="编码器：多头注意力 (Multi-Head Attention)" highlight={highlight}>
                <p>多头注意力的核心思想是将输入（<InlineMath math="Z"/>）拆分到 <InlineMath math={`h=${dims.h}`}/> 个“子空间”中并行处理，最后再将结果融合。这允许模型从不同角度关注信息。</p>
                <h5>为单个头生成 Q, K, V</h5>
                <p>输入矩阵 <InlineMath math="Z"/> 被并行地送入 {dims.h} 个独立的注意力头。每个头都拥有三块自己专属、可学习的权重矩阵。</p>

                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={LN.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.Wq} rows={dims.d_model} cols={dims.d_model/dims.h} highlight={highlight} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.Q} rows={dims.seq_len} cols={dims.d_model/dims.h} highlight={highlight} /></div>
                </div>

                <h5>计算注意力分数</h5>
                <p>通过将 Query 矩阵与转置后的 Key 矩阵相乘，我们得到一个注意力分数矩阵 <InlineMath math="S"/>。</p>
                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.Q} rows={dims.seq_len} cols={dims.d_model/dims.h} highlight={highlight} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.K} rows={dims.d_model/dims.h} cols={dims.seq_len} highlight={highlight} transpose={true}/></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.Scores} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight} /></div>
                </div>

                <h5>缩放、Softmax 和加权求和</h5>
                <p>为防止梯度过小，将分数矩阵 <InlineMath math="S"/> 中的所有元素都除以一个缩放因子 <InlineMath math={`\\sqrt{d_k}`}/>。然后，对缩放后的分数矩阵<b>逐行</b>应用 Softmax 函数，将其转换为概率分布（权重 <InlineMath math="A"/>）。</p>
                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.Scores} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight}/></div>
                    <BlockMath math={`\\xrightarrow{/\\sqrt{d_k}}`} />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.ScaledScores} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight}/></div>
                    <BlockMath math={`\\xrightarrow{\\text{softmax}}`} />
                    <div className="matrix-scroll-wrapper"><SymbolicMatrix name={HN.AttentionWeights} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight}/></div>
                </div>

                <h5>拼接与最终投影</h5>
                <p>所有 {dims.h} 个头的输出矩阵被拼接在一起，然后通过一个最终的线性层进行融合，得到该多头注意力块的最终输出 <InlineMath math="M"/>。</p>
             </MathBlock>

             <MathBlock id="add_norm_1" title="残差连接与层归一化 (1)" highlight={highlight}>
                <p>此步骤包含两个关键操作：残差连接 (Add) 和层归一化 (LayerNorm)，旨在改善深度网络的训练过程并增强信息流动。</p>
                <div className="formula-display">
                    <SymbolicMatrix name={LN.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                    <BlockMath math="+" />
                    <SymbolicMatrix name={LN.mha_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <SymbolicMatrix name={LN.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                </div>
             </MathBlock>

              <MathBlock id="ffn" title="前馈神经网络 (Feed-Forward Network)" highlight={highlight}>
                <p>前馈网络是一个简单的两层全连接神经网络，它被独立地应用于序列中的每一个位置（即每一个词元向量）。</p>
                <h5>1. 第一次线性变换 (维度扩展)</h5>
                <p>输入矩阵 <InlineMath math="Z'"/> 首先会经过一个线性层，将其维度从 <InlineMath math={`d_{model}=${dims.d_model}`}/> 扩展到一个更大的中间维度 <InlineMath math={`d_{ff}=${dims.d_ff}`}/>。</p>
                <div className="formula-display">
                    <SymbolicMatrix name={LN.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight}/>
                    <BlockMath math="\times"/>
                    <SymbolicMatrix name={LN.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight}/>
                    <BlockMath math="+"/>
                    <SymbolicVector name={LN.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight}/>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <SymbolicMatrix name={LN.Activated} rows={dims.seq_len} cols={dims.d_ff} highlight={highlight}/>
                </div>

                <h5>2. 第二次线性变换 (维度投影)</h5>
                <p>最后，将经过激活函数处理的矩阵再通过第二个线性层，将其从中间维度 <InlineMath math={`d_{ff}`}/> 投影回原始的模型维度 <InlineMath math={`d_{model}`}/>。</p>
                <div className="formula-display">
                    <SymbolicMatrix name={LN.Activated} rows={dims.seq_len} cols={dims.d_ff} highlight={highlight}/>
                    <BlockMath math="\times"/>
                    <SymbolicMatrix name={LN.W2} rows={dims.d_ff} cols={dims.d_model} highlight={highlight}/>
                    <BlockMath math="+"/>
                    <SymbolicVector name={LN.b2} data={Array(dims.d_model).fill(0)} highlight={highlight}/>
                    <BlockMath math="="/>
                    <SymbolicMatrix name={LN.ffn_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight}/>
                </div>
             </MathBlock>

             <MathBlock id="add_norm_2" title="残差连接与层归一化 (2)" highlight={highlight}>
                <p>与第一个 "Add & Norm" 层类似，此步骤将 FFN 子层的输出信息与该子层的输入信息直接结合，然后进行层归一化。</p>
                <div className="formula-display">
                    <SymbolicMatrix name={LN.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                    <BlockMath math="+" />
                    <SymbolicMatrix name={LN.ffn_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <SymbolicMatrix name={LN.add_norm_2_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                </div>
             </MathBlock>
        </div>
    );
};
// END OF FILE: src/components/Explanation.tsx


================================================================================
### 文件路径: src/components/FeedForward.tsx
================================================================================

// FILE: src/components/FeedForward.tsx
import React from 'react';
import { FFNData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { MATRIX_NAMES } from '../config/matrixNames';

interface FFNProps {
    baseName: string; // only used for deriving layerIndex
    data: FFNData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const FeedForward: React.FC<FFNProps> = ({ baseName, data, highlight, onElementClick }) => {
    const isActive = highlight.activeComponent === 'ffn';
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const LN = MATRIX_NAMES.layer(layerIndex);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Feed-Forward Network</div>
            <div className="component-body">
                <p>Input (from Add & Norm)</p>
                <div className="arrow-down">↓</div>
                {/* Visualizing Z' * W1 + b1 */}
                <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                    <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                    <div className="op-symbol">+</div>
                    <Matrix name={LN.b1} data={[data.b1]} highlight={highlight} onElementClick={onElementClick} />
                    <span>→ ReLU →</span>
                    <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                </div>
                 {/* Visualizing H * W2 + b2 */}
                 <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '10px'}}>
                    <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                    <div className="op-symbol">+</div>
                    <Matrix name={LN.b2} data={[data.b2]} highlight={highlight} onElementClick={onElementClick} />
                    <div className="op-symbol">=</div>
                    <Matrix name={LN.ffn_output} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/FeedForward.tsx


================================================================================
### 文件路径: src/components/Matrix.tsx
================================================================================

// FILE: src/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
  isTransposed?: boolean;
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, isTransposed = false }) => {
  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const rows = isTransposed ? data[0].length : data.length;
  const cols = isTransposed ? data.length : data[0].length;

  const gridTemplateColumns = `repeat(${cols}, auto)`;

  const vectorHighlights = highlight.sources
    .filter(s => s.name === name && (s.highlightRow || s.highlightCol))
    .map((s, i) => {
       const elementWidth = 45;
       const elementHeight = 25;
       const gap = 3;
       let style: React.CSSProperties = {};

       const highlightDataRow = s.highlightRow ?? false;
       const highlightDataCol = s.highlightCol ?? false;

       if (isTransposed) {
           if (highlightDataRow) {
               style.width = `${elementWidth}px`;
               style.height = `calc(${rows} * (${elementHeight}px + ${gap}px) - ${gap}px)`;
               style.top = `5px`;
               style.left = `${s.row * (elementWidth + gap) + 5}px`;
           } else if (highlightDataCol) {
               style.width = `calc(${cols} * (${elementWidth}px + ${gap}px) - ${gap}px)`;
               style.height = `${elementHeight}px`;
               style.top = `${s.col * (elementHeight + gap) + 5}px`;
               style.left = `5px`;
           }
       } else {
           if (highlightDataRow) {
               style.width = `calc(${cols} * (${elementWidth}px + ${gap}px) - ${gap}px)`;
               style.height = `${elementHeight}px`;
               style.top = `${s.row * (elementHeight + gap) + 5}px`;
               style.left = `5px`;
           } else if (highlightDataCol) {
               style.width = `${elementWidth}px`;
               style.height = `calc(${rows} * (${elementHeight}px + ${gap}px) - ${gap}px)`;
               style.top = `5px`;
               style.left = `${s.col * (elementWidth + gap) + 5}px`;
           }
       }
       return <div key={`${s.name}-${s.row}-${s.col}-${i}`} className="vector-highlight-overlay" style={style} />;
    });

  const getLabelText = (fullName: string): string => {
      const parts = fullName.split('.');
      const lastPart = parts[parts.length - 1];
      const simpleNames = ['Q', 'K', 'V', 'Scores', 'ScaledScores', 'AttentionWeights', 'HeadOutput', 'Wq', 'Wk', 'Wv', 'Wo', 'W1', 'W2', 'b1', 'b2'];
      if (simpleNames.includes(lastPart)) {
          return lastPart;
      }
      return `\\text{${lastPart.replace(/_/g, '\\_')}}`;
  }

  const labelText = getLabelText(name);

  const symbolParts = getSymbolParts(name);
  let mathSymbol = symbolParts.base;
  if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
  if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;

  let symbolTag = null;
  if (mathSymbol && name !== 'inputEmbeddings' && name !== 'posEncodings') {
      symbolTag = (
        <div className="matrix-symbol-tag">
            <InlineMath math={mathSymbol} />
        </div>
      );
  }

  return (
    <div className="matrix-wrapper">
      <div className="matrix-container">
        {vectorHighlights}
        <div className="matrix-grid" style={{ gridTemplateColumns }}>
          {Array.from({ length: rows }).map((_, r) => (
            <React.Fragment key={`row-${r}`}>
            {Array.from({ length: cols }).map((_, c) => {
              const originalRow = isTransposed ? c : r;
              const originalCol = isTransposed ? r : c;
              const value = data[originalRow][originalCol];

              return (
                <Element
                  key={`${name}-${originalRow}-${originalCol}`}
                  name={name}
                  row={originalRow}
                  col={originalCol}
                  value={value}
                  highlight={highlight}
                  onElementClick={onElementClick}
                />
              );
            })}
            </React.Fragment>
          ))}
        </div>
      </div>
      <div className="matrix-label-container">
        <div className="matrix-label"><InlineMath>{`${labelText}${isTransposed ? '^T' : ''}`}</InlineMath></div>
        {symbolTag}
      </div>
    </div>
  );
};
// END OF FILE: src/components/Matrix.tsx


================================================================================
### 文件路径: src/components/MultiHeadAttention.tsx
================================================================================

// FILE: src/components/MultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface MHAProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const MultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick }) => {
    // Simplified to show only the first head's details for clarity
    const headData = data.heads[0];
    const headBaseName = `${baseName}.h0`;
    const isActive = highlight.activeComponent === 'mha'; // 检查是否为当前激活的组件

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}> {/* 应用active类 */}
            <div className="component-header">Multi-Head Attention</div>
            <div className="component-body">
                <p>Input (from previous layer)</p>
                <div className="arrow-down">↓</div>

                {/* Q, K, V Generation */}
                <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', alignItems: 'center', gap: '15px'}}>
                   <span>Q = Z × Wq →</span>
                   <Matrix name={`${headBaseName}.Wq`} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                   <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                </div>
                 <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', alignItems: 'center', gap: '15px', marginTop: '10px'}}>
                   <span>K = Z × Wk →</span>
                   <Matrix name={`${headBaseName}.Wk`} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                   <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                </div>
                 <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', alignItems: 'center', gap: '15px', marginTop: '10px'}}>
                   <span>V = Z × Wv →</span>
                   <Matrix name={`${headBaseName}.Wv`} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                   <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down">↓</div>
                <p>Scaled Dot-Product Attention (Head 1)</p>

                <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                    <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    <InlineMath math="\times" />
                    <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                     <InlineMath math="=" />
                    <Matrix name={`${headBaseName}.Scores`} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    {/* 新增: 明确展示缩放步骤 */}
                    <InlineMath math="\xrightarrow{/ \sqrt{d_k}}" />
                    <Matrix name={`${headBaseName}.ScaledScores`} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    <InlineMath math="\xrightarrow{\text{softmax}}" />
                    <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                     <InlineMath math="\times" />
                    <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                     <InlineMath math="=" />
                    <Matrix name={`${headBaseName}.HeadOutput`} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                </div>

                <div className="arrow-down">↓</div>
                <p>Concat & Final Projection</p>

                 <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                   <Matrix name={`${headBaseName}.HeadOutput`} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick} />
                   <InlineMath math="..." />
                   <Matrix name={`${baseName}.Wo`} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                   <InlineMath math="=" />
                   <Matrix name={`${baseName}.Output`} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/MultiHeadAttention.tsx


================================================================================
### 文件路径: src/components/SymbolicMatrix.tsx
================================================================================

// FILE: src/components/SymbolicMatrix.tsx
import React from 'react';
import { HighlightState } from '../types';
import { BlockMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';

interface SymbolicMatrixProps {
  name: string;
  rows: number;
  cols: number;
  highlight: HighlightState;
  transpose?: boolean;
}

export const SymbolicMatrix: React.FC<SymbolicMatrixProps> = ({ name, rows, cols, highlight, transpose = false }) => {
  const displayRows = transpose ? cols : rows;
  const displayCols = transpose ? rows : cols;

  const symbol = getSymbolParts(name);

  const MAX_DIM = 7;
  const EDGE_COUNT = 2;
  const WINDOW_RADIUS = 2;

  const getVisibleIndices = (total: number, highlightIndices: number[]): number[] => {
    if (total <= MAX_DIM) {
      return Array.from({ length: total }, (_, i) => i);
    }
    const visible = new Set<number>();
    for(let i=0; i < EDGE_COUNT; i++) visible.add(i);
    for(let i=total - EDGE_COUNT; i < total; i++) visible.add(i);
    highlightIndices.forEach(hIdx => {
        if (hIdx === -1) return;
        const start = Math.max(0, hIdx - WINDOW_RADIUS);
        const end = Math.min(total - 1, hIdx + WINDOW_RADIUS);
        for(let i = start; i <= end; i++) visible.add(i);
    });
    return Array.from(visible).sort((a,b) => a - b);
  }

  const thisSymbolicConceptualName = name.split('.').pop();

  const highlightedTarget = (highlight.target?.name.split('.').pop() === thisSymbolicConceptualName) ? highlight.target : null;
  const highlightedSources = highlight.sources.filter(s => s.name.split('.').pop() === thisSymbolicConceptualName);

  const highlightRows = new Set<number>();
  const highlightCols = new Set<number>();
  if(highlightedTarget) {
      highlightRows.add(transpose ? highlightedTarget.col : highlightedTarget.row);
      highlightCols.add(transpose ? highlightedTarget.row : highlightedTarget.col);
  }
  highlightedSources.forEach(s => {
      highlightRows.add(transpose ? s.col : s.row);
      highlightCols.add(transpose ? s.row : s.col);
  });

  const visibleRows = getVisibleIndices(displayRows, Array.from(highlightRows));
  const visibleCols = getVisibleIndices(displayCols, Array.from(highlightCols));

  const getElement = (r_idx: number, c_idx: number): string => {
      const originalRow = transpose ? c_idx : r_idx;
      const originalCol = transpose ? r_idx : c_idx;

      const elementBase = symbol.base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
      const subscriptContent = [symbol.subscript, originalRow, originalCol].filter(s => s !== undefined).join(',');

      let elementString = `${elementBase}_{${subscriptContent}}`;

      let isTarget = false;
      if (highlightedTarget && highlightedTarget.row === originalRow && highlightedTarget.col === originalCol) isTarget = true;

      let isSource = false;
      if (highlightedSources.some(s => {
          if (s.highlightRow && !s.highlightCol) return s.row === originalRow;
          if (s.highlightCol && !s.highlightRow) return s.col === originalCol;
          return s.row === originalRow && s.col === originalCol;
      })) isSource = true;

      if (isTarget) return `{\\color{#e63946}${elementString}}`;
      if (isSource) return `{\\color{#1d3557}${elementString}}`;
      return elementString;
  }

  let matrixRowsStr: string[] = [];
  let lastRow = -1;
  visibleRows.forEach(r => {
      if (r > lastRow + 1) {
         const dots = visibleCols.map((c, i) => (i > 0 && visibleCols[i-1] !== c-1) ? '\\ddots' : '\\vdots').join(' & ');
         matrixRowsStr.push(dots);
      }
      let matrixColsStr: string[] = [];
      let lastCol = -1;
      visibleCols.forEach(c => {
          if(c > lastCol + 1) matrixColsStr.push('\\dots');
          matrixColsStr.push(getElement(r,c));
          lastCol = c;
      });
      matrixRowsStr.push(matrixColsStr.join(' & '));
      lastRow = r;
  });

  const matrixString = matrixRowsStr.join(' \\\\ ');
  const bmatrix = `\\begin{pmatrix} ${matrixString} \\end{pmatrix}`;

  // [最终修复] 移除复杂的标签生成逻辑，只渲染矩阵本身
  const finalFormula = bmatrix;

  const isSourceComponent = highlight.sources.some(s => s.name === name);
  const isTargetComponent = highlight.target?.name === name;
  const wrapperClass = `symbolic-matrix-wrapper ${isTargetComponent ? 'target' : ''} ${isSourceComponent ? 'source' : ''}`;

  return (
    <div className={wrapperClass}>
        <BlockMath math={finalFormula} />
    </div>
  );
};
// END OF FILE: src/components/SymbolicMatrix.tsx


================================================================================
### 文件路径: src/components/SymbolicVector.tsx
================================================================================

// FILE: src/components/SymbolicVector.tsx
import React from 'react';
import { HighlightState } from '../types';
import { BlockMath } from 'react-katex';
import { Vector } from '../types';
import { getSymbolParts } from '../config/symbolMapping';

interface SymbolicVectorProps {
  name: string;
  data: Vector;
  highlight: HighlightState;
}

export const SymbolicVector: React.FC<SymbolicVectorProps> = ({ name, data, highlight }) => {
  const displayCols = data.length;
  const symbol = getSymbolParts(name);

  const getElement = (c_idx: number): string => {
      const elementBase = symbol.base.toLowerCase();
      const subscriptContent = [symbol.subscript, c_idx].filter(s => s !== undefined).join(',');

      let elementString = `${elementBase}_{${subscriptContent}}`;

      const isTarget = highlight.target?.name === name && highlight.target.col === c_idx;

      if (isTarget) return `{\\color{#e63946}${elementString}}`;
      return elementString;
  }

  let vectorElements: string[] = [];
  for (let c = 0; c < displayCols; c++) {
      vectorElements.push(getElement(c));
  }

  const vectorString = vectorElements.join(' & ');
  const pmatrix = `\\begin{pmatrix} ${vectorString} \\end{pmatrix}`;

  let baseNameForFormula = symbol.base;
  if (symbol.subscript) baseNameForFormula += `_{${symbol.subscript}}`;

  const finalFormula = `${baseNameForFormula} = ${pmatrix}`;

  const isSourceComponent = highlight.sources.some(s => s.name === name);
  const isTargetComponent = highlight.target?.name === name;
  const wrapperClass = `symbolic-matrix-wrapper ${isTargetComponent ? 'target' : ''} ${isSourceComponent ? 'source' : ''}`;

  return (
    <div className={wrapperClass}>
        <BlockMath math={finalFormula} />
    </div>
    );
};
// END OF FILE: src/components/SymbolicVector.tsx


================================================================================
### 文件路径: src/components/Viz.tsx
================================================================================

// FILE: src/components/Viz.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EncoderLayer } from './EncoderLayer';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface VizProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const Viz: React.FC<VizProps> = ({ data, highlight, onElementClick }) => {
    const isInputEmbedActive = highlight.activeComponent === 'input_embed';
    return (
        <div>
            {/* Input Embedding & Positional Encoding 组件高亮 */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header">Input Embedding & Positional Encoding</div>
                <div className="component-body">
                    <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                    <div className="op-symbol">+</div>
                    <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            <div className="arrow-down">↓</div>

            {/* Encoder Input 组件高亮 */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header">Encoder Input (<InlineMath math="Z_0" />)</div>
                <div className="component-body">
                     <Matrix name="encoderInput" data={data.encoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.encoderLayers.map((layer, i) => (
                <EncoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
            ))}
        </div>
    );
};
// END OF FILE: src/components/Viz.tsx


================================================================================
### 文件路径: src/config/matrixNames.ts
================================================================================

// FILE: src/config/matrixNames.ts
// This file is the single source of truth for all matrix and vector names.

export const MATRIX_NAMES = {
    // Input
    inputEmbeddings: 'inputEmbeddings',
    posEncodings: 'posEncodings',
    encoderInput: 'encoderInput',

    // Layer-specific names (functions to generate names for a specific layer)
    layer: (layerIndex: number) => ({
        // Inputs
        encoder_input: `encoder.${layerIndex}.encoder_input`,

        // MHA
        mha_output: `encoder.${layerIndex}.mha_output`,
        Wo: `encoder.${layerIndex}.mha.Wo`,

        // Add & Norm 1
        add_norm_1_output: `encoder.${layerIndex}.add_norm_1_output`,

        // FFN
        W1: `encoder.${layerIndex}.ffn.W1`,
        b1: `encoder.${layerIndex}.ffn.b1`,
        Intermediate: `encoder.${layerIndex}.ffn.Intermediate`,
        Activated: `encoder.${layerIndex}.ffn.Activated`,
        W2: `encoder.${layerIndex}.ffn.W2`,
        b2: `encoder.${layerIndex}.ffn.b2`,
        ffn_output: `encoder.${layerIndex}.ffn_output`,

        // Add & Norm 2
        add_norm_2_output: `encoder.${layerIndex}.add_norm_2_output`,
    }),

    // Head-specific names
    head: (layerIndex: number, headIndex: number) => ({
        Wq: `encoder.${layerIndex}.mha.h${headIndex}.Wq`,
        Wk: `encoder.${layerIndex}.mha.h${headIndex}.Wk`,
        Wv: `encoder.${layerIndex}.mha.h${headIndex}.Wv`,
        Q: `encoder.${layerIndex}.mha.h${headIndex}.Q`,
        K: `encoder.${layerIndex}.mha.h${headIndex}.K`,
        V: `encoder.${layerIndex}.mha.h${headIndex}.V`,
        Scores: `encoder.${layerIndex}.mha.h${headIndex}.Scores`,
        ScaledScores: `encoder.${layerIndex}.mha.h${headIndex}.ScaledScores`,
        AttentionWeights: `encoder.${layerIndex}.mha.h${headIndex}.AttentionWeights`,
        HeadOutput: `encoder.${layerIndex}.mha.h${headIndex}.HeadOutput`,
    }),

    // A conceptual name for the concatenated heads, used only in explanations
    concatOutput: (layerIndex: number) => `encoder.${layerIndex}.mha.ConcatOutput`,
};

// END OF FILE: src/config/matrixNames.ts


================================================================================
### 文件路径: src/config/symbolMapping.ts
================================================================================

// FILE: src/config/symbolMapping.ts

// This file is the single source of truth for mapping a matrix's unique name
// to its mathematical symbol parts for consistent rendering.

interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

const SYMBOL_CONFIG: { [key: string]: SymbolParts } = {
    // Input
    inputEmbeddings: { base: 'E' },
    posEncodings: { base: 'PE' },
    encoderInput: { base: 'Z' },
    encoder_input: { base: 'Z' }, // Alias for layers

    // MHA Weights
    Wq: { base: 'W', superscript: 'Q', subscript: 'q' },
    Wk: { base: 'W', superscript: 'K', subscript: 'k' },
    Wv: { base: 'W', superscript: 'V', subscript: 'v' },
    Wo: { base: 'W', superscript: 'O', subscript: 'o' },

    // MHA Tensors
    Q: { base: 'Q' },
    K: { base: 'K' },
    V: { base: 'V' },
    Scores: { base: 'S' },
    ScaledScores: { base: "S'" },
    AttentionWeights: { base: 'A' },
    HeadOutput: { base: 'H' },
    ConcatOutput: { base: 'H_{cat}'},
    mha_output: { base: 'M' },

    // Add & Norm
    add_norm_1_output: { base: "Z'" },
    add_norm_2_output: { base: "Z''" },

    // FFN
    W1: { base: 'W', subscript: '1' },
    b1: { base: 'b', subscript: '1' },
    Intermediate: { base: 'H_{ffn}' },
    Activated: { base: 'H_{act}' },
    W2: { base: 'W', subscript: '2' },
    b2: { base: 'b', subscript: '2' },
    ffn_output: { base: 'F' },
};

/**
 * Gets the consistent mathematical symbol parts for a given matrix name.
 * @param name The full, unique name of the matrix (e.g., "encoder.0.add_norm_1_output").
 * @returns An object with base, superscript, and subscript parts.
 */
export const getSymbolParts = (name: string): SymbolParts => {
    const conceptualName = name.split('.').pop() || '';
    return SYMBOL_CONFIG[conceptualName] || { base: 'X' }; // Default to 'X' if not found
};
// END OF FILE: src/config/symbolMapping.ts


================================================================================
### 文件路径: src/hooks/useTransformer.ts
================================================================================

// FILE: src/hooks/useTransformer.ts
import { useMemo } from 'react';
import { Matrix, TransformerData, EncoderLayerData, FFNData, MultiHeadAttentionData, AttentionHeadData, Vector } from '../types';

// --- Utility Functions ---

const createRandomMatrix = (rows: number, cols: number): Matrix => {
  return Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)))
  );
};

const createRandomVector = (size: number): Vector => {
  return Array.from({ length: size }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)));
}

const addMatrices = (A: Matrix, B: Matrix): Matrix => {
  return A.map((row, i) =>
    row.map((val, j) => parseFloat((val + B[i][j]).toFixed(2)))
  );
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
  const rowsA = A.length;
  const colsA = A[0].length;
  const colsB = B[0].length;
  const result: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));

  for (let i = 0; i < rowsA; i++) {
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      result[i][j] = parseFloat(sum.toFixed(2));
    }
  }
  return result;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => {
    return A.map(row => row.map(val => parseFloat((val / scalar).toFixed(2))));
}

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row);
        const exps = row.map(val => Math.exp(val - maxVal));
        const sumExps = exps.reduce((a, b) => a + b, 0);
        return exps.map(exp => parseFloat((exp / sumExps).toFixed(2)));
    });
}

const layerNorm = (A: Matrix): Matrix => {
    return A.map(row => {
        const mean = row.reduce((a,b) => a+b, 0) / row.length;
        const variance = row.map(x => (x - mean) ** 2).reduce((a,b) => a+b,0) / row.length;
        const std = Math.sqrt(variance + 1e-5);
        return row.map(x => parseFloat(((x - mean) / std).toFixed(2)));
    });
}

const applyReLU = (A: Matrix): Matrix => {
    return A.map(row => row.map(val => Math.max(0, val)));
}

const addBias = (A: Matrix, b: Vector): Matrix => {
    return A.map(row => row.map((val, j) => parseFloat((val + b[j]).toFixed(2))));
}

// --- Main Hook ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number;
    n_layers: number;
    d_ff: number;
}

export const useTransformer = (dims: Dims): TransformerData | null => {

  return useMemo(() => {
    try {
        const { d_model, h, seq_len, n_layers, d_ff } = dims;
        if (d_model % h !== 0) return null;
        const d_k = d_model / h;

        const inputEmbeddings = createRandomMatrix(seq_len, d_model);
        const posEncodings: Matrix = Array.from({ length: seq_len }, (_, pos) =>
          Array.from({ length: d_model }, (_, i) =>
            parseFloat((i % 2 === 0
              ? Math.sin(pos / (10000 ** (i / d_model)))
              : Math.cos(pos / (10000 ** ((i - 1) / d_model)))).toFixed(2))
          )
        );
        const encoderInput = addMatrices(inputEmbeddings, posEncodings);

        let currentInput = encoderInput;
        const encoderLayers: EncoderLayerData[] = [];

        for (let i = 0; i < n_layers; i++) {
            const encoder_input = currentInput;

            // MHA
            const heads: AttentionHeadData[] = [];
            const headOutputs: Matrix[] = [];
            for(let j=0; j < h; j++) {
                const Wq = createRandomMatrix(d_model, d_k);
                const Wk = createRandomMatrix(d_model, d_k);
                const Wv = createRandomMatrix(d_model, d_k);

                const Q = multiplyMatrices(encoder_input, Wq);
                const K = multiplyMatrices(encoder_input, Wk);
                const V = multiplyMatrices(encoder_input, Wv);

                const K_T: Matrix = Array.from({ length: d_k }, (_, r) => Array.from({ length: seq_len }, (_, c) => K[c][r]));
                const Scores = multiplyMatrices(Q, K_T);

                const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
                const AttentionWeights = softmaxByRow(ScaledScores);
                const HeadOutput = multiplyMatrices(AttentionWeights, V);

                heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
                headOutputs.push(HeadOutput);
            }
            const ConcatOutput = headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(seq_len).fill(0).map(() => []));
            const Wo = createRandomMatrix(d_model, d_model);
            const mha_output = multiplyMatrices(ConcatOutput, Wo);
            const mha: MultiHeadAttentionData = { heads, Wo, Output: mha_output };

            const add_norm_1_sum = addMatrices(encoder_input, mha_output);
            const add_norm_1_output = layerNorm(add_norm_1_sum);

            const W1 = createRandomMatrix(d_model, d_ff);
            const b1 = createRandomVector(d_ff);
            const Intermediate = addBias(multiplyMatrices(add_norm_1_output, W1), b1);
            const Activated = applyReLU(Intermediate);
            const W2 = createRandomMatrix(d_ff, d_model);
            const b2 = createRandomVector(d_model);
            const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
            const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };

            const add_norm_2_sum = addMatrices(add_norm_1_output, ffn_output);
            const add_norm_2_output = layerNorm(add_norm_2_sum);

            encoderLayers.push({
                encoder_input,
                mha,
                mha_output,
                add_norm_1_output,
                ffn,
                ffn_output,
                add_norm_2_output
            });

            currentInput = add_norm_2_output;
        }

        return {
            inputEmbeddings,
            posEncodings,
            encoderInput,
            encoderLayers
        };
    } catch (e) {
        console.error("Error during transformer calculation:", e);
        return null;
    }
  }, [dims]);
};
// END OF FILE: src/hooks/useTransformer.ts


================================================================================
### 文件路径: public/index.html
================================================================================

<!-- START OF FILE: public/index.html -->
<!--# FILE: public/index.html-->

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>矩阵可视化 (React)</title>
    <!-- 引入 MathJax 用于渲染 LaTeX 公式 -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

<!--# END OF FILE: public/index.html-->


