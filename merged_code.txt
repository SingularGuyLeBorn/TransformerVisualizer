================================================================================
### 文件路径: src/App.css
================================================================================

/*// FILE: src/App.css*/
:root {
  --highlight-color: #c0392b;
  --highlight-bg: rgba(192, 57, 43, 0.08);
  --border-color: #dcdfe6;
  --bg-color: #f5f7fa;
  --text-color: #303133;
  --arrow-color: #888;
  --component-bg: #ffffff;
  --component-header-bg: #f8f9fa;
  --residual-bg: #f0f4c3;
  --residual-border: #dce775;

  /* Highlighting */
  --highlight-target-bg: rgba(230, 57, 70, 0.15);
  --highlight-target-color: #d63031;
  --highlight-target-border: #e63946;
  --highlight-source-bg: rgba(96, 98, 102, 0.1);
  --highlight-source-color: #2f3542;
  --highlight-source-border: #606266;

  --highlight-formula-bg: rgba(252, 163, 17, 0.15);
  --highlight-formula-border: #fca311;
  --highlight-vector-bg: rgba(69, 123, 157, 0.2);
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  background-color: var(--bg-color);
  color: var(--text-color);
  margin: 0;
  font-size: 15px;
}

#root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

h1 {
  text-align: center;
  color: #000;
  margin: 0;
  padding: 20px 0;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
}


/* Specific overrides for Controls Panel (kept here as it's used by multiple topics) */
.controls-panel .panel-header {
    padding: 5px;
}
.controls-panel .panel-toggle-btn {
    width: 40px;
    height: 40px;
    font-size: 20px;
}
.controls-panel.collapsed {
    padding: 0;
    min-width: 50px;
    min-height: 50px;
    width: 50px !important;
    height: 50px !important;
    transition: width 0.3s ease, height 0.3s ease;
}
.controls-panel.collapsed .resize-handle {
    display: none;
}
.controls-container {
    padding: 20px;
    flex-grow: 1;
    overflow-y: auto;
}


/* [NEW] Split pane separator style */
.split-pane-separator {
    width: 8px;
    background-color: #e4e7ed;
    cursor: col-resize;
    flex-shrink: 0;
    z-index: 10;
    transition: background-color 0.2s ease;
}
.split-pane-separator:hover {
    background-color: #409eff;
}

/*// END OF FILE: src/App.css*/



================================================================================
### 文件路径: src/App.tsx
================================================================================

// FILE: src/App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';
// [FIXED] Corrected import paths based on our new flat 'pages' directory structure
import { HomePage } from './pages/HomePage/HomePage';
import { TopicPage } from './pages/TopicPage/TopicPage';
import './App.css'; // Global styles remain

function App() {
  return (
    <Router>
      <div className="app-container">
        <header className="app-header">
            <h1><Link to="/" style={{ textDecoration: 'none', color: 'inherit' }}>AI 深度探索专题</Link></h1>
        </header>
        <main className="app-main-content">
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/topic/:topicId" element={<TopicPage />} />
          </Routes>
        </main>
      </div>
    </Router>
  );
}

// Add new global styles for the new layout
const globalStyles = `
  .app-header {
    flex-shrink: 0;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--component-bg);
    z-index: 1001; /* Ensure header is on top */
  }
  .app-header h1 {
    padding: 15px 0;
    font-size: 1.8em;
  }
  .app-main-content {
    flex-grow: 1;
    overflow: hidden; /* It should NOT scroll itself */
    min-height: 0; /* Crucial for nested flex scrolling */
    position: relative; /* Needed for absolute positioned children like controls */
  }
  /* This is now a generic container for standard pages that need scrolling */
  .page-scroll-container {
      height: 100%;
      overflow-y: auto;
  }
`;

// Use a more robust way to ensure the stylesheet is added only once.
if (!document.getElementById('app-global-styles')) {
    const styleSheet = document.createElement("style");
    styleSheet.id = 'app-global-styles';
    styleSheet.innerText = globalStyles;
    document.head.appendChild(styleSheet);
}


export default App;

// END OF FILE: src/App.tsx



================================================================================
### 文件路径: src/components/CalculationTooltip/CalculationTooltip.css
================================================================================

/* FILE: src/components/CalculationTooltip/CalculationTooltip.css */

/* [EXTRACTED] Generic styles for draggable/resizable panels */
.resizable-panel {
    position: absolute;
    background-color: var(--component-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}
.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #eee;
    padding: 8px 15px;
    margin: 0;
    cursor: move;
    background-color: var(--component-header-bg);
    flex-shrink: 0;
}
.panel-title {
    font-weight: bold;
    font-size: 1.1em;
}
.panel-toggle-btn, .tooltip-close-btn, .tooltip-toggle-btn {
    background: none;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
    color: #999;
    padding: 0 5px;
    line-height: 1;
}
.panel-toggle-btn:hover, .tooltip-close-btn:hover, .tooltip-toggle-btn:hover {
    color: #333;
}
.resize-handle {
    position: absolute;
    opacity: 0;
    transition: opacity 0.2s ease;
}
.resizable-panel:hover .resize-handle {
    opacity: 1;
}
.resize-handle.br { right: 0; bottom: 0; width: 15px; height: 15px; cursor: nwse-resize; }
.resize-handle.t { top: 0; left: 5px; right: 5px; height: 5px; cursor: ns-resize; }
.resize-handle.r { top: 5px; right: 0; bottom: 5px; width: 5px; cursor: ew-resize; }
.resize-handle.b { bottom: 0; left: 5px; right: 5px; height: 5px; cursor: ns-resize; }
.resize-handle.l { top: 5px; left: 0; bottom: 5px; width: 5px; cursor: ew-resize; }


/* [EXTRACTED & REFINED] Specific styles for Calculation Tooltip */
.calculation-tooltip {
    /* max-width is intentionally NOT set to allow the tooltip to become very wide if needed. */
    width: auto;
    font-size: 0.95em;
}
.calculation-tooltip .panel-header {
    cursor: move;
}
.calculation-tooltip .panel-header .tooltip-controls {
    display: flex;
    align-items: center;
    gap: 5px;
}
.calculation-tooltip .panel-header .view-toggle-btn {
    font-size: 0.8em;
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    background-color: #f0f0f0;
}
.calculation-tooltip .panel-header .view-toggle-btn:hover {
    background-color: #e0e0e0;
}
.calculation-tooltip.collapsed {
    height: auto !important;
}
.calculation-tooltip.collapsed .tooltip-content-wrapper {
    max-height: 0;
    overflow: hidden;
}
.tooltip-content-wrapper {
    flex-grow: 1;
    min-height: 0;
    overflow-y: auto;
    transition: max-height 0.3s ease-in-out;
    max-height: 1000px; /* Generous max height */
}
.tooltip-body {
    padding: 15px;
    display: flex;
    flex-direction: column;
    min-height: 100%;
    box-sizing: border-box;
}
.calculation-content-container {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
.calculation-content-container > div { /* Target the visualizer's root div */
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}


/* [EXTRACTED & REFINED] Styles for upgraded tooltip content */
.tooltip-step-container {
    padding: 10px 0;
    border-bottom: 1px dashed #eee;
}
.tooltip-step-container:last-child {
    border-bottom: none;
}
.tooltip-step-title {
    font-family: sans-serif;
    font-size: 1em;
    font-weight: bold;
    color: #333;
    margin: -10px 0 10px 0;
}
.tooltip-vector-group {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 5px 0;
}
.tooltip-symbol {
    font-family: 'Times New Roman', serif;
    font-weight: bold;
    font-size: 1.2em;
}
.tooltip-vector {
    display: flex;
    gap: 3px;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 4px;
    background-color: #f9f9f9;
    overflow-x: auto;
}
.tooltip-vector.column {
    flex-direction: column;
}
.tooltip-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  transition: all 0.2s ease;
}
.tooltip-element.highlight {
    background-color: var(--highlight-formula-bg);
    border-color: var(--highlight-formula-border);
    transform: scale(1.1);
}
.tooltip-op-symbol {
    font-size: 1.4em;
    font-weight: bold;
    padding: 0 8px;
}
.tooltip-matmul-container, .tooltip-add-container { /* [MODIFIED] Added add-container */
    display: inline-flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
}
.tooltip-result-line {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1.1em;
}
.tooltip-result {
    padding: 2px 6px;
    border-radius: 4px;
    background-color: var(--highlight-target-bg);
    border: 1px solid var(--highlight-target-border);
    color: var(--highlight-target-color);
    font-weight: bold;
}
.tooltip-calculation-detail {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #eee;
    width: 100%;
}
.tooltip-calc-title {
    font-weight: bold;
    font-size: 0.9em;
    color: #333;
    margin-bottom: 8px;
    font-family: sans-serif;
}
.tooltip-calc-equation {
    font-family: monospace;
    font-size: 0.95em;
    color: #555;
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    row-gap: 5px;
}
.tooltip-calc-equation-multi {
    font-family: monospace;
    font-size: 0.95em;
    color: #555;
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto;
    white-space: pre-wrap;
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.tooltip-calc-equation > * {
    margin-right: 5px;
}
.tooltip-calc-equation .op {
    color: #c0392b;
    font-weight: bold;
}
.tooltip-calc-equation .result {
    font-weight: bold;
    color: var(--highlight-target-color);
}
.tooltip-calc-term {
    transition: background-color 0.2s ease;
    border-radius: 3px;
    padding: 1px 3px;
    cursor: default;
    white-space: nowrap;
}
.tooltip-calc-term.highlight {
    background-color: var(--highlight-formula-bg);
}

.tooltip-braced-group {
    display: flex;
    align-items: center;
    gap: 5px;
}
.tooltip-curly-brace {
    font-size: 2.5em;
    color: #555;
    font-family: serif;
    align-self: center;
}
.tooltip-calc-terms-wrapper {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    row-gap: 5px;
}
.tooltip-calc-terms-wrapper > * {
    margin-right: 5px;
}


/* Generic styles for matrix symbolic display in tooltips */
.matrix-wrapper {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
}
.matrix-wrapper.side-label {
    flex-direction: row;
    gap: 8px;
    align-items: center;
}
.matrix-wrapper .matrix-label-side {
    font-size: 1.1em;
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    border: 1px solid #ced4da;
    line-height: 1;
}

/* END OF FILE: src/components/CalculationTooltip/CalculationTooltip.css */



================================================================================
### 文件路径: src/components/CalculationTooltip/CalculationTooltip.tsx
================================================================================

// FILE: src/components/CalculationTooltip/CalculationTooltip.tsx
import React, { useState, useEffect, useRef } from 'react';
import { TooltipState } from './types';
import { useDraggableAndResizable } from '../../hooks/useDraggableAndResizable';
import { InteractiveMatMulVisualizer } from '../visualizers/InteractiveMatMulVisualizer';
import { SoftmaxVisualizer } from '../visualizers/SoftmaxVisualizer';
import { ActivationFunctionVisualizer } from '../visualizers/ActivationFunctionVisualizer';
import { ElementWiseOpVisualizer } from '../visualizers/ElementWiseOpVisualizer';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../../topics/transformer-explorer/lib/symbolMapping';
import './CalculationTooltip.css';
import { LayerNormVisualizer } from '../visualizers/LayerNormVisualizer';

interface CalculationTooltipProps {
  tooltip: TooltipState;
  onClose: () => void;
  initialViewMode?: 'compact' | 'detailed';
}

const formatNumber = (num: number, precision = 4) => {
    if (num === null || num === undefined || isNaN(num)) return '?';
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '+∞';
    const fixed = num.toFixed(precision);
    return parseFloat(fixed).toString();
};

const ELLIPSIS = '...';
const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {
  const MIN_SIZE_FOR_TRUNCATION = 12;
  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }
  const visible = new Set<number>();
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) visible.add(i);
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) visible.add(totalSize - 1 - i);
  if (focusIndex === -1) visible.add(Math.floor((totalSize - 1) / 2));
  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) visible.add(i);
  }
  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];
  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) result.push(ELLIPSIS);
      result.push(sorted[i]);
    }
  }
  return result;
};

export const CalculationTooltip: React.FC<CalculationTooltipProps> = ({ tooltip, onClose, initialViewMode = 'compact' }) => {
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [viewMode, setViewMode] = useState<'compact' | 'detailed'>(initialViewMode);
    const [hoveredComponentIndex, setHoveredComponentIndex] = useState<number | null>(null);
    const panelRef = useRef<HTMLDivElement>(null);

    const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
        x: 20,
        y: 20,
        width: 800,
        height: 600,
    }, panelRef);

    useEffect(() => {
        setIsCollapsed(false);
        setViewMode(initialViewMode);
        setHoveredComponentIndex(null);
    }, [tooltip, initialViewMode]);

    const renderVector = (vec: number[], symbolInfo: TooltipState['steps'][0]['aSymbolInfo'], direction: 'row' | 'column' = 'row') => {
        let mathSymbol = symbolInfo.base;
        if (symbolInfo.subscript) mathSymbol += `_{${symbolInfo.subscript}}`;
        if (symbolInfo.superscript) mathSymbol += `^{${symbolInfo.superscript}}`;

        return (
            <div className="tooltip-vector-group">
                <span className="tooltip-symbol"><InlineMath>{mathSymbol}</InlineMath> =</span>
                <div className={`tooltip-vector ${direction}`}>
                    {vec.map((val, i) => (
                        <span key={i} className={`tooltip-element source ${hoveredComponentIndex === i ? 'highlight' : ''}`}>
                            {formatNumber(val, 2)}
                        </span>
                    ))}
                </div>
            </div>
        );
    };

    const renderBody = () => {
        if (!tooltip.steps || tooltip.steps.length === 0) return null;

        if (viewMode === 'detailed') {
            return null;
        }

        // COMPACT (DECOMPOSITION) VIEW
        return tooltip.steps.map((step, stepIndex) => {
            let content;
            const focusIndex = tooltip.target.col;

            switch(tooltip.opType) {
                case 'matmul':
                    const components = step.a.map((val, i) => ({ a: val, b: step.b[i] }));
                    const visibleTermIndices = getVisibleIndices(components.length, hoveredComponentIndex ?? -1, 1, 5);
                    content = (
                        <div className="tooltip-matmul-container">
                            {renderVector(step.a, step.aSymbolInfo, 'row')}
                            <div className="tooltip-op-symbol">·</div>
                            {renderVector(step.b, step.bSymbolInfo, 'column')}
                            <div className="tooltip-result-line">
                                <span className="tooltip-op-symbol">=</span>
                                <span className="tooltip-result">{formatNumber(step.result, 4)}</span>
                            </div>
                            <div className="tooltip-calculation-detail">
                                <div className="tooltip-calc-title">点积计算分解:</div>
                                <div className="tooltip-calc-equation">
                                    <div className="tooltip-braced-group">
                                        <span className="tooltip-curly-brace">{'{'}</span>
                                        <div className="tooltip-calc-terms-wrapper">
                                            {visibleTermIndices.map((idx, i) => {
                                                if (idx === ELLIPSIS) return <span key={`ellipsis-${i}`} className="op">...</span>;
                                                const comp = components[idx];
                                                return (
                                                    <React.Fragment key={idx}>
                                                        {i > 0 && visibleTermIndices[i-1] !== ELLIPSIS && <span className="op">+</span>}
                                                        <span onMouseEnter={() => setHoveredComponentIndex(idx)} onMouseLeave={() => setHoveredComponentIndex(null)}>
                                                            <span className={`tooltip-calc-term ${hoveredComponentIndex === idx ? 'highlight' : ''}`}>
                                                                ({formatNumber(comp.a, 2)} <span className="op">×</span> {formatNumber(comp.b, 2)})
                                                            </span>
                                                        </span>
                                                    </React.Fragment>
                                                );
                                            })}
                                        </div>
                                        <span className="tooltip-curly-brace">{'}'}</span>
                                    </div>
                                    <span>=</span>
                                    <span className="result">{formatNumber(step.result, 4)}</span>
                                </div>
                            </div>
                        </div>
                    );
                    break;
                case 'add':
                     const addStep = tooltip.steps.find(s => s.op === '+') || step;
                    content = (
                        <div className="tooltip-add-container">
                             {renderVector(addStep.a, addStep.aSymbolInfo, 'row')}
                             <div className="tooltip-op-symbol">+</div>
                             {renderVector(addStep.b, addStep.bSymbolInfo, 'row')}
                             <div className="tooltip-result-line">
                                 <span className="tooltip-op-symbol">=</span>
                                 <span className="tooltip-result">{formatNumber(addStep.result, 4)}</span>
                             </div>
                        </div>
                    );
                    break;
                case 'softmax':
                    const finiteInputRow = step.a.filter(v => isFinite(v));
                    const maxVal = finiteInputRow.length > 0 ? Math.max(...finiteInputRow) : 0;
                    const exps = step.a.map(v => isFinite(v) ? Math.exp(v - maxVal) : 0);
                    const sumExps = exps.reduce((a, b) => a + b, 0);
                    content = (
                        <>
                            {renderVector(step.a, step.aSymbolInfo, 'row')}
                            <div className="tooltip-calculation-detail">
                                <div className="tooltip-calc-title">Softmax 计算分解 (for {tooltip.target.symbol}[{tooltip.target.row}, {tooltip.target.col}]):</div>
                                <div className="tooltip-calc-equation-multi">
                                    <div>1. 减去最大值: <span>max(...) = {formatNumber(maxVal, 2)}</span></div>
                                    <div>2. 计算指数: <span>e^({formatNumber(step.a[focusIndex], 2)} - {formatNumber(maxVal, 2)}) = {formatNumber(exps[focusIndex], 4)}</span></div>
                                    <div>3. 计算所有指数之和: <span>Σ e^(...) = {formatNumber(sumExps, 4)}</span></div>
                                    <div>4. 归一化: <span>{formatNumber(exps[focusIndex], 4)} / {formatNumber(sumExps, 4)} = <span className="result">{formatNumber(step.result, 4)}</span></span></div>
                                </div>
                            </div>
                        </>
                    );
                    break;
                case 'relu':
                    content = (
                        <>
                            {renderVector(step.a, step.aSymbolInfo, 'row')}
                            <div className="tooltip-calculation-detail">
                                <div className="tooltip-calc-title">ReLU 计算:</div>
                                <div className="tooltip-calc-equation">
                                    <span>max(0, {formatNumber(step.a[focusIndex], 2)}) = <span className="result">{formatNumber(step.result, 2)}</span></span>
                                </div>
                            </div>
                        </>
                    );
                    break;
                 case 'layernorm':
                    const mean = step.a.reduce((a, b) => a + b, 0) / step.a.length;
                    const variance = step.a.map(x => Math.pow(x - mean, 2)).reduce((a,b) => a+b, 0) / step.a.length;
                    content = (
                         <>
                            {renderVector(step.a, step.aSymbolInfo, 'row')}
                            <div className="tooltip-calculation-detail">
                                <div className="tooltip-calc-title">LayerNorm 计算分解:</div>
                                 <div className="tooltip-calc-equation-multi">
                                    <div>1. 计算均值 μ: <span>{formatNumber(mean, 4)}</span></div>
                                    <div>2. 计算方差 σ²: <span>{formatNumber(variance, 4)}</span></div>
                                    <div>3. 归一化 (for index {focusIndex}): <span>({formatNumber(step.a[focusIndex], 2)} - {formatNumber(mean, 2)}) / √({formatNumber(variance, 2)} + ε) = <span className="result">{formatNumber(step.result, 4)}</span></span></div>
                                </div>
                            </div>
                        </>
                    );
                    break;
                default:
                    content = <div>未知操作类型。</div>;
            }
            return (
                <div className="tooltip-step-container" key={stepIndex}>
                    {step.title && <h4 className="tooltip-step-title">{step.title}</h4>}
                    {content}
                </div>
            );
        });
    };

    const panelStyle: React.CSSProperties = {
        top: position.y,
        left: position.x,
        width: size.width,
        height: typeof size.height === 'number' && !isCollapsed ? size.height : 'auto',
    };

    return (
        <div ref={panelRef} style={panelStyle} className={`calculation-tooltip ${isCollapsed ? 'collapsed' : ''} resizable-panel`}>
            <div className="panel-header" {...dragHandleProps}>
                <span className="panel-title">
                     <InlineMath>{`Calculation for ${tooltip.target.symbol || ''}[${tooltip.target.row},${tooltip.target.col}]`}</InlineMath>
                </span>
                <div className="tooltip-controls">
                    <button onClick={() => setIsCollapsed(!isCollapsed)} className="tooltip-toggle-btn">
                        {isCollapsed ? '⊕' : '⊖'}
                    </button>
                    <button onClick={onClose} className="tooltip-close-btn">&times;</button>
                </div>
            </div>
            <div className="tooltip-content-wrapper">
                <div className="tooltip-body">
                    {renderBody()}
                </div>
            </div>
            <div className="resize-handle br" {...resizeHandleProps.br}></div>
            <div className="resize-handle t" {...resizeHandleProps.t}></div>
            <div className="resize-handle r" {...resizeHandleProps.r}></div>
            <div className="resize-handle b" {...resizeHandleProps.b}></div>
            <div className="resize-handle l" {...resizeHandleProps.l}></div>
        </div>
    );
};
// END OF FILE: src/components/CalculationTooltip/CalculationTooltip.tsx



================================================================================
### 文件路径: src/components/CalculationTooltip/types.ts
================================================================================

// FILE: src/components/CalculationTooltip/types.ts
import { SymbolInfo, Vector } from '../../components/visualizers/types';

// This file defines the standardized, generic types for the unified CalculationTooltip.
// All topics must produce a TooltipState object conforming to this structure.

/**
 * Represents a single element being interacted with.
 */
export interface ElementIdentifier {
  name: string;
  row: number;
  col: number;
  isInternal?: boolean;
  symbol?: string; // The full LaTeX string for the element, e.g., "Z_{final}[1,2]"
  layerIndex?: number;
  headIndex?: number;
}

/**
 * Represents a single component in a dot product calculation (a * b).
 */
export interface CalculationComponent {
    a: number;
    b: number;
}

/**
 * Represents a single step in a calculation breakdown.
 * Can be a matmul, an element-wise op, or a complex function like softmax.
 */
export interface CalculationStep {
    title?: string;
    a: Vector;
    b: Vector;
    op: string;
    result: number;
    aSymbolInfo: SymbolInfo;
    bSymbolInfo: SymbolInfo;
    aLabel?: string;
    bLabel?: string;
    resultLabel?: string;
    aSources?: { data: Vector, symbolInfo: SymbolInfo }[];
    bSources?: { data: Vector, symbolInfo: SymbolInfo }[];
    components?: CalculationComponent[];
}

/**
 * The complete state required by the unified CalculationTooltip component.
 */
export interface TooltipState {
    target: ElementIdentifier;
    opType: 'matmul' | 'add' | 'softmax' | 'relu' | 'layernorm' | 'wx-plus-b' | 'info';
    steps: CalculationStep[];
    title: string;
}

// END OF FILE: src/components/CalculationTooltip/types.ts



================================================================================
### 文件路径: src/components/MarkdownRenderer.tsx
================================================================================

// FILE: src/components/MarkdownRenderer.tsx
import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
import 'katex/dist/katex.min.css';

interface MarkdownRendererProps {
  children: string;
}

const MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ children }) => {
  // react-markdown expects children to be a string, not a React node array
  // The content is passed directly as the child of ReactMarkdown
  return (
    <ReactMarkdown
      remarkPlugins={[remarkMath]}
      rehypePlugins={[rehypeKatex]}
    >
      {children}
    </ReactMarkdown>
  );
};

export default MarkdownRenderer;
// END OF FILE: src/components/MarkdownRenderer.tsx



================================================================================
### 文件路径: src/components/ViewToggle/ViewToggle.css
================================================================================

/* FILE: src/components/ViewToggle/ViewToggle.css */
.view-toggle-container {
    position: absolute;
    top: 20px;
    left: 80px; /* Position it to the right of the sidebar toggle */
    z-index: 1005;
    background-color: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(5px);
    border-radius: 8px;
    padding: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    display: flex;
    gap: 5px;
    border: 1px solid var(--border-color);
}

.view-toggle-button {
    padding: 8px 16px;
    font-size: 0.9em;
    font-weight: 500;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    background-color: transparent;
    color: #606266;
    transition: all 0.2s ease-in-out;
}

.view-toggle-button.active {
    background-color: #409eff;
    color: #fff;
    box-shadow: 0 2px 5px rgba(64, 158, 255, 0.3);
}

.view-toggle-button:not(.active):hover {
    background-color: #f0f2f5;
}

.view-toggle-close-button {
    background: none;
    border: 1px solid #e0e0e0;
    border-radius: 50%;
    color: #909399;
    cursor: pointer;
    width: 28px;
    height: 28px;
    font-size: 1.2em;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 5px;
    transition: all 0.2s ease;
}

.view-toggle-close-button:hover {
    background-color: #f56c6c;
    color: white;
    border-color: #f56c6c;
}
/* END OF FILE: src/components/ViewToggle/ViewToggle.css */



================================================================================
### 文件路径: src/components/ViewToggle/ViewToggle.tsx
================================================================================

// FILE: src/components/ViewToggle/ViewToggle.tsx
import React from 'react';
import './ViewToggle.css';

export type ViewMode = 'decomposition' | 'animation' | 'none';

interface ViewToggleProps {
  viewMode: ViewMode;
  setViewMode: React.Dispatch<React.SetStateAction<ViewMode>>;
}

export const ViewToggle: React.FC<ViewToggleProps> = ({ viewMode, setViewMode }) => {
  return (
    <div className="view-toggle-container">
      <button
        className={`view-toggle-button ${viewMode === 'decomposition' ? 'active' : ''}`}
        onClick={() => setViewMode(prev => prev === 'decomposition' ? 'none' : 'decomposition')}
        title="切换到分解视图模式"
      >
        分解视图
      </button>
      <button
        className={`view-toggle-button ${viewMode === 'animation' ? 'active' : ''}`}
        onClick={() => setViewMode(prev => prev === 'animation' ? 'none' : 'animation')}
        title="切换到动画视图模式"
      >
        动画视图
      </button>
      {viewMode !== 'none' && (
         <button
            className="view-toggle-close-button"
            onClick={() => setViewMode('none')}
            title="关闭视图模式"
         >
            &times;
         </button>
      )}
    </div>
  );
};

// END OF FILE: src/components/ViewToggle/ViewToggle.tsx



================================================================================
### 文件路径: src/components/visualizers/ActivationFunctionVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/ActivationFunctionVisualizer.tsx
import React, { useMemo, useState } from 'react';
import { Vector, ActivationFunctionType, ActivationStep } from './types';
import { formatNumber, useAnimationController } from './utils';
import { InlineMath } from 'react-katex';

interface ActivationFunctionVisualizerProps {
    inputVector: Vector;
    functionType: ActivationFunctionType;
    inputLabel?: string;
    outputLabel?: string;
}

export const ActivationFunctionVisualizer: React.FC<ActivationFunctionVisualizerProps> = ({ inputVector, functionType, inputLabel = "Input", outputLabel = "Output" }) => {
    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

    const functions = {
        relu: (x: number) => Math.max(0, x),
        gelu: (x: number) => 0.5 * x * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * Math.pow(x, 3)))),
        silu: (x: number) => x / (1 + Math.exp(-x)),
    };

    const outputVector = useMemo(() => inputVector.map(functions[functionType]), [inputVector, functionType]);

    const steps: ActivationStep[] = useMemo(() => {
        const generatedSteps: ActivationStep[] = [{ type: 'start' }];
        inputVector.forEach((_, i) => {
            generatedSteps.push({ type: 'process', index: i });
        });
        generatedSteps.push({ type: 'finish' });
        return generatedSteps;
    }, [inputVector]);

    const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 600);
    const currentAnimState = steps[currentStep] || { type: 'idle' };
    const activeIndex = (currentAnimState.type === 'process') ? (currentAnimState as any).index : (currentAnimState.type === 'finish' ? inputVector.length - 1 : -1);
    const lastCalculatedIndex = (currentAnimState.type === 'finish') ? inputVector.length - 1 : activeIndex;

    const displayIndex = hoveredIndex !== null ? hoveredIndex : activeIndex;

    const elementWidth = '60px';

    const styles: { [key: string]: React.CSSProperties } = {
        container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
        title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold', textTransform: 'uppercase' },
        mainArea: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '20px', width: '100%' },
        vectorSection: { display: 'flex', width: '100%', gap: '15px', alignItems: 'center' },
        label: { fontWeight: 'bold', color: '#495057', fontSize: '1.5em', width: '80px', textAlign: 'right' },
        vectorGroup: { flex: 1, minWidth: 0 },
        vectorScroll: { overflowX: 'auto', padding: '5px' },
        vector: { display: 'flex', gap: '5px', width: 'max-content' },
        elementColumn: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px' },
        indexLabel: { width: elementWidth, height: '20px', display: 'flex', justifyContent: 'center', alignItems: 'center', color: '#495057', fontSize: '0.8em', fontFamily: 'monospace', boxSizing: 'border-box', backgroundColor: '#f0f2f5', border: '1px solid #dee2e6', borderRadius: '4px' },
        element: { width: elementWidth, height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', boxSizing: 'border-box', cursor: 'pointer' },
        highlightAnim: { transform: 'scale(1.15)', borderColor: '#4a90e2', backgroundColor: 'rgba(74, 144, 226, 0.1)' },
        highlightHover: { borderColor: '#f5a623', backgroundColor: 'rgba(245, 166, 35, 0.1)' },
        calculationBox: { height: '60px', display: 'flex', alignItems: 'center', justifyContent: 'center', backgroundColor: '#fff', border: '1px solid #dee2e6', borderRadius: '8px', padding: '10px 20px', fontSize: '1.2em', transition: 'opacity 0.3s, background-color 0.3s', fontFamily: 'monospace' },
        controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '10px' },
        button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
        playingButton: { backgroundColor: '#6c757d', color: '#fff' },
    };

    const activeInput = displayIndex > -1 ? inputVector[displayIndex] : null;
    const activeOutput = displayIndex > -1 ? outputVector[displayIndex] : null;
    const calculationString = activeInput !== null && activeOutput !== null
        ? `max(0, ${formatNumber(activeInput, 2)}) = ${formatNumber(activeOutput, 2)}`
        : '...';

    const renderVector = (vec: Vector, label: string, isOutput: boolean) => (
        <div style={styles.vectorSection}>
            <div style={styles.label}><InlineMath>{label}</InlineMath></div>
            <div style={styles.vectorGroup}>
                <div style={styles.vectorScroll}>
                    <div style={styles.vector}>
                        {vec.map((val, i) => (
                            <div key={i} style={styles.elementColumn}>
                                <div style={styles.indexLabel}>{i}</div>
                                <div
                                    style={{
                                        ...styles.element,
                                        ...(displayIndex === i ? (hoveredIndex === i ? styles.highlightHover : styles.highlightAnim) : {}),
                                        opacity: isOutput && i > lastCalculatedIndex && hoveredIndex === null ? 0.3 : 1
                                    }}
                                    onMouseEnter={() => setHoveredIndex(i)}
                                    onMouseLeave={() => setHoveredIndex(null)}
                                >
                                    {isOutput && i > lastCalculatedIndex && hoveredIndex === null ? '?' : formatNumber(val, 2)}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );

    return (
        <div style={styles.container}>
            <h3 style={styles.title}>{functionType} Activation</h3>
            <div style={styles.mainArea}>
                {renderVector(inputVector, inputLabel!, false)}

                <div style={{ ...styles.calculationBox, opacity: displayIndex > -1 ? 1 : 0.2, backgroundColor: hoveredIndex !== null ? 'rgba(245, 166, 35, 0.05)' : '#fff' }}>
                    {calculationString}
                </div>

                {renderVector(outputVector, outputLabel!, true)}
            </div>
            <div style={styles.controls}>
                <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
                <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
                <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
                <button onClick={reset} style={styles.button}>Reset</button>
            </div>
            <input
                type="range"
                min={-1}
                max={steps.length - 1}
                value={currentStep}
                onChange={e => setStepManually(parseInt(e.target.value))}
                style={{width: '80%', cursor: 'pointer', marginTop: '10px'}}
            />
        </div>
    );
};
// END OF FILE: src/components/visualizers/ActivationFunctionVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/ElementWiseOpVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/ElementWiseOpVisualizer.tsx
import React, { useMemo, useRef, useEffect, useState } from 'react';
import { Matrix, ElementWiseOpStep } from './types';
import { formatNumber, useAnimationController } from './utils';
import { InlineMath } from 'react-katex';

interface ElementWiseOpVisualizerProps {
    matrixA: Matrix;
    matrixB: Matrix;
    operation: '+' | '-' | '×' | '÷';
    labelA?: string;
    labelB?: string;
    labelC?: string;
}

export const ElementWiseOpVisualizer: React.FC<ElementWiseOpVisualizerProps> = ({ matrixA, matrixB, operation, labelA = 'A', labelB = 'B', labelC = 'C' }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const elementsARef = useRef<(HTMLDivElement | null)[]>([]);
    const elementsBRef = useRef<(HTMLDivElement | null)[]>([]);
    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

    const vectorA = matrixA[0];
    const vectorB = matrixB[0];

    const resultVector = useMemo(() => vectorA.map((val, c) => {
        switch (operation) {
            case '+': return val + vectorB[c];
            case '-': return val - vectorB[c];
            case '×': return val * vectorB[c];
            case '÷': return val / vectorB[c];
            default: return NaN;
        }
    }), [vectorA, vectorB, operation]);

    const numCols = vectorA.length;

    const steps: ElementWiseOpStep[] = useMemo(() => {
        const generatedSteps: ElementWiseOpStep[] = [{ type: 'start' }];
        for (let c = 0; c < numCols; c++) {
            generatedSteps.push({ type: 'highlight', row: 0, col: c });
            generatedSteps.push({ type: 'show-op', row: 0, col: c });
            generatedSteps.push({ type: 'calculate', row: 0, col: c });
        }
        generatedSteps.push({ type: 'finish' });
        return generatedSteps;
    }, [numCols]);

    const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 600);
    const currentAnimState = steps[currentStep] || { type: 'idle' };
    const animActiveCol = (currentAnimState.type === 'highlight' || currentAnimState.type === 'calculate' || currentAnimState.type === 'show-op')
        ? (currentAnimState as any).col
        : -1;
    const lastCalculatedIndex = (currentAnimState.type === 'finish')
        ? numCols - 1
        : (currentAnimState.type === 'calculate' ? (currentAnimState as any).col : animActiveCol - 1);

    const [opPosition, setOpPosition] = useState<{ top: number, left: number } | null>(null);
    const displayIndex = hoveredIndex ?? animActiveCol;

    useEffect(() => {
        if (displayIndex !== -1 && containerRef.current && elementsARef.current[displayIndex] && elementsBRef.current[displayIndex]) {
            const containerRect = containerRef.current.getBoundingClientRect();
            const elARect = elementsARef.current[displayIndex]!.getBoundingClientRect();
            const elBRect = elementsBRef.current[displayIndex]!.getBoundingClientRect();

            const top = (elARect.bottom - containerRect.top + (elBRect.top - elARect.bottom) / 2);
            const left = (elARect.left - containerRect.left + elARect.width / 2);

            setOpPosition({ top, left });
        }
    }, [displayIndex]);

    const elementWidth = '60px';

    const styles: { [key: string]: React.CSSProperties } = {
        container: { position: 'relative', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px', padding: '15px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6', width: '100%', boxSizing: 'border-box' },
        row: { display: 'flex', alignItems: 'center', gap: '15px', width: '100%' },
        label: { fontWeight: 'bold', color: '#495057', fontSize: '1.5em', width: '60px', textAlign: 'right' },
        vectorGroup: { flex: 1, minWidth: 0 },
        vectorScroll: { overflowX: 'auto', padding: '10px 5px' },
        vector: { display: 'flex', gap: '5px', width: 'max-content' },
        elementColumn: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px' },
        indexLabel: { width: elementWidth, height: '20px', display: 'flex', justifyContent: 'center', alignItems: 'center', color: '#495057', fontSize: '0.8em', fontFamily: 'monospace', boxSizing: 'border-box', backgroundColor: '#f0f2f5', border: '1px solid #dee2e6', borderRadius: '4px' },
        element: { width: elementWidth, height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', boxSizing: 'border-box', cursor: 'pointer' },
        sourceHighlight: { transform: 'scale(1.15)', borderColor: '#4a90e2', backgroundColor: 'rgba(74, 144, 226, 0.1)', fontWeight: 'bold' },
        resultHighlight: { transform: 'scale(1.15)', borderColor: '#28a745', backgroundColor: 'rgba(40, 167, 69, 0.1)', fontWeight: 'bold' },
        hoverHighlight: { borderColor: '#f5a623', backgroundColor: 'rgba(245, 166, 35, 0.1)'},
        opSymbol: { position: 'absolute', fontSize: '2em', fontWeight: 'bold', color: '#e63946', opacity: 0, transition: 'opacity 0.3s ease, transform 0.3s ease', transform: 'translate(-50%, -50%) scale(0.8)', pointerEvents: 'none' },
        opVisible: { opacity: 1, transform: 'translate(-50%, -50%) scale(1)' },
        controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '10px' },
        button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
        playingButton: { backgroundColor: '#6c757d', color: '#fff' },
        equalSignRow: { display: 'flex', alignItems: 'center', justifyContent: 'flex-start', paddingLeft: '80px', height: '30px' },
        equalSign: { fontSize: '2em', fontWeight: 'bold', color: '#6c757d' },
    };

    const renderVector = (vec: number[], label: string, isResult: boolean = false, refs?: React.MutableRefObject<(HTMLDivElement | null)[]>) => (
        <div style={styles.row}>
            <div style={styles.label}><InlineMath>{label}</InlineMath></div>
            <div style={styles.vectorGroup}>
                <div style={styles.vectorScroll}>
                    <div style={styles.vector}>
                        {vec.map((val, i) => {
                            let highlightStyle = {};
                            if (animActiveCol === i) highlightStyle = isResult ? styles.resultHighlight : styles.sourceHighlight;
                            if (hoveredIndex === i) highlightStyle = {...highlightStyle, ...styles.hoverHighlight};
                            return (
                                <div key={i} style={styles.elementColumn}>
                                    <div style={styles.indexLabel}>{i}</div>
                                    <div
                                        ref={refs ? el => { if (refs.current) refs.current[i] = el; } : undefined}
                                        style={{
                                            ...styles.element,
                                            ...highlightStyle,
                                            opacity: (isResult && i > lastCalculatedIndex && hoveredIndex === null) ? 0.3 : 1
                                        }}
                                        onMouseEnter={() => setHoveredIndex(i)}
                                        onMouseLeave={() => setHoveredIndex(null)}
                                    >
                                        {(isResult && i > lastCalculatedIndex && hoveredIndex === null) ? '?' : formatNumber(val, 2)}
                                    </div>
                                </div>
                            )
                        })}
                    </div>
                </div>
            </div>
        </div>
    );

    return (
        <div style={styles.container} ref={containerRef}>
            {renderVector(vectorA, labelA, false, elementsARef)}
            {renderVector(vectorB, labelB, false, elementsBRef)}
            {opPosition && (
                <div style={{
                    ...styles.opSymbol,
                    top: opPosition.top,
                    left: opPosition.left,
                    ...((currentAnimState.type === 'show-op' && animActiveCol === displayIndex) || hoveredIndex === animActiveCol ? styles.opVisible : {})
                }}>
                    {operation}
                </div>
            )}
            <div style={styles.equalSignRow}>
                <div style={styles.equalSign}>=</div>
            </div>
            {renderVector(resultVector, labelC, true)}

            <div style={styles.controls}>
                <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
                <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
                <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
                <button onClick={reset} style={styles.button}>Reset</button>
            </div>
            <input
                type="range"
                min={-1}
                max={steps.length - 1}
                value={currentStep}
                onChange={e => setStepManually(parseInt(e.target.value))}
                style={{width: '80%', cursor: 'pointer', marginTop: '15px'}}
            />
        </div>
    );
};
// END OF FILE: src/components/visualizers/ElementWiseOpVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/InteractiveMatMulVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/InteractiveMatMulVisualizer.tsx
import React, { useMemo, useRef, useEffect, useState } from 'react';
import { Vector, MatMulStep, SymbolInfo } from './types';
import { useAnimationController, formatNumber } from './utils';
import { InlineMath } from 'react-katex';

interface MatMulVisualizerProps {
    sourceVectorsA: { data: Vector, symbolInfo: SymbolInfo }[];
    sourceVectorB: { data: Vector, symbolInfo: SymbolInfo };
    resultSymbolInfo: SymbolInfo;
    operation?: '+' | '×';
}

export const InteractiveMatMulVisualizer: React.FC<MatMulVisualizerProps> = ({
                                                                                 sourceVectorsA,
                                                                                 sourceVectorB,
                                                                                 resultSymbolInfo,
                                                                                 operation = '×',
                                                                             }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const elementsARefs = useRef<(HTMLDivElement | null)[][]>(sourceVectorsA.map(() => []));
    const elementsBRef = useRef<(HTMLDivElement | null)[]>([]);
    const productRefs = useRef<(HTMLDivElement | null)[]>([]);

    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

    const vectorA = useMemo(() => sourceVectorsA.map(v => v.data).flat(), [sourceVectorsA]);
    const vectorB = sourceVectorB.data;

    const steps: MatMulStep[] = useMemo(() => {
        const generatedSteps: MatMulStep[] = [{ type: 'start', index: -1 }];
        let cumulativeSum = 0;
        for (let i = 0; i < vectorA.length; i++) {
            generatedSteps.push({ type: 'highlight-pair', index: i });
            generatedSteps.push({ type: 'show-op', index: i });
            const product = vectorA[i] * vectorB[i];
            generatedSteps.push({ type: 'multiply', index: i, product });
            cumulativeSum += product;
            generatedSteps.push({ type: 'accumulate', index: i, product, cumulativeSum });
        }
        generatedSteps.push({ type: 'finish', index: -1, cumulativeSum });
        return generatedSteps;
    }, [vectorA, vectorB]);

    const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 600);
    const result = useMemo(() => vectorA.reduce((sum, val, i) => sum + val * vectorB[i], 0), [vectorA, vectorB]);
    const currentAnimState: MatMulStep = steps[currentStep] || { type: 'idle', index: -1 };
    const [sumHistory, setSumHistory] = useState<number[]>([]);

    const animActiveIndex = currentAnimState.type !== 'idle' && currentAnimState.type !== 'start' && currentAnimState.type !== 'finish'
        ? currentAnimState.index
        : -1;
    const displayIndex = hoveredIndex ?? animActiveIndex;


    useEffect(() => {
        const newSumHistory: number[] = [];
        for (let i = 0; i < currentStep; i++) {
            const step = steps[i];
            if (step && step.type === 'accumulate') {
                newSumHistory.push(step.product);
            }
        }
        setSumHistory(newSumHistory);
    }, [currentStep, steps]);


    useEffect(() => {
        if (currentAnimState.type !== 'idle' && currentAnimState.index !== -1) {
            const activeIndex = currentAnimState.index;
            productRefs.current[activeIndex]?.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            elementsBRef.current[activeIndex]?.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });

            let sourceAIndex = activeIndex;
            for (let i = 0; i < elementsARefs.current.length; i++) {
                const sourceVectorLength = elementsARefs.current[i].length;
                if (sourceAIndex < sourceVectorLength) {
                    elementsARefs.current[i][sourceAIndex]?.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    break;
                }
                sourceAIndex -= sourceVectorLength;
            }
        }
    }, [currentStep, currentAnimState]);

    const elementWidth = '60px';

    const styles: { [key: string]: React.CSSProperties } = {
        container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px', padding: '15px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6', width: '100%', boxSizing: 'border-box' },
        row: { display: 'flex', alignItems: 'center', gap: '15px', width: '100%' },
        vectorGroup: { display: 'flex', flexDirection: 'column', gap: '5px', flex: 1, minWidth: 0 },
        label: { fontWeight: 'bold', color: '#6c757d', display: 'flex', alignItems: 'center', gap: '8px', height: '30px', width: '80px', justifyContent: 'flex-end' },
        vectorScroll: { overflowX: 'auto', padding: '5px' },
        vector: { display: 'flex', gap: '5px', width: 'max-content', border: '1px solid #ccc', borderRadius: '4px', padding: '5px', backgroundColor: 'white' },
        elementColumn: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px' },
        indexLabel: { width: elementWidth, height: '20px', display: 'flex', justifyContent: 'center', alignItems: 'center', color: '#495057', fontSize: '0.8em', fontFamily: 'monospace', boxSizing: 'border-box', backgroundColor: '#f0f2f5', border: '1px solid #dee2e6', borderRadius: '4px' },
        element: { width: elementWidth, height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', boxSizing: 'border-box', cursor: 'pointer' },
        highlight: { transform: 'scale(1.15)', borderColor: '#4a90e2', backgroundColor: 'rgba(74, 144, 226, 0.1)', fontWeight: 'bold', zIndex: 2 },
        highlightHover: { borderColor: '#f5a623', backgroundColor: 'rgba(245, 166, 35, 0.1)', zIndex: 3 },
        productRow: { display: 'flex', alignItems: 'center', position: 'relative', width: '100%' },
        productsContainer: { flex: 1, minWidth: 0, overflowX: 'auto', padding: '15px 5px' },
        products: { display: 'flex', gap: '10px', alignItems: 'center', width: 'max-content' },
        productTermContainer: { display: 'flex', flexDirection: 'column', gap: '4px', alignItems: 'center' },
        productTerm: { display: 'flex', justifyContent: 'center', alignItems: 'center', padding: '5px 8px', border: '1px dashed #adb5bd', borderRadius: '4px', opacity: 0, transition: 'opacity 0.3s ease', whiteSpace: 'nowrap', minWidth: '120px', position: 'relative', cursor: 'pointer' },
        productResult: { fontSize: '0.8em', color: '#28a745', fontWeight: 'bold', opacity: 0, transition: 'opacity 0.3s 0.2s ease', height: '1.2em' },
        opSymbol: { position: 'absolute', top: '-25px', left: '50%', transform: 'translateX(-50%)', fontSize: '1.5em', fontWeight: 'bold', color: '#e63946', opacity: 0, transition: 'opacity 0.2s' },
        plus: { opacity: 0, transition: 'opacity 0.3s ease', fontWeight: 'bold', fontSize: '1.2em', alignSelf: 'flex-start', paddingTop: '8px' },
        sumContainer: { display: 'flex', flexDirection: 'column', gap: '5px', marginTop: '10px', backgroundColor: 'white', padding: '10px', borderRadius: '8px', border: '1px solid #dee2e6', width: 'calc(100% - 20px)' },
        sumRow: { display: 'flex', alignItems: 'center', gap: '10px', width: '100%'},
        sumLabel: { fontSize: '1.5em', fontWeight: 'bold' },
        sumEquationScroll: { flex: 1, minWidth: 0, overflowX: 'auto', paddingBottom: '5px'},
        sumEquation: { display: 'flex', alignItems: 'center', width: 'max-content', gap: '5px', fontSize: '1.1em', color: '#333' },
        sumTerm: { padding: '2px 6px', border: '1px solid #ccc', borderRadius: '4px', transition: 'all 0.2s', cursor: 'pointer', backgroundColor: 'white' },
        sumResult: { display: 'flex', alignItems: 'center', gap: '10px', paddingLeft: '40px', fontSize: '1.1em', fontWeight: 'bold' },
        sumValue: { padding: '8px 15px', fontSize: '1.2em', fontWeight: 'bold', border: '2px solid #28a745', borderRadius: '8px', backgroundColor: 'rgba(40, 167, 69, 0.1)', color: '#155724' },
        visible: { opacity: 1 },
        controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '15px' },
        button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
        playingButton: { backgroundColor: '#6c757d', color: '#fff' },
    };

    const cumulativeSum = sumHistory.reduce((a, b) => a + b, 0);

    let currentIndex = 0;
    return (
        <div style={styles.container} ref={containerRef}>
            {sourceVectorsA.map((vec, vecIndex) => {
                const vecContent = (
                    <div style={styles.row} key={`a-vec-${vecIndex}`}>
                        <div style={styles.label}><InlineMath>{`${vec.symbolInfo.base}${vec.symbolInfo.subscript ? `_{${vec.symbolInfo.subscript}}` : ''}`}</InlineMath></div>
                        <div style={styles.vectorGroup}>
                            <div style={styles.vectorScroll}>
                                <div style={styles.vector}>
                                    {vec.data.map((val, i) => {
                                        const globalIndex = currentIndex + i;
                                        return (
                                            <div key={globalIndex} style={styles.elementColumn}>
                                                <div style={styles.indexLabel}>{globalIndex}</div>
                                                <div
                                                    ref={el => elementsARefs.current[vecIndex][i] = el}
                                                    style={{...styles.element, ...(displayIndex === globalIndex ? {...styles.highlight, ...styles.highlightHover} : {})}}
                                                    onMouseEnter={() => setHoveredIndex(globalIndex)}
                                                    onMouseLeave={() => setHoveredIndex(null)}
                                                >{formatNumber(val, 2)}</div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                        <div style={{...styles.label, visibility: vecIndex === 0 ? 'visible' : 'hidden' }}><InlineMath math="\odot" /></div>
                    </div>
                );
                currentIndex += vec.data.length;
                return vecContent;
            })}
            <div style={styles.row}>
                <div style={styles.label}><InlineMath>{`${sourceVectorB.symbolInfo.base}${sourceVectorB.symbolInfo.subscript ? `_{${sourceVectorB.symbolInfo.subscript}}` : ''}`}</InlineMath></div>
                <div style={styles.vectorGroup}>
                    <div style={styles.vectorScroll}>
                        <div style={styles.vector}>
                            {vectorB.map((val, i) => (
                                <div key={i} style={styles.elementColumn}>
                                    <div style={styles.indexLabel}>{i}</div>
                                    <div
                                        ref={el => elementsBRef.current[i] = el}
                                        style={{...styles.element, ...(displayIndex === i ? {...styles.highlight, ...styles.highlightHover} : {})}}
                                        onMouseEnter={() => setHoveredIndex(i)}
                                        onMouseLeave={() => setHoveredIndex(null)}
                                    >{formatNumber(val, 2)}</div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
                <div style={{...styles.label, visibility: 'hidden' }}><InlineMath math="\odot" /></div>
            </div>
            <div style={styles.row}>
                <div style={styles.label}><InlineMath>{`${resultSymbolInfo.base}${resultSymbolInfo.subscript ? `_{${resultSymbolInfo.subscript}}` : ''}`}</InlineMath></div>
                <div style={styles.productRow}>
                    <div style={styles.productsContainer}>
                        <div style={styles.products}>
                            {vectorA.map((_, i) => {
                                const stepIndexMultiply = steps.findIndex(s => s.type === 'multiply' && s.index === i);
                                const isVisible = currentStep >= stepIndexMultiply;
                                const productStep = steps[stepIndexMultiply] as Extract<MatMulStep, { type: 'multiply' }>;
                                return (
                                    <React.Fragment key={`prod-frag-${i}`}>
                                        <div style={styles.productTermContainer}>
                                            <div
                                                ref={el => productRefs.current[i] = el}
                                                style={{ ...styles.productTerm, ...(isVisible ? styles.visible : {}), ...(displayIndex === i ? styles.highlightHover : {}) }}
                                                onMouseEnter={() => setHoveredIndex(i)}
                                                onMouseLeave={() => setHoveredIndex(null)}
                                            >
                                                <div style={{...styles.opSymbol, ...(currentAnimState.type === 'show-op' && currentAnimState.index === i ? styles.visible : {})}}>{operation}</div>
                                                ({formatNumber(vectorA[i], 2)} {operation} {formatNumber(vectorB[i], 2)})
                                            </div>
                                            <div style={{...styles.productResult, ...(isVisible ? styles.visible : {})}}>
                                                {isVisible ? `= ${formatNumber(productStep.product, 3)}` : ''}
                                            </div>
                                        </div>
                                        {i < vectorA.length - 1 && <span style={{...styles.plus, ...(currentStep > stepIndexMultiply ? styles.visible : {})}}>+</span>}
                                    </React.Fragment>
                                );
                            })}
                        </div>
                    </div>
                </div>
                <div style={{...styles.label, visibility: 'hidden' }}><InlineMath math="\odot" /></div>
            </div>

            <div style={styles.sumContainer}>
                <div style={styles.sumRow}>
                    <div style={styles.sumLabel}><InlineMath math="\sum" /></div>
                    <div style={styles.sumEquationScroll}>
                        <div style={styles.sumEquation}>
                            {sumHistory.length > 0 ? (
                                sumHistory.map((p, i) => (
                                    <React.Fragment key={`sum-term-${i}`}>
                                    <span
                                        style={{...styles.sumTerm, ...(displayIndex === i ? styles.highlightHover : {})}}
                                        onMouseEnter={() => setHoveredIndex(i)}
                                        onMouseLeave={() => setHoveredIndex(null)}
                                    >
                                        ({formatNumber(p, 3)})
                                    </span>
                                        {i < sumHistory.length - 1 && <span>+</span>}
                                    </React.Fragment>
                                ))
                            ) : (currentStep >= 0 && <span>0</span>)}
                        </div>
                    </div>
                </div>
                {sumHistory.length > 0 && (
                    <div style={styles.sumResult}>
                        <span>=</span>
                        <div style={styles.sumValue}>
                            {currentAnimState.type === 'accumulate' ? formatNumber(currentAnimState.cumulativeSum ?? 0, 3) : currentAnimState.type === 'finish' ? formatNumber(result, 3) : (currentStep > 0 ? formatNumber(cumulativeSum, 3) : '?')}
                        </div>
                    </div>
                )}
            </div>

            <div style={styles.controls}>
                <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
                <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
                <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
                <button onClick={reset} style={styles.button}>Reset</button>
            </div>
            <input type="range" min={0} max={steps.length - 1} value={currentStep} onChange={e => setStepManually(parseInt(e.target.value))} style={{width: '90%', cursor: 'pointer', marginTop: '10px'}} />
        </div>
    );
};
// END OF FILE: src/components/visualizers/InteractiveMatMulVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/LayerNormVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/LayerNormVisualizer.tsx
import React, { useMemo, useState } from 'react';
import { Vector, LayerNormStep } from './types';
import { formatNumber, useAnimationController } from './utils';
import { InlineMath } from 'react-katex';

interface LayerNormVisualizerProps {
    inputVector: Vector;
    epsilon?: number;
    inputLabel?: string;
    outputLabel?: string;
}

export const LayerNormVisualizer: React.FC<LayerNormVisualizerProps> = ({ inputVector, epsilon = 1e-5, inputLabel = "Input", outputLabel = "Output" }) => {
    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

    const calculations = useMemo(() => {
        const mean = inputVector.reduce((a, b) => a + b, 0) / inputVector.length;
        const variance = inputVector.map(x => (x - mean) ** 2).reduce((a, b) => a + b, 0) / inputVector.length;
        const stdDev = Math.sqrt(variance + epsilon);
        const normalized = inputVector.map(x => (x - mean) / stdDev);
        return { mean, variance, stdDev, normalized };
    }, [inputVector, epsilon]);

    const steps: LayerNormStep[] = useMemo(() => {
        const generatedSteps: LayerNormStep[] = [{ type: 'start' }];
        let currentSum = 0;
        inputVector.forEach((val, i) => {
            currentSum += val;
            generatedSteps.push({ type: 'accumulate-mean', index: i, sum: currentSum });
        });
        generatedSteps.push({ type: 'calculate-mean', value: calculations.mean });

        let currentVarSum = 0;
        inputVector.forEach((val, i) => {
            const term = (val - calculations.mean) ** 2;
            currentVarSum += term;
            generatedSteps.push({ type: 'accumulate-variance', index: i, sum: currentVarSum });
        });
        generatedSteps.push({ type: 'calculate-variance', value: calculations.variance });

        inputVector.forEach((_, i) => {
            generatedSteps.push({ type: 'show-norm-formula', index: i });
            generatedSteps.push({ type: 'apply-norm', index: i });
        });
        generatedSteps.push({ type: 'finish' });
        return generatedSteps;
    }, [inputVector, calculations]);

    const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 300);
    const currentAnimState = steps[currentStep] || { type: 'idle' };

    const { meanFormula, varianceFormula, calculationString } = useMemo((): {
        meanFormula: string;
        varianceFormula: string;
        calculationString: string;
    } => {
        let newMeanFormula = '';
        let newVarianceFormula = '';
        let newCalcString = '';

        const meanStartIndex = steps.findIndex(s => s.type === 'accumulate-mean');
        const meanEndIndex = steps.findIndex(s => s.type === 'calculate-mean');
        const varianceStartIndex = steps.findIndex(s => s.type === 'accumulate-variance');
        const varianceEndIndex = steps.findIndex(s => s.type === 'calculate-variance');
        const normStartIndex = steps.findIndex(s => s.type === 'show-norm-formula');

        if (currentStep >= meanStartIndex) {
            let sumStr = '...';
            let currentSum = 0;
            if (currentStep >= meanEndIndex) {
                sumStr = inputVector.map(v => formatNumber(v, 2)).join(' + ');
                currentSum = inputVector.reduce((a,b)=>a+b, 0);
            } else if (currentAnimState.type === 'accumulate-mean') {
                const history = inputVector.slice(0, currentAnimState.index + 1);
                sumStr = history.map(v => formatNumber(v, 2)).join(' + ');
                currentSum = history.reduce((a,b)=>a+b, 0);
            }
            newMeanFormula = `μ = (${sumStr}) / ${inputVector.length} = ${formatNumber(currentSum / inputVector.length, 4)}`;
        }

        if (currentStep >= varianceStartIndex) {
            let sumStr = '...';
            let currentSum = 0;
            if(currentStep >= varianceEndIndex) {
                const history = inputVector.map(v => (v - calculations.mean) ** 2);
                sumStr = history.map(v => formatNumber(v, 2)).join(' + ');
                currentSum = history.reduce((a,b)=>a+b, 0);
            } else if (currentAnimState.type === 'accumulate-variance') {
                const history = inputVector.slice(0, currentAnimState.index + 1).map(v => (v - calculations.mean) ** 2);
                sumStr = history.map(v => formatNumber(v, 2)).join(' + ');
                currentSum = history.reduce((a,b)=>a+b, 0);
            }
            newVarianceFormula = `σ² = (${sumStr}) / ${inputVector.length} = ${formatNumber(currentSum / inputVector.length, 4)}`;
        }

        let displayIndex = -1;
        if (hoveredIndex !== null) {
            displayIndex = hoveredIndex;
        } else if (currentAnimState.type === 'show-norm-formula' || currentAnimState.type === 'apply-norm') {
            displayIndex = currentAnimState.index;
        } else if (currentStep >= normStartIndex) {
            if (currentAnimState.type === 'finish') {
                displayIndex = inputVector.length - 1;
            } else {
                for (let i = currentStep; i >= normStartIndex; i--) {
                    const step = steps[i];
                    if (step.type === 'apply-norm' || step.type === 'show-norm-formula') {
                        displayIndex = step.index;
                        break;
                    }
                }
            }
        }

        if (displayIndex !== -1) {
            const x = inputVector[displayIndex];
            const res = calculations.normalized[displayIndex];
            newCalcString = `(${formatNumber(x,2)} - ${formatNumber(calculations.mean,2)}) / √(${formatNumber(calculations.variance,2)} + ε) = ${formatNumber(res, 4)}`;
        }

        return {
            meanFormula: newMeanFormula,
            varianceFormula: newVarianceFormula,
            calculationString: newCalcString
        };

    }, [currentStep, currentAnimState, steps, calculations, inputVector, hoveredIndex]);

    const elementWidth = '60px';

    const styles: { [key: string]: React.CSSProperties } = {
        container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
        stepContainer: { width: '100%', padding: '15px', border: '1px solid #e9ecef', borderRadius: '8px', backgroundColor: '#fff', textAlign: 'center' },
        title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
        description: { margin: '0 0 15px 0', color: '#6c757d', minHeight: '40px' },
        calculationBox: { minHeight: '30px', display: 'flex', alignItems: 'center', justifyContent: 'center', backgroundColor: '#e9ecef', border: '1px solid #dee2e6', borderRadius: '8px', padding: '8px 15px', fontSize: '1em', transition: 'opacity 0.3s, background-color 0.3s', fontFamily: 'monospace', margin: '5px 0', overflowX: 'auto', whiteSpace: 'nowrap' },
        vectorSection: { display: 'flex', width: '100%', gap: '15px', alignItems: 'center' },
        label: { fontWeight: 'bold', color: '#495057', fontSize: '1.2em', width: '100px', textAlign: 'right' },
        vectorGroup: { flex: 1, minWidth: 0 },
        vectorScroll: { overflowX: 'auto', padding: '5px' },
        vector: { display: 'flex', gap: '5px', width: 'max-content' },
        elementColumn: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px' },
        indexLabel: { width: elementWidth, height: '20px', display: 'flex', justifyContent: 'center', alignItems: 'center', color: '#495057', fontSize: '0.8em', fontFamily: 'monospace', boxSizing: 'border-box', backgroundColor: '#f0f2f5', border: '1px solid #dee2e6', borderRadius: '4px' },
        element: { width: elementWidth, height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', boxSizing: 'border-box', cursor: 'pointer' },
        highlightMean: { borderColor: '#4a90e2', backgroundColor: 'rgba(74, 144, 226, 0.1)', transform: 'scale(1.1)' },
        highlightVariance: { borderColor: '#f5a623', backgroundColor: 'rgba(245, 166, 35, 0.1)', transform: 'scale(1.1)' },
        highlightNorm: { borderColor: '#28a745', backgroundColor: 'rgba(40, 167, 69, 0.1)', transform: 'scale(1.1)' },
        highlightHover: { borderColor: '#f5a623', backgroundColor: 'rgba(245, 166, 35, 0.1)'},
        connector: { fontSize: '2em', color: '#6c757d', margin: '5px 0', transition: 'opacity 0.3s ease' },
        controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '10px' },
        button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
        playingButton: { backgroundColor: '#6c757d', color: '#fff' },
    };

    const descriptions: Record<string, string> = {
        start: '初始输入向量。点击 "Play" 开始计算。',
        'accumulate-mean': '1. 计算均值(μ): 将所有元素累加求和,然后除以元素数量。',
        'calculate-mean': `1. 均值(μ)计算完成，值为 ${formatNumber(calculations.mean)}。`,
        'accumulate-variance': '2. 计算方差(σ²): 将每个元素与均值的差的平方累加,然后求平均。',
        'calculate-variance': `2. 方差(σ²)计算完成，值为 ${formatNumber(calculations.variance)}。`,
        'show-norm-formula': '3. 归一化: 使用均值和标准差对每个元素进行归一化。',
        'apply-norm': '3. 归一化: 使用均值和标准差对每个元素进行归一化。',
        finish: '计算完成！输出向量的均值接近0，方差接近1。',
        idle: '准备开始LayerNorm计算。',
    };

    const getActiveDescription = () => {
        const key = currentAnimState.type as keyof typeof descriptions;
        return descriptions[key] || descriptions['start'];
    };

    const isMeanCalculated = currentStep >= steps.findIndex(s => s.type === 'calculate-mean');
    const isVarianceCalculated = currentStep >= steps.findIndex(s => s.type === 'calculate-variance');

    const renderVector = (vec: Vector, label: string, isOutput: boolean = false) => (
        <div style={styles.vectorSection}>
            <div style={styles.label}><InlineMath>{label}</InlineMath></div>
            <div style={styles.vectorGroup}>
                <div style={styles.vectorScroll}>
                    <div style={styles.vector}>
                        {vec.map((val, i) => {
                            let highlightStyle: React.CSSProperties = {};
                            if (hoveredIndex === i) highlightStyle = styles.highlightHover;
                            else if ((currentAnimState.type === 'accumulate-mean') && currentAnimState.index === i) highlightStyle = styles.highlightMean;
                            else if ((currentAnimState.type === 'accumulate-variance') && currentAnimState.index === i) highlightStyle = styles.highlightVariance;
                            else if ((currentAnimState.type === 'apply-norm' || currentAnimState.type === 'show-norm-formula') && currentAnimState.index === i && !isOutput) highlightStyle = styles.highlightMean;
                            else if ((currentAnimState.type === 'apply-norm' || currentAnimState.type === 'show-norm-formula') && currentAnimState.index === i && isOutput) highlightStyle = styles.highlightNorm;

                            const isVisible = !isOutput || currentStep >= steps.findIndex(s => s.type === 'apply-norm' && s.index === i);

                            return (
                                <div key={i} style={styles.elementColumn}>
                                    <div style={styles.indexLabel}>{i}</div>
                                    <div
                                        style={{ ...styles.element, ...highlightStyle, opacity: (isVisible || hoveredIndex !== null) ? 1 : 0.3 }}
                                        onMouseEnter={() => setHoveredIndex(i)}
                                        onMouseLeave={() => setHoveredIndex(null)}
                                    >
                                        {(isVisible || hoveredIndex !== null) ? formatNumber(val) : '?'}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
        </div>
    );

    return (
        <div style={styles.container}>
            <div style={styles.stepContainer}>
                <h3 style={styles.title}>LayerNorm(x)</h3>
                <p style={styles.description}>{getActiveDescription()}</p>

                {renderVector(inputVector, inputLabel)}

                <div style={{...styles.connector, opacity: currentStep > 0 ? 1 : 0.2 }}>↓</div>
                <div style={{...styles.calculationBox, opacity: meanFormula ? 1 : 0.3, borderColor: isMeanCalculated ? '#28a745' : '#dee2e6', backgroundColor: (hoveredIndex !== null && calculationString) ? 'rgba(245, 166, 35, 0.05)' : '#e9ecef'}}>{meanFormula || 'μ = ?'}</div>
                <div style={{...styles.calculationBox, opacity: isMeanCalculated ? 1 : 0.3, borderColor: isVarianceCalculated ? '#28a745' : '#dee2e6', backgroundColor: (hoveredIndex !== null && calculationString) ? 'rgba(245, 166, 35, 0.05)' : '#e9ecef'}}>{varianceFormula || 'σ² = ?'}</div>
                <div style={{...styles.calculationBox, opacity: calculationString ? 1 : 0.3, backgroundColor: (hoveredIndex !== null && calculationString) ? 'rgba(245, 166, 35, 0.05)' : '#e9ecef'}}>{calculationString || '...'}</div>
                <div style={{...styles.connector, opacity: isVarianceCalculated ? 1 : 0.2 }}>↓</div>
                {renderVector(calculations.normalized, outputLabel, true)}
            </div>
            <div style={styles.controls}>
                <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
                <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
                <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
                <button onClick={reset} style={styles.button}>Reset</button>
            </div>
            <input
                type="range"
                min={-1}
                max={steps.length - 1}
                value={currentStep}
                onChange={e => setStepManually(parseInt(e.target.value))}
                style={{width: '80%', cursor: 'pointer', marginTop: '10px'}}
            />
        </div>
    );
};
// END OF FILE: src/components/visualizers/LayerNormVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/RMSNormVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/RMSNormVisualizer.tsx
import React, { useMemo } from 'react';
import { Vector, RMSNormStep } from './types';
import { formatNumber, useAnimationController } from './utils';

interface RMSNormVisualizerProps {
  inputVector: Vector;
  epsilon?: number;
}

export const RMSNormVisualizer: React.FC<RMSNormVisualizerProps> = ({ inputVector, epsilon = 1e-5 }) => {

  const calculations = useMemo(() => {
    const n = inputVector.length;
    const squared = inputVector.map(x => x*x);
    const squaredSum = squared.reduce((a, b) => a + b, 0);
    const meanSquare = squaredSum / n;
    const rms = Math.sqrt(meanSquare + epsilon);
    const normalized = inputVector.map(x => x / rms);
    return { squared, squaredSum, rms, normalized };
  }, [inputVector, epsilon]);

  const steps: RMSNormStep[] = useMemo(() => {
    const generatedSteps: RMSNormStep[] = [{ type: 'start' }];
    inputVector.forEach((_, i) => generatedSteps.push({ type: 'square', index: i }));
    generatedSteps.push({ type: 'sum-squares', value: calculations.squaredSum });
    generatedSteps.push({ type: 'calculate-rms', value: calculations.rms });
    inputVector.forEach((_, i) => generatedSteps.push({ type: 'normalize', index: i }));
    generatedSteps.push({ type: 'finish' });
    return generatedSteps;
  }, [inputVector, calculations]);

  const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 300);
  const currentAnimState = steps[currentStep] || { type: 'idle' };

  // Inline Styles
  const styles: { [key: string]: React.CSSProperties } = {
    container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    stepContainer: { width: '100%', padding: '15px', border: '1px solid #e9ecef', borderRadius: '8px', backgroundColor: '#fff', textAlign: 'center' },
    title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
    description: { margin: '0 0 15px 0', color: '#6c757d', minHeight: '40px' },
    vector: { display: 'flex', justifyContent: 'center', gap: '5px', flexWrap: 'wrap' },
    element: { minWidth: '60px', padding: '5px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease' },
    highlight: { borderColor: '#fd7e14', backgroundColor: 'rgba(253, 126, 20, 0.1)', transform: 'scale(1.1)' },
    connector: { fontSize: '2em', color: '#6c757d', margin: '5px 0', transition: 'opacity 0.3s ease' },
    scalar: { padding: '8px 15px', fontSize: '1.1em', fontWeight: 'bold', border: '1px solid #ced4da', borderRadius: '8px', backgroundColor: '#e9ecef', transition: 'all 0.3s ease' },
    controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '10px' },
    button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
    playingButton: { backgroundColor: '#6c757d', color: '#fff' },
  };

  const descriptions: Record<string, string> = {
    start: '初始输入向量。RMSNorm 是一种简化的 LayerNorm。',
    square: `首先，计算向量所有元素的平方和。`,
    'sum-squares': `平方和为 ${formatNumber(calculations.squaredSum)}`,
    'calculate-rms': `然后，计算均方根 (Root Mean Square)。公式: √ (Σ(x²) / n + ε)`,
    normalize: `最后，将每个原始元素除以 RMS 值进行归一化。公式: x / RMS(x)`,
    finish: '计算完成！(注意：这里省略了可学习的 gamma 缩放步骤)',
    idle: '准备开始RMSNorm计算。',
  };

  const getActiveDescription = () => {
    const key = currentAnimState.type as keyof typeof descriptions;
    return descriptions[key] || descriptions['start'];
  }

  const isSumCalculated = currentStep >= steps.findIndex(s => s.type === 'sum-squares');
  const isRmsCalculated = currentStep >= steps.findIndex(s => s.type === 'calculate-rms');

  const renderVector = (vec: Vector, type: 'input' | 'squared' | 'normalized') => (
    <div style={styles.vector}>
      {vec.map((val, i) => {
        let isHighlighted = false;
        let isVisible = true;

        if(type === 'input' && currentAnimState.type === 'square' && currentAnimState.index === i) isHighlighted = true;
        if(type === 'squared' && currentAnimState.type === 'square' && currentAnimState.index === i) isHighlighted = true;
        if(type === 'normalized' && currentAnimState.type === 'normalize' && currentAnimState.index === i) isHighlighted = true;

        if(type === 'squared') isVisible = currentStep >= steps.findIndex(s => s.type === 'square' && s.index === i);
        if(type === 'normalized') isVisible = currentStep >= steps.findIndex(s => s.type === 'normalize' && s.index === i);

        return (
          <div key={i} style={{ ...styles.element, ...(isHighlighted ? styles.highlight : {}), opacity: isVisible ? 1 : 0.3 }}>
            {isVisible ? formatNumber(val) : '?'}
          </div>
        )
      })}
    </div>
  );

  return (
    <div style={styles.container}>
      <div style={styles.stepContainer}>
        <h3 style={styles.title}>RMSNorm(x)</h3>
        <p style={styles.description}>{getActiveDescription()}</p>

        {renderVector(inputVector, 'input')}
        <div style={{...styles.connector, opacity: currentStep >= steps.findIndex(s => s.type === 'square') ? 1 : 0.2 }}>↓ x²</div>
        {renderVector(calculations.squared, 'squared')}

        <div style={{...styles.connector, opacity: isSumCalculated ? 1 : 0.2 }}>↓ Σ</div>
        <div style={{ ...styles.scalar, ...(currentAnimState.type === 'sum-squares' ? styles.highlight : {}), opacity: isSumCalculated ? 1 : 0.2 }}>
          Σ(x²) = {isSumCalculated ? formatNumber(calculations.squaredSum) : '?'}
        </div>

        <div style={{...styles.connector, opacity: isRmsCalculated ? 1 : 0.2 }}>↓ RMS</div>
        <div style={{ ...styles.scalar, ...(currentAnimState.type === 'calculate-rms' ? styles.highlight : {}), opacity: isRmsCalculated ? 1 : 0.2 }}>
          RMS = {isRmsCalculated ? formatNumber(calculations.rms) : '?'}
        </div>

        <div style={{...styles.connector, opacity: isRmsCalculated ? 1 : 0.2 }}>↓ Normalize</div>
        {renderVector(calculations.normalized, 'normalized')}
      </div>
      <div style={styles.controls}>
        <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
        <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
        <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
        <button onClick={reset} style={styles.button}>Reset</button>
      </div>
       <input
        type="range"
        min={-1}
        max={steps.length - 1}
        value={currentStep}
        onChange={e => setStepManually(parseInt(e.target.value))}
        style={{width: '80%', cursor: 'pointer', marginTop: '10px'}}
      />
    </div>
  );
};
// END OF FILE: src/components/visualizers/RMSNormVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/RoPEVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/RoPEVisualizer.tsx
import React, { useMemo, useState } from 'react';
import { Vector, RoPEStep } from './types';
import { formatNumber, useAnimationController } from './utils';
import { InlineMath } from 'react-katex';

interface RoPEVisualizerProps {
  inputVector: Vector;
  position: number;
}

export const RoPEVisualizer: React.FC<RoPEVisualizerProps> = ({ inputVector, position }) => {
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

  const calculations = useMemo(() => {
    const d = inputVector.length;
    const theta = 10000;
    const outputVector = [...inputVector];
    const details = [];

    for (let i = 0; i < d; i += 2) {
      const x_i = inputVector[i];
      const x_j = (i + 1 < d) ? inputVector[i + 1] : 0;

      const freq = 1 / (theta ** (i / d));
      const m_theta = position * freq;
      const cos_m_theta = Math.cos(m_theta);
      const sin_m_theta = Math.sin(m_theta);

      const y_i = x_i * cos_m_theta - x_j * sin_m_theta;
      const y_j = x_i * sin_m_theta + x_j * cos_m_theta;

      outputVector[i] = y_i;
      if (i + 1 < d) outputVector[i + 1] = y_j;

      details.push({ freq, m_theta, cos_m_theta, sin_m_theta });
    }
    return { outputVector, details };
  }, [inputVector, position]);

  const steps: RoPEStep[] = useMemo(() => {
    const generatedSteps: RoPEStep[] = [{ type: 'start' }];
    for (let i = 0; i < inputVector.length; i += 2) {
      generatedSteps.push({ type: 'process-pair', index: i });
    }
    generatedSteps.push({ type: 'finish' });
    return generatedSteps;
  }, [inputVector]);

  const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 500);
  const currentAnimState = steps[currentStep] || { type: 'idle' };

  const animActiveIndex = currentAnimState.type === 'process-pair' ? currentAnimState.index : -1;
  const lastCalculatedIndex = (currentAnimState.type === 'finish')
      ? inputVector.length - 1
      : (animActiveIndex !== -1 ? animActiveIndex + 1 : -1);

  const displayIndex = hoveredIndex !== null ? hoveredIndex : animActiveIndex;
  const detail = displayIndex !== -1 ? calculations.details[displayIndex / 2] : null;

  const styles: { [key: string]: React.CSSProperties } = {
    container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    mainArea: { display: 'flex', justifyContent: 'space-around', alignItems: 'center', width: '100%', gap: '20px', flexWrap: 'wrap' },
    vectorColumn: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px' },
    vector: { display: 'flex', flexDirection: 'column', gap: '4px' },
    elementPair: { display: 'flex', gap: '4px', border: '2px solid transparent', borderRadius: '4px', transition: 'all 0.3s' },
    element: { width: '70px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', boxSizing: 'border-box' },
    highlightAnim: { borderColor: '#4a90e2' },
    highlightHover: { borderColor: '#f5a623' },
    plotColumn: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px' },
    plotBox: { width: '200px', height: '200px', border: '1px solid #ccc', position: 'relative', backgroundColor: 'white' },
    formulaBox: { fontFamily: 'monospace', fontSize: '0.85em', lineHeight: 1.5, padding: '10px', backgroundColor: 'white', border: '1px solid #eee', borderRadius: '4px', width: '100%', boxSizing: 'border-box' },
    controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '15px' },
    button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
    playingButton: { backgroundColor: '#6c757d', color: '#fff' },
  };

  const renderPlot = () => {
    if (displayIndex === -1 || !detail) return <div style={styles.plotBox}><p style={{textAlign: 'center', color: '#aaa', fontSize: '0.8em', padding: '10px'}}>Hover over or play animation to see rotation</p></div>;

    const SIZE = 200;
    const CENTER = SIZE / 2;
    const SCALE = 40;
    const [x1, x2] = [inputVector[displayIndex], inputVector[displayIndex + 1] || 0];
    const [y1, y2] = [calculations.outputVector[displayIndex], calculations.outputVector[displayIndex + 1] || 0];

    const angle = detail.m_theta;
    const radius = Math.sqrt(x1**2 + x2**2) * SCALE;
    const startAngle = Math.atan2(x2, x1);
    const endAngle = startAngle + angle;
    const largeArcFlag = angle > Math.PI ? 1 : 0;

    const arcPath = `M ${CENTER + radius * Math.cos(startAngle)} ${CENTER - radius * Math.sin(startAngle)} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${CENTER + radius * Math.cos(endAngle)} ${CENTER - radius * Math.sin(endAngle)}`;

    return (
        <div style={styles.plotBox}>
            <svg width={SIZE} height={SIZE} viewBox={`0 0 ${SIZE} ${SIZE}`}>
                <line x1={0} y1={CENTER} x2={SIZE} y2={CENTER} stroke="#ddd" />
                <line x1={CENTER} y1={0} x2={CENTER} y2={SIZE} stroke="#ddd" />
                <path d={arcPath} fill="none" stroke="rgba(245, 166, 35, 0.5)" strokeWidth="2" strokeDasharray="3 3"/>
                <line x1={CENTER} y1={CENTER} x2={CENTER + x1 * SCALE} y2={CENTER - x2 * SCALE} stroke="#6c757d" strokeWidth="2" markerEnd="url(#arrow-gray)" />
                <line x1={CENTER} y1={CENTER} x2={CENTER + y1 * SCALE} y2={CENTER - y2 * SCALE} stroke="#e63946" strokeWidth="2.5" markerEnd="url(#arrow-red)" />
                <defs>
                    <marker id="arrow-gray" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#6c757d" /></marker>
                    <marker id="arrow-red" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#e63946" /></marker>
                </defs>
            </svg>
        </div>
    );
  };


  return (
    <div style={styles.container}>
      <h3>Rotary Positional Embedding (RoPE)</h3>
      <div style={styles.mainArea}>
        <div style={styles.vectorColumn}>
            <h4>Input Vector (pos={position})</h4>
            <div style={styles.vector}>
                {inputVector.map((val, i) => (i % 2 === 0 &&
                    <div
                        key={i} style={{...styles.elementPair, ...(displayIndex === i ? styles.highlightHover : {})}}
                        onMouseEnter={() => setHoveredIndex(i)} onMouseLeave={() => setHoveredIndex(null)}
                    >
                        <div style={styles.element}>{formatNumber(val)}</div>
                        <div style={styles.element}>{formatNumber(inputVector[i+1] || 0)}</div>
                    </div>
                ))}
            </div>
        </div>
        <div style={styles.plotColumn}>
            <h4>Rotation in 2D Plane</h4>
            {renderPlot()}
            <div style={styles.formulaBox}>
              {detail ? <>
                <div><InlineMath math={`\\theta_i = 1 / ${10000}^{(${displayIndex}/${inputVector.length})}`} /></div>
                <div>Rotation Angle: {formatNumber(detail.m_theta, 2)} rad</div>
                <div><InlineMath math={`(x'_i, x'_{i+1}) = (x_i, x_{i+1}) \\begin{pmatrix} \\cos(m\\theta) & \\sin(m\\theta) \\\\ -\\sin(m\\theta) & \\cos(m\\theta) \\end{pmatrix}`}/></div>
              </> : "Hover a pair..."}
            </div>
        </div>
        <div style={styles.vectorColumn}>
            <h4>Output Vector</h4>
            <div style={styles.vector}>
                {calculations.outputVector.map((val, i) => (i % 2 === 0 &&
                    <div
                        key={i}
                        style={{
                            ...styles.elementPair,
                            ...(animActiveIndex === i ? styles.highlightAnim : {}),
                            ...(hoveredIndex === i ? styles.highlightHover : {})
                        }}
                        onMouseEnter={() => setHoveredIndex(i)} onMouseLeave={() => setHoveredIndex(null)}
                    >
                        <div style={{...styles.element, opacity: (lastCalculatedIndex < i && hoveredIndex === null) ? 0.3 : 1 }}>
                            {(lastCalculatedIndex < i && hoveredIndex === null) ? '?' : formatNumber(val)}
                        </div>
                        <div style={{...styles.element, opacity: (lastCalculatedIndex < i+1 && hoveredIndex === null) ? 0.3 : 1 }}>
                             {(lastCalculatedIndex < i+1 && hoveredIndex === null) ? '?' : formatNumber(calculations.outputVector[i+1] || 0)}
                        </div>
                    </div>
                ))}
            </div>
        </div>
      </div>
       <div style={styles.controls}>
        <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
        <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
        <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
        <button onClick={reset} style={styles.button}>Reset</button>
      </div>
      <input
        type="range"
        min={-1}
        max={steps.length - 1}
        value={currentStep}
        onChange={e => setStepManually(parseInt(e.target.value))}
        style={{width: '90%', cursor: 'pointer', marginTop: '10px'}}
      />
    </div>
  );
};

// END OF FILE: src/components/visualizers/RoPEVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/SoftmaxVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/SoftmaxVisualizer.tsx
import React, { useMemo, useState } from 'react';
import { Vector, SoftmaxStep } from './types';
import { formatNumber, useAnimationController } from './utils';
import { InlineMath } from 'react-katex';

interface SoftmaxVisualizerProps {
    inputVector: Vector;
    inputLabel?: string;
    outputLabel?: string;
}

export const SoftmaxVisualizer: React.FC<SoftmaxVisualizerProps> = ({ inputVector, inputLabel = "Input", outputLabel = "P" }) => {
    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

    const calculations = useMemo(() => {
        const finiteInputs = inputVector.filter(isFinite);
        const maxVal = finiteInputs.length > 0 ? Math.max(...finiteInputs) : 0;
        const shifted = inputVector.map(v => v - maxVal);
        const exps = shifted.map(v => isFinite(v) ? Math.exp(v) : 0);
        const sumExps = exps.reduce((a, b) => a + b, 0);
        const result = sumExps > 0 ? exps.map(v => v / sumExps) : exps.map(()=> 1 / exps.length);
        return { maxVal, shifted, exps, sumExps, result };
    }, [inputVector]);

    const steps: SoftmaxStep[] = useMemo(() => {
        const generatedSteps: SoftmaxStep[] = [{ type: 'start' }];
        generatedSteps.push({ type: 'highlight-max', value: calculations.maxVal });
        inputVector.forEach((_, i) => generatedSteps.push({ type: 'subtract-max', index: i }));
        inputVector.forEach((_, i) => generatedSteps.push({ type: 'exponentiate', index: i }));
        generatedSteps.push({ type: 'sum-exps', value: calculations.sumExps });
        inputVector.forEach((_, i) => generatedSteps.push({ type: 'normalize', index: i }));
        generatedSteps.push({ type: 'finish' });
        return generatedSteps;
    }, [inputVector, calculations]);

    const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 300);
    const currentAnimState = steps[currentStep] || { type: 'idle' };

    const elementWidth = '60px';

    const styles: { [key: string]: React.CSSProperties } = {
        container: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
        stepContainer: { width: '100%', padding: '15px', border: '1px solid #e9ecef', borderRadius: '8px', backgroundColor: '#fff', textAlign: 'center' },
        title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
        description: { margin: '0 0 15px 0', color: '#6c757d', minHeight: '40px', fontSize: '0.9em' },
        vectorSection: { display: 'flex', width: '100%', gap: '15px', alignItems: 'center' },
        label: { fontWeight: 'bold', color: '#495057', fontSize: '1.2em', width: '100px', textAlign: 'right' },
        vectorGroup: { flex: 1, minWidth: 0 },
        vectorScroll: { overflowX: 'auto', padding: '5px' },
        vector: { display: 'flex', gap: '5px', width: 'max-content' },
        elementColumn: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px' },
        indexLabel: { width: elementWidth, height: '20px', display: 'flex', justifyContent: 'center', alignItems: 'center', color: '#495057', fontSize: '0.8em', fontFamily: 'monospace', boxSizing: 'border-box', backgroundColor: '#f0f2f5', border: '1px solid #dee2e6', borderRadius: '4px' },
        element: { width: elementWidth, height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', boxSizing: 'border-box', cursor: 'pointer' },
        highlight: { borderColor: '#4a90e2', backgroundColor: 'rgba(74, 144, 226, 0.1)', transform: 'scale(1.1)' },
        highlightHover: { borderColor: '#f5a623', backgroundColor: 'rgba(245, 166, 35, 0.1)'},
        connector: { fontSize: '1.5em', color: '#6c757d', margin: '5px 0', transition: 'opacity 0.3s ease' },
        scalar: { padding: '8px 15px', fontSize: '1.1em', fontWeight: 'bold', border: '1px solid #ced4da', borderRadius: '8px', backgroundColor: '#e9ecef', transition: 'all 0.3s ease' },
        controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '10px' },
        button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
        playingButton: { backgroundColor: '#6c757d', color: '#fff' },
    };

    const descriptions: Record<string, string> = {
        start: `初始输入向量 (Logits / ${inputLabel})。点击 "Play" 开始计算。`,
        'highlight-max': `1. 为保证数值稳定性, 计算最大值: max(${inputLabel}) = ${formatNumber(calculations.maxVal, 2)}。`,
        'subtract-max': `2. 从每个元素中减去最大值, 得到 L'。这可以防止计算指数时溢出。`,
        exponentiate: `3. 对 L' 中每个元素应用指数函数 e^x, 得到 E。`,
        'sum-exps': `4. 将 E 中所有元素相加, 得到归一化因子 ΣE = ${formatNumber(calculations.sumExps, 4)}。`,
        normalize: `5. 将 E 中每个元素除以总和 ΣE, 得到最终的概率分布 ${outputLabel}。`,
        finish: '计算完成！这是一个有效的概率分布, 所有元素之和为1。',
        idle: '准备开始Softmax计算。',
    };

    const getActiveDescription = () => {
        const key = currentAnimState.type as keyof typeof descriptions;
        return descriptions[key] || descriptions['start'];
    }

    const isShiftedVisible = (index: number) => currentStep >= steps.findIndex(s => s.type === 'subtract-max' && s.index === index);
    const isExpVisible = (index: number) => currentStep >= steps.findIndex(s => s.type === 'exponentiate' && s.index === index);
    const isSumVisible = currentStep >= steps.findIndex(s => s.type === 'sum-exps');
    const isResultVisible = (index: number) => currentStep >= steps.findIndex(s => s.type === 'normalize' && s.index === index);

    const renderVector = (vec: Vector, label: string | React.ReactNode, type: 'input' | 'shifted' | 'exp' | 'result') => (
        <div style={styles.vectorSection}>
            <div style={styles.label}>{typeof label === 'string' ? <InlineMath>{label}</InlineMath> : label}</div>
            <div style={styles.vectorGroup}>
                <div style={styles.vectorScroll}>
                    <div style={styles.vector}>
                        {vec.map((val, i) => {
                            let isHighlighted = false;
                            let isVisible = true;
                            if (hoveredIndex === i) isHighlighted = true;
                            else if (currentAnimState.type === 'subtract-max' && currentAnimState.index === i && (type === 'input' || type === 'shifted')) isHighlighted = true;
                            else if (currentAnimState.type === 'exponentiate' && currentAnimState.index === i && (type === 'shifted' || type === 'exp')) isHighlighted = true;
                            else if (currentAnimState.type === 'normalize' && currentAnimState.index === i && (type === 'exp' || type === 'result')) isHighlighted = true;

                            if (type === 'shifted') isVisible = isShiftedVisible(i);
                            if (type === 'exp') isVisible = isExpVisible(i);
                            if (type === 'result') isVisible = isResultVisible(i);

                            return (
                                <div key={`${type}-${i}`} style={styles.elementColumn}>
                                    <div style={styles.indexLabel}>{i}</div>
                                    <div
                                        style={{ ...styles.element, ...(isHighlighted ? (hoveredIndex === i ? styles.highlightHover : styles.highlight) : {}), opacity: (isVisible || hoveredIndex !== null) ? 1 : 0.3 }}
                                        onMouseEnter={() => setHoveredIndex(i)}
                                        onMouseLeave={() => setHoveredIndex(null)}
                                    >
                                        {(isVisible || hoveredIndex !== null) ? formatNumber(val, 2) : '?'}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
        </div>
    );

    return (
        <div style={styles.container}>
            <div style={styles.stepContainer}>
                <h3 style={styles.title}>Softmax(x)</h3>
                <p style={styles.description}>{getActiveDescription()}</p>

                {renderVector(inputVector, inputLabel!, 'input')}
                <div style={{...styles.connector, opacity: currentStep >= 1 ? 1 : 0.2 }}>↓ <InlineMath>{"- max(" + inputLabel + ") = -" + formatNumber(calculations.maxVal, 2)}</InlineMath></div>
                {renderVector(calculations.shifted, "L' = " + inputLabel + " - max(" + inputLabel + ")", 'shifted')}
                <div style={{...styles.connector, opacity: isShiftedVisible(inputVector.length - 1) ? 1 : 0.2 }}>↓ <InlineMath>e^x</InlineMath></div>
                {renderVector(calculations.exps, "E = e^{L'}", 'exp')}
                <div style={{...styles.connector, opacity: isExpVisible(inputVector.length - 1) ? 1 : 0.2 }}>↓ <InlineMath>\\sum</InlineMath></div>
                <div style={{...styles.scalar, ...(currentAnimState.type === 'sum-exps' ? styles.highlight : {}), opacity: isSumVisible ? 1 : 0.2 }}>
                    <InlineMath>{"\\sum E ="}</InlineMath> {isSumVisible ? formatNumber(calculations.sumExps, 4) : '?'}
                </div>
                <div style={{...styles.connector, opacity: isSumVisible ? 1 : 0.2 }}>↓ Normalize</div>
                {renderVector(calculations.result, "P = E / \\sum E", 'result')}
            </div>
            <div style={styles.controls}>
                <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
                <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
                <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
                <button onClick={reset} style={styles.button}>Reset</button>
            </div>
            <input
                type="range"
                min={-1}
                max={steps.length - 1}
                value={currentStep}
                onChange={e => setStepManually(parseInt(e.target.value))}
                style={{width: '80%', cursor: 'pointer', marginTop: '10px'}}
            />
        </div>
    );
};
// END OF FILE: src/components/visualizers/SoftmaxVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/SwiGLUVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/SwiGLUVisualizer.tsx
import React, { useRef, useMemo, useState, useEffect } from 'react';
import { Vector, SwiGLUAnimationStep } from './types';
import { formatNumber, getCurvePath, useAnimationController } from './utils';
import { InlineMath } from 'react-katex';

interface SwiGLUVisualizerProps {
  inputVector: Vector;
  gateActivation: Vector;
  dataVector: Vector;
}

export const SwiGLUVisualizer: React.FC<SwiGLUVisualizerProps> = ({ inputVector, gateActivation, dataVector }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRefs = useRef<(HTMLDivElement | null)[]>([]);
  const gateRefs = useRef<(HTMLDivElement | null)[]>([]);
  const dataRefs = useRef<(HTMLDivElement | null)[]>([]);
  const outputRefs = useRef<(HTMLDivElement | null)[]>([]);

  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

  const outputVector = useMemo(() => gateActivation.map((val, i) => val * dataVector[i]), [gateActivation, dataVector]);

  const steps: SwiGLUAnimationStep[] = useMemo(() => {
    const generatedSteps: SwiGLUAnimationStep[] = [{ type: 'start' }];
    inputVector.forEach((_, i) => {
        generatedSteps.push({ type: 'highlight-pair', index: i });
        generatedSteps.push({ type: 'calculate', index: i });
    });
    generatedSteps.push({ type: 'finish' });
    return generatedSteps;
  }, [inputVector]);

  const { currentStep, isPlaying, play, pause, reset, setStepManually } = useAnimationController(steps.length, 600);
  const currentAnimState = steps[currentStep] || { type: 'idle' };

  const animActiveIndex = (currentAnimState.type === 'highlight-pair' || currentAnimState.type === 'calculate') ? currentAnimState.index : -1;
  const lastCalculatedIndex = (currentAnimState.type === 'finish') ? inputVector.length - 1 : (currentAnimState.type === 'calculate' ? currentAnimState.index : animActiveIndex - 1);

  const styles: { [key: string]: React.CSSProperties } = {
    container: { position: 'relative', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '20px', padding: '20px', fontFamily: 'sans-serif', backgroundColor: '#f8f9fa', borderRadius: '8px', border: '1px solid #dee2e6' },
    title: { margin: '0 0 10px 0', fontSize: '1.2em', fontWeight: 'bold' },
    mainArea: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '30px', flexWrap: 'wrap', width: '100%' },
    pathContainer: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px' },
    label: { fontWeight: 'bold', color: '#6c757d', padding: '4px 8px', backgroundColor: '#e9ecef', borderRadius: '4px' },
    vector: { display: 'flex', flexDirection: 'column', gap: '5px' },
    element: { width: '60px', height: '30px', display: 'flex', justifyContent: 'center', alignItems: 'center', border: '1px solid #ced4da', borderRadius: '4px', backgroundColor: '#fff', transition: 'all 0.3s ease', boxSizing: 'border-box', cursor: 'pointer' },
    opSymbol: { fontSize: '2em', fontWeight: 'bold', alignSelf: 'center' },
    svg: { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none' },
    path: { fill: 'none', strokeWidth: '2px', stroke: '#adb5bd', strokeDasharray: '4 4', transition: 'stroke 0.3s, stroke-width 0.3s' },
    highlightPath: { stroke: '#fd7e14', strokeWidth: '3px', strokeDasharray: 'none' },
    highlightAnim: { borderColor: '#4a90e2', backgroundColor: 'rgba(74, 144, 226, 0.1)', transform: 'scale(1.1)' },
    highlightHover: { borderColor: '#f5a623', backgroundColor: 'rgba(245, 166, 35, 0.1)', transform: 'scale(1.1)' },
    controls: { display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '15px', width: '100%' },
    button: { padding: '8px 16px', fontSize: '1em', cursor: 'pointer', border: '1px solid #6c757d', borderRadius: '4px', backgroundColor: '#fff' },
    playingButton: { backgroundColor: '#6c757d', color: '#fff' },
  };

  const renderVector = (vec: Vector, refs: React.MutableRefObject<(HTMLDivElement | null)[]>, type: 'input' | 'gate' | 'data' | 'output') => (
    <div style={styles.vector}>
      {vec.map((val, i) => {
        const isAnimActive = animActiveIndex === i;
        const isHoverActive = hoveredIndex === i;
        const isSource = type === 'input' || type === 'gate' || type === 'data';
        const isOutput = type === 'output';

        let highlightStyle = {};
        if (isAnimActive && isSource) {
            highlightStyle = {...highlightStyle, ...styles.highlightAnim};
        }
        if (isAnimActive && isOutput && currentAnimState.type === 'calculate') {
             highlightStyle = {...highlightStyle, ...styles.highlightAnim};
        }
        if (isHoverActive) {
            highlightStyle = {...highlightStyle, ...styles.highlightHover};
        }

        const isVisible = isOutput ? (i <= lastCalculatedIndex && hoveredIndex === null) || hoveredIndex !== null : true;

        return (
            <div
                key={i}
                ref={el => refs.current[i] = el}
                style={{ ...styles.element, ...highlightStyle, opacity: isVisible ? 1 : 0.3 }}
                onMouseEnter={() => setHoveredIndex(i)}
                onMouseLeave={() => setHoveredIndex(null)}
            >
              {isVisible ? formatNumber(val, 2) : '?'}
            </div>
        );
      })}
    </div>
  );

  return (
    <div style={styles.container} ref={containerRef}>
      <svg style={styles.svg}>
        {inputVector.map((_, i) => {
           const isPathHighlighted = hoveredIndex === i || animActiveIndex === i;
           const pathStyle = isPathHighlighted ? {...styles.path, ...styles.highlightPath} : styles.path;
           return (
              <React.Fragment key={`path-${i}`}>
                <path d={getCurvePath(inputRefs.current[i], gateRefs.current[i], containerRef.current)} style={pathStyle} />
                <path d={getCurvePath(inputRefs.current[i], dataRefs.current[i], containerRef.current)} style={pathStyle} />
                <path d={getCurvePath(gateRefs.current[i], outputRefs.current[i], containerRef.current)} style={pathStyle} />
                <path d={getCurvePath(dataRefs.current[i], outputRefs.current[i], containerRef.current)} style={pathStyle} />
              </React.Fragment>
           );
        })}
      </svg>
      <h3 style={styles.title}><InlineMath math={"\\text{SwiGLU}(x) = \\text{SiLU}(xW) \\odot xV"} /></h3>
      <div style={styles.mainArea}>
        <div style={styles.pathContainer}>
          <div style={styles.label}>Input (x)</div>
          {renderVector(inputVector, inputRefs, 'input')}
        </div>

        <div style={styles.opSymbol}>→</div>

        <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
          <div style={styles.pathContainer}>
            <div style={styles.label}><InlineMath math={"\\text{Gate Path: SiLU}(xW)"}/></div>
            {renderVector(gateActivation, gateRefs, 'gate')}
          </div>
          <div style={styles.pathContainer}>
            <div style={styles.label}><InlineMath math={"\\text{Data Path: } xV"}/></div>
            {renderVector(dataVector, dataRefs, 'data')}
          </div>
        </div>

        <div style={styles.opSymbol}>⊙</div>

        <div style={styles.pathContainer}>
          <div style={styles.label}>Output</div>
          {renderVector(outputVector, outputRefs, 'output')}
        </div>
      </div>
       <div style={styles.controls}>
        <button onClick={() => setStepManually(currentStep - 1)} disabled={currentStep <= 0} style={styles.button}>上一步</button>
        <button onClick={isPlaying ? pause : play} style={{ ...styles.button, ...(isPlaying ? styles.playingButton : {}) }}>{isPlaying ? 'Pause' : 'Play'}</button>
        <button onClick={() => setStepManually(currentStep + 1)} disabled={currentStep >= steps.length - 1} style={styles.button}>下一步</button>
        <button onClick={reset} style={styles.button}>Reset</button>
      </div>
      <input
        type="range"
        min={-1}
        max={steps.length - 1}
        value={currentStep}
        onChange={e => setStepManually(parseInt(e.target.value))}
        style={{width: '90%', cursor: 'pointer', marginTop: '10px'}}
      />
    </div>
  );
};
// END OF FILE: src/components/visualizers/SwiGLUVisualizer.tsx



================================================================================
### 文件路径: src/components/visualizers/types.ts
================================================================================

// FILE: src/components/visualizers/types.ts

/**
 * 定义可视化组件库共享的类型
 */

export type Vector = number[];
export type Matrix = number[][];

export type AnimationStatus = 'idle' | 'running' | 'paused' | 'finished';

export type MatMulStep =
    | { type: 'start' | 'finish' | 'idle', index: -1, cumulativeSum?: number }
    | { type: 'highlight-pair' | 'show-op', index: number }
    | { type: 'multiply', index: number, product: number }
    | { type: 'accumulate', index: number, product: number, cumulativeSum: number };

export type ElementWiseOpStep =
    | { type: 'idle' | 'start' | 'finish' }
    | { type: 'highlight', row: number, col: number }
    | { type: 'show-op', row: number, col: number }
    | { type: 'calculate', row: number, col: number };

export type ActivationStep =
    | { type: 'idle' | 'start' | 'finish' }
    | { type: 'process', index: number };

export type SoftmaxStep =
    | { type: 'idle' | 'start' | 'finish' }
    | { type: 'highlight-max', value: number }
    | { type: 'subtract-max', index: number }
    | { type: 'exponentiate', index: number }
    | { type: 'sum-exps', value: number }
    | { type: 'normalize', index: number };

export type LayerNormStep =
    | { type: 'idle' | 'start' | 'finish' }
    | { type: 'highlight-for-mean', index: number }
    | { type: 'accumulate-mean', index: number, sum: number }
    | { type: 'calculate-mean', value: number }
    | { type: 'highlight-for-variance', index: number }
    | { type: 'accumulate-variance', index: number, sum: number }
    | { type: 'calculate-variance', value: number }
    | { type: 'show-norm-formula', index: number }
    | { type: 'apply-norm', index: number };

export type RMSNormStep =
    | { type: 'idle' | 'start' | 'finish' }
    | { type: 'square', index: number }
    | { type: 'sum-squares', value: number }
    | { type: 'calculate-rms', value: number }
    | { type: 'normalize', index: number };

export type SwiGLUAnimationStep =
    | { type: 'idle' | 'start' | 'finish' }
    | { type: 'highlight-pair', index: number }
    | { type: 'calculate', index: number };

export type RoPEStep =
    | { type: 'idle' | 'start' | 'finish' }
    | { type: 'process-pair', index: number };

// [MODIFIED] Combined Wx+b animation steps for a two-phase animation
export type WxPlusBStep =
    | { type: 'idle' }
    | { type: 'start-matmul' }
    | { type: 'finish-matmul', matmulResult: number }
    | { type: 'highlight-bias' }
    | { type: 'add-bias', finalResult: number }
    | { type: 'finish-add' };

export type ProcessingStep =
    | 'start'
    | 'subtract-max'
    | 'exponentiate'
    | 'sum-exps'
    | 'normalize'
    | 'calculate-mean'
    | 'calculate-variance'
    | 'apply-norm'
    | 'calculate-squared-sum'
    | 'calculate-rms'
    | 'apply-rms-norm'
    | 'done';

export type ActivationFunctionType = 'relu' | 'gelu' | 'silu';

export interface CalculationComponent {
    a: number;
    b: number;
}

export interface SymbolInfo {
    base: string;
    superscript?: string;
    subscript?: string;
}
// END OF FILE: src/components/visualizers/types.ts



================================================================================
### 文件路径: src/components/visualizers/utils.ts
================================================================================

// FILE: src/components/visualizers/utils.ts

import { useState, useEffect, useCallback, useRef } from 'react';

/**
 * 格式化数字以便显示
 * @param num 要格式化的数字
 * @param precision 小数位数，默认为3
 * @returns 格式化后的字符串
 */
export const formatNumber = (num: number, precision: number = 3): string => {
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '∞';
    const fixed = num.toFixed(precision);
    // 移除末尾多余的0和可能存在的小数点
    return parseFloat(fixed).toString();
};


/**
 * 一个用于控制分步动画的 React Hook
 * @param totalSteps 动画总步数
 * @param delay 动画每一步之间的延迟（毫秒）
 * @returns [currentStep, play, pause, reset]
 */
export const useAnimationController = (totalSteps: number, delay: number = 500) => {
    const [step, setStep] = useState<number>(-1); // -1表示未开始
    const [isPlaying, setIsPlaying] = useState<boolean>(false);
    const intervalRef = useRef<number | null>(null);

    const stopInterval = useCallback(() => {
        if (intervalRef.current !== null) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
        }
    }, []);

    useEffect(() => {
        if (isPlaying) {
            if (step >= totalSteps - 1) {
                setIsPlaying(false);
                stopInterval();
                return;
            }
            intervalRef.current = window.setInterval(() => {
                setStep(prev => {
                    if (prev >= totalSteps - 1) {
                        stopInterval();
                        setIsPlaying(false);
                        return prev;
                    }
                    return prev + 1;
                });
            }, delay);
        } else {
            stopInterval();
        }

        return () => stopInterval();
    }, [isPlaying, step, totalSteps, delay, stopInterval]);

    const play = useCallback(() => {
        if (step >= totalSteps - 1) {
            setStep(0);
        } else if (step === -1) {
            setStep(0);
        }
        setIsPlaying(true);
    }, [step, totalSteps]);

    const pause = useCallback(() => {
        setIsPlaying(false);
    }, []);

    const reset = useCallback(() => {
        setIsPlaying(false);
        setStep(-1);
    }, []);

    const setStepManually = useCallback((newStep: number) => {
        setIsPlaying(false); // Stop playback when user interacts with slider
        if (newStep >= -1 && newStep < totalSteps) {
            setStep(newStep);
        }
    }, [totalSteps]);


    return {
        currentStep: step,
        isPlaying,
        play,
        pause,
        reset,
        setStepManually
    };
};

/**
 * 计算两个 DOM 元素中心点之间的 SVG 曲线路径
 * @param startEl 起始 DOM 元素
 * @param endEl 结束 DOM 元素
 * @param containerEl 容器 DOM 元素，用于计算相对坐标
 * @returns SVG 'd' 属性字符串
 */
export const getCurvePath = (startEl: Element | null, endEl: Element | null, containerEl: Element | null): string => {
    if (!startEl || !endEl || !containerEl) return '';

    const containerRect = containerEl.getBoundingClientRect();
    const startRect = startEl.getBoundingClientRect();
    const endRect = endEl.getBoundingClientRect();

    const startX = startRect.left + startRect.width / 2 - containerRect.left;
    const startY = startRect.top + startRect.height / 2 - containerRect.top;
    const endX = endRect.left + endRect.width / 2 - containerRect.left;
    const endY = endRect.top + endRect.height / 2 - containerRect.top;

    const dx = endX - startX;
    const dy = endY - startY;

    // 控制点，用于创建曲线效果
    const cp1x = startX + dx * 0.25;
    const cp1y = startY + dy * 0.1;
    const cp2x = startX + dx * 0.75;
    const cp2y = startY + dy * 0.9;

    return `M ${startX} ${startY} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${endX},${endY}`;
};


// END OF FILE: src/components/visualizers/utils.ts



================================================================================
### 文件路径: src/components/visualizers/WxPlusBVisualizer.tsx
================================================================================

// FILE: src/components/visualizers/WxPlusBVisualizer.tsx
import React, { useMemo, useState, useEffect } from 'react';
import { Vector, SymbolInfo, WxPlusBStep, MatMulStep } from './types';
import { useAnimationController, formatNumber } from './utils';
import { InlineMath } from 'react-katex';
import { InteractiveMatMulVisualizer } from './InteractiveMatMulVisualizer';

interface WxPlusBVisualizerProps {
    sourceVectorsA: { data: Vector, symbolInfo: SymbolInfo }[];
    sourceVectorB: { data: Vector, symbolInfo: SymbolInfo };
    biasVector: { data: Vector, symbolInfo: SymbolInfo };
    resultSymbolInfo: SymbolInfo;
}

export const WxPlusBVisualizer: React.FC<WxPlusBVisualizerProps> = ({
                                                                        sourceVectorsA,
                                                                        sourceVectorB,
                                                                        biasVector,
                                                                        resultSymbolInfo,
                                                                    }) => {

    const bias = biasVector.data[0];
    const matmulResult = useMemo(() =>
            sourceVectorsA.map(v => v.data).flat().reduce((sum, val, i) => sum + val * sourceVectorB.data[i], 0),
        [sourceVectorsA, sourceVectorB]
    );
    const finalResult = matmulResult + bias;

    const [phase, setPhase] = useState<'matmul' | 'add-bias'>('matmul');

    const styles: { [key: string]: React.CSSProperties } = {
        container: { display: 'flex', flexDirection: 'column', height: '100%', boxSizing: 'border-box', overflow: 'hidden' },
        phaseContainer: { flexGrow: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' },
        phaseTitle: { fontSize: '1.2em', fontWeight: 'bold', color: '#343a40', padding: '10px 15px', borderBottom: '2px solid #e9ecef', backgroundColor: '#f8f9fa', flexShrink: 0, textAlign: 'center' },
        matmulWrapper: { flexGrow: 1, overflow: 'auto' },
        biasAddSection: { width: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', gap: '15px', flexGrow: 1, padding: '20px', boxSizing: 'border-box' },
        biasRow: { display: 'flex', alignItems: 'center', gap: '20px', fontSize: '1.5em', fontWeight: 'bold' },
        biasElement: { padding: '10px 20px', borderRadius: '8px', border: '2px solid #ced4da', backgroundColor: '#fff', fontFamily: 'monospace', transition: 'all 0.3s ease' },
        highlightSource: { borderColor: '#4a90e2', backgroundColor: 'rgba(74, 144, 226, 0.1)', transform: 'scale(1.1)' },
        highlightResult: { borderColor: '#28a745', backgroundColor: 'rgba(40, 167, 69, 0.1)', transform: 'scale(1.1)' },
    };

    // This is a simplified animation for the bias addition phase
    useEffect(() => {
        let timer: NodeJS.Timeout;
        if (phase === 'add-bias') {
            const el = document.getElementById('final-result-box');
            if (el) el.style.opacity = '0';
            timer = setTimeout(() => {
                if(el) el.style.opacity = '1';
            }, 300);
        }
        return () => clearTimeout(timer);
    }, [phase]);

    return (
        <div style={styles.container}>
            {phase === 'matmul' && (
                <div style={styles.phaseContainer}>
                    <div style={styles.phaseTitle}>Phase 1: Dot Product (W·x)</div>
                    <div style={styles.matmulWrapper}>
                        <InteractiveMatMulVisualizer
                            sourceVectorsA={sourceVectorsA}
                            sourceVectorB={sourceVectorB}
                            resultSymbolInfo={{base: 'W·x'}}
                        />
                    </div>
                    <button
                        onClick={() => setPhase('add-bias')}
                        style={{ padding: '10px', fontSize: '1em', cursor: 'pointer', border: 'none', backgroundColor: '#007bff', color: 'white', flexShrink: 0 }}
                    >
                        Continue to Phase 2: Add Bias
                    </button>
                </div>
            )}

            {phase === 'add-bias' && (
                <div style={styles.phaseContainer}>
                    <div style={styles.phaseTitle}>Phase 2: Add Bias (+b)</div>
                    <div style={styles.biasAddSection}>
                        <div style={styles.biasRow}>
                            <div style={{...styles.biasElement, ...styles.highlightSource}}>
                                {formatNumber(matmulResult, 4)}
                            </div>
                            <span>+</span>
                            <div style={{...styles.biasElement, ...styles.highlightSource}}>
                                {formatNumber(bias, 4)}
                            </div>
                            <span>=</span>
                            <div id="final-result-box" style={{...styles.biasElement, ...styles.highlightResult, opacity: 0, transition: 'opacity 0.5s ease'}}>
                                {formatNumber(finalResult, 4)}
                            </div>
                        </div>
                    </div>
                    <button
                        onClick={() => setPhase('matmul')}
                        style={{ padding: '10px', fontSize: '1em', cursor: 'pointer', border: 'none', backgroundColor: '#6c757d', color: 'white', flexShrink: 0 }}
                    >
                        Back to Phase 1: Dot Product
                    </button>
                </div>
            )}
        </div>
    );
};
// END OF FILE: src/components/visualizers/WxPlusBVisualizer.tsx



================================================================================
### 文件路径: src/hooks/useDraggableAndResizable.tsx
================================================================================

// FILE: src/hooks/useDraggableAndResizable.ts
import { useState, useCallback, useRef, MouseEvent, useEffect } from 'react';

type DragType = 'move' | 'resize-t' | 'resize-r' | 'resize-b' | 'resize-l' | 'resize-br';

interface DragState {
  type: DragType;
  startX: number;
  startY: number;
  startWidth: number;
  startHeight: number;
  startLeft: number;
  startTop: number;
}

export const useDraggableAndResizable = (initialState: {
  width: number;
  height: number | 'auto';
  x: number;
  y: number;
}, contentRef: React.RefObject<HTMLDivElement>) => {
  const [size, setSize] = useState<{width: number, height: number | 'auto'}>({ width: initialState.width, height: initialState.height });
  const [position, setPosition] = useState({ x: initialState.x, y: initialState.y });
  const observerRef = useRef<ResizeObserver | null>(null);

  const dragState = useRef<DragState | null>(null);

  // --- [NEW] Effect to clamp initial position and size to be within the viewport ---
  useEffect(() => {
    const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));

    let initialWidth = initialState.width;
    let initialHeight = typeof initialState.height === 'number' ? initialState.height : 500; // Use a default for 'auto'

    let clampedWidth = clamp(initialWidth, 200, window.innerWidth);
    let clampedHeight = clamp(initialHeight, 100, window.innerHeight);

    let clampedX = clamp(initialState.x, 0, window.innerWidth - clampedWidth);
    let clampedY = clamp(initialState.y, 0, window.innerHeight - clampedHeight);

    // If the window is smaller than the component, adjust position to 0
    if (clampedWidth >= window.innerWidth) clampedX = 0;
    if (clampedHeight >= window.innerHeight) clampedY = 0;

    setSize({ width: clampedWidth, height: initialState.height === 'auto' ? 'auto' : clampedHeight });
    setPosition({ x: clampedX, y: clampedY });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Run only once on mount


  const disconnectObserver = useCallback(() => {
    if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
    }
  }, []);

  useEffect(() => {
    if (size.height === 'auto' && contentRef.current) {
        disconnectObserver();
        observerRef.current = new ResizeObserver(entries => {
            const entry = entries[0];
            if (entry) {
                const contentHeight = entry.contentRect.height;
                // Add panel header/padding height to content height
                const totalHeight = contentHeight + 80; // Approximate extra height
                setSize(s => ({...s, height: Math.min(totalHeight, window.innerHeight - 40)}));
            }
        });
        observerRef.current.observe(contentRef.current);
    }
    return () => disconnectObserver();
  }, [contentRef, size.height, disconnectObserver]);


  const handleMouseDown = useCallback((e: MouseEvent<HTMLDivElement>, type: DragType) => {
    e.preventDefault();
    e.stopPropagation();

    if (!contentRef.current) return;

    const currentHeight = typeof size.height === 'number' ? size.height : contentRef.current.offsetHeight;
    if (size.height === 'auto') {
        setSize(s => ({...s, height: currentHeight}));
    }

    dragState.current = {
      type,
      startX: e.clientX,
      startY: e.clientY,
      startWidth: contentRef.current.offsetWidth,
      startHeight: currentHeight,
      startLeft: position.x,
      startTop: position.y,
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [size, position, contentRef]);

  const handleMouseMove = useCallback((e: globalThis.MouseEvent) => {
    if (!dragState.current) return;
    e.preventDefault();
    e.stopPropagation();

    const dx = e.clientX - dragState.current.startX;
    const dy = e.clientY - dragState.current.startY;
    const { type, startWidth, startHeight, startLeft, startTop } = dragState.current;

    let newWidth = startWidth;
    let newHeight = startHeight;
    let newX = startLeft;
    let newY = startTop;

    if (type === 'move') {
      newX = startLeft + dx;
      newY = startTop + dy;
    } else {
        if (type.includes('r')) newWidth = startWidth + dx;
        if (type.includes('l')) {
            newWidth = startWidth - dx;
            newX = startLeft + dx;
        }
        if (type.includes('b')) newHeight = startHeight + dy;
        if (type.includes('t')) {
            newHeight = startHeight - dy;
            newY = startTop + dy;
        }
    }

    // --- [MODIFIED] Add boundary constraints ---
    const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));

    // Minimum dimensions
    newWidth = Math.max(200, newWidth);
    newHeight = Math.max(100, newHeight);

    // Clamp size to viewport
    newWidth = Math.min(newWidth, window.innerWidth);
    newHeight = Math.min(newHeight, window.innerHeight);

    // Clamp position to viewport
    newX = clamp(newX, 0, window.innerWidth - newWidth);
    newY = clamp(newY, 0, window.innerHeight - newHeight);
    // --- End of boundary constraints ---

    setSize({ width: newWidth, height: newHeight });
    setPosition({ x: newX, y: newY });

  }, []);

  const handleMouseUp = useCallback(() => {
    dragState.current = null;
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  }, [handleMouseMove]);

  return {
    size,
    position,
    dragHandleProps: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'move') },
    resizeHandleProps: {
        br: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-br') },
        r: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-r') },
        b: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-b') },
        l: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-l') },
        t: { onMouseDown: (e: MouseEvent<HTMLDivElement>) => handleMouseDown(e, 'resize-t') },
    },
  };
};
// END OF FILE: src/hooks/useDraggableAndResizable.tsx



================================================================================
### 文件路径: src/hooks/useSplitPane.ts
================================================================================

// FILE: src/hooks/useSplitPane.ts
import { useState, useCallback, useRef, MouseEvent } from 'react';

export const useSplitPane = (initialPrimarySize: number, minPrimarySize: number = 200, minSecondarySize: number = 200) => {
    const [primarySize, setPrimarySize] = useState(initialPrimarySize);
    const separatorRef = useRef<HTMLDivElement>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    const handleMouseDown = useCallback((e: MouseEvent<HTMLDivElement>) => {
        e.preventDefault();

        const startX = e.clientX;
        const startSize = primarySize;

        const handleMouseMove = (moveEvent: globalThis.MouseEvent) => {
            if (!containerRef.current) return;
            const dx = moveEvent.clientX - startX;
            const containerWidth = containerRef.current.offsetWidth;

            let newPrimarySize = startSize + dx;

            // Enforce min sizes
            if (newPrimarySize < minPrimarySize) {
                newPrimarySize = minPrimarySize;
            }
            if (containerWidth - newPrimarySize < minSecondarySize) {
                newPrimarySize = containerWidth - minSecondarySize;
            }

            setPrimarySize(newPrimarySize);
        };

        const handleMouseUp = () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    }, [primarySize, minPrimarySize, minSecondarySize]);

    return {
        primarySize,
        separatorProps: {
            ref: separatorRef,
            onMouseDown: handleMouseDown,
        },
        containerProps: {
            ref: containerRef,
        },
    };
};

// END OF FILE: src/hooks/useSplitPane.ts



================================================================================
### 文件路径: src/index.css
================================================================================





================================================================================
### 文件路径: src/index.tsx
================================================================================

// FILE: src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Add this empty export statement to treat this file as a module.
export {};
// END OF FILE: src/index.tsx



================================================================================
### 文件路径: src/pages/HomePage/HomePage.css
================================================================================

/* FILE: src/pages/HomePage/HomePage.css */
.homepage-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 40px 20px;
}

.homepage-intro {
    text-align: center;
    margin-bottom: 50px;
}

.homepage-intro h2 {
    font-size: 2.8em;
    color: #303133;
    font-weight: 700;
}

.homepage-intro p {
    font-size: 1.25em;
    color: #606266;
    max-width: 700px;
    margin: 10px auto 0;
}

.topic-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 30px;
}

.topic-card-link {
    text-decoration: none;
    color: inherit;
    display: flex; /* Ensure link takes up full grid cell height */
}

/* --- [REWRITTEN] New Topic Card Styles --- */
.topic-card {
  position: relative;
  color: #2e2e2f;
  background-color: #fff;
  padding: 1.5rem;
  border-radius: 12px;
  box-shadow: rgba(99, 99, 99, 0.1) 0px 2px 8px 0px;
  border: 2px solid transparent;
  transition: all 0.3s ease-in-out;
  display: flex;
  flex-direction: column;
  width: 100%;
}

.topic-card:hover {
  box-shadow: rgba(99, 99, 99, 0.2) 0px 4px 12px 0px;
  transform: translateY(-5px);
  border-color: rgba(64, 158, 255, 0.3);
}

.topic-card-header {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.topic-card-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.topic-card-tag {
    border-radius: 100px;
    padding: 5px 12px;
    font-size: 12px;
    font-weight: 500;
    color: #ffffff;
}

/* Define a few colors for tags */
.topic-card-tag.color-1 { background-color: #409EFF; }
.topic-card-tag.color-2 { background-color: #67C23A; }
.topic-card-tag.color-3 { background-color: #E6A23C; }
.topic-card-tag.color-4 { background-color: #F56C6C; }
.topic-card-tag.color-5 { background-color: #909399; }

.topic-card-content {
    flex-grow: 1;
}

.topic-card-title {
    font-size: 1.6em;
    margin: 0 0 0.8rem 0;
    color: #303133;
    font-weight: 600;
}

.topic-card-description {
    font-size: 1em;
    line-height: 1.6;
    color: #606266;
    margin: 0;
}

.topic-card-footer {
  position: relative;
  width: 100%;
  color: #9fa4aa;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: flex-start; /* Align date to the left */
  margin-top: 1.5rem;
  padding-top: 1rem;
  border-top: 1px solid #f0f2f5;
}

.topic-card-date {
  display: flex;
  align-items: center;
  cursor: pointer;
}

.topic-card-date svg {
  margin-right: 8px;
  height: 20px;
  width: 20px;
  stroke: #9fa4aa;
}

/*// END OF FILE: src/pages/HomePage/HomePage.css*/



================================================================================
### 文件路径: src/pages/HomePage/HomePage.tsx
================================================================================

// FILE: src/pages/HomePage/HomePage.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { topics, Topic } from '../../topics';
import './HomePage.css';

const TAG_COLORS = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5'];

const TopicCard: React.FC<{ topic: Topic }> = ({ topic }) => {
    return (
        <Link to={`/topic/${topic.id}`} className="topic-card-link">
            <div className="topic-card">
                <div className="topic-card-header">
                    <div className="topic-card-tags">
                        {topic.tags.map((tag, index) => (
                            <span key={tag} className={`topic-card-tag ${TAG_COLORS[index % TAG_COLORS.length]}`}>{tag}</span>
                        ))}
                    </div>
                </div>
                <div className="topic-card-content">
                    <h3 className="topic-card-title">{topic.title}</h3>
                    <p className="topic-card-description">{topic.description}</p>
                </div>
                <div className="topic-card-footer">
                    <div className="topic-card-date">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <g strokeWidth="0" id="SVGRepo_bgCarrier"></g>
                            <g strokeLinejoin="round" strokeLinecap="round" id="SVGRepo_tracerCarrier"></g>
                            <g id="SVGRepo_iconCarrier">
                                <path strokeLinecap="round" strokeWidth="2" d="M12 8V12L15 15"></path>
                                <circle strokeWidth="2" r="9" cy="12" cx="12"></circle>
                            </g>
                        </svg>
                        {topic.date}
                    </div>
                </div>
            </div>
        </Link>
    );
};


export const HomePage: React.FC = () => {
    return (
        <div className="page-scroll-container">
            <div className="homepage-container">
                <div className="homepage-intro">
                    <h2>欢迎来到 AI 深度探索</h2>
                    <p>一个旨在通过交互式可视化和深度文章，剖析前沿AI技术的知识平台。</p>
                </div>
                <div className="topic-grid">
                    {topics.map(topic => (
                        <TopicCard key={topic.id} topic={topic} />
                    ))}
                </div>
            </div>
        </div>
    );
};

// END OF FILE: src/pages/HomePage/HomePage.tsx



================================================================================
### 文件路径: src/pages/TopicPage/components/TopicSidebar.css
================================================================================

/* FILE: src/pages/TopicPage/components/TopicSidebar.css */
.topic-sidebar {
    width: 280px;
    flex-shrink: 0;
    background-color: var(--component-bg);
    border-right: 1px solid var(--border-color);
    padding: 20px;
    overflow-y: auto;
    height: 100%;
    box-sizing: border-box;
    /* [NEW] Add transition for smooth slide-in/out */
    transition: margin-left 0.3s ease-in-out;
    /* [NEW] Sidebar is hidden by default by being pushed off-screen */
    margin-left: -280px;
    /* [NEW] Ensure sidebar is on top of content but below the toggle button */
    z-index: 1001;
}

.sidebar-title {
    font-size: 1.2em;
    font-weight: 600;
    color: var(--text-color);
    padding-bottom: 10px;
    margin: 0 0 15px 0;
    border-bottom: 2px solid var(--highlight-color);
}

.sidebar-topic-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.sidebar-topic-item {
    margin-bottom: 5px;
}

.sidebar-topic-link {
    display: block;
    padding: 12px 15px;
    text-decoration: none;
    color: #606266;
    border-radius: 6px;
    font-size: 0.95em;
    font-weight: 500;
    transition: background-color 0.2s ease, color 0.2s ease;
    border: 1px solid transparent;
}

.sidebar-topic-link:hover {
    background-color: var(--highlight-bg);
    color: var(--highlight-color);
}

.sidebar-topic-link.active {
    background-color: var(--highlight-bg);
    color: var(--highlight-color);
    font-weight: 700;
    border-color: var(--highlight-color);
}

/* END OF FILE: src/pages/TopicPage/components/TopicSidebar.css */



================================================================================
### 文件路径: src/pages/TopicPage/components/TopicSidebar.tsx
================================================================================

// FILE: src/pages/TopicPage/components/TopicSidebar.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import { Topic, topics } from '../../../topics';
import './TopicSidebar.css';

export const TopicSidebar: React.FC = () => {
    return (
        <aside className="topic-sidebar">
            <h3 className="sidebar-title">所有专题</h3>
            <ul className="sidebar-topic-list">
                {topics.map((topic: Topic) => (
                    <li key={topic.id} className="sidebar-topic-item">
                        <NavLink
                            to={`/topic/${topic.id}`}
                            className={({ isActive }) =>
                                `sidebar-topic-link ${isActive ? 'active' : ''}`
                            }
                        >
                            {topic.title}
                        </NavLink>
                    </li>
                ))}
            </ul>
        </aside>
    );
};

// END OF FILE: src/pages/TopicPage/components/TopicSidebar.tsx



================================================================================
### 文件路径: src/pages/TopicPage/TopicPage.css
================================================================================

/* FILE: src/pages/TopicPage/TopicPage.css */
.topic-page-layout {
    display: flex;
    height: 100%;
    overflow: hidden; /* Important: this container does not scroll */
    /* [NEW] Add position relative for the absolute positioned toggle button */
    position: relative;
}

/* [NEW] When the sidebar is visible, adjust its margin */
.topic-page-layout.sidebar-visible .topic-sidebar {
    margin-left: 0;
}

/* [NEW] Styles for the sidebar toggle button */
.sidebar-toggle-button {
    position: absolute;
    top: 15px;
    left: 15px;
    z-index: 1002; /* Must be higher than the sidebar's z-index */
    width: 44px;
    height: 44px;
    background-color: var(--component-bg);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    color: var(--text-color);
    transition: left 0.3s ease-in-out, transform 0.2s ease, box-shadow 0.2s ease;
}

.sidebar-toggle-button:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
    color: var(--highlight-color);
}

/* [NEW] Move the button along with the sidebar when it's visible */
.topic-page-layout.sidebar-visible .sidebar-toggle-button {
    left: calc(280px + 15px);
}


.topic-content-area {
    flex-grow: 1;
    height: 100%;
    min-width: 0; /* Crucial for flexbox children overflow */
    display: flex;
    flex-direction: column; /* Allows child components to manage their own layout */
}

/* This is the wrapper for the actual topic component, e.g., TransformerExplorer or an article */
.topic-component-wrapper {
    flex-grow: 1;
    overflow-y: auto; /* Standard articles will scroll here */
    min-height: 0;
}

/* Specific override for components like TransformerExplorer that manage their own scrolling */
.topic-component-wrapper.no-scroll {
    overflow-y: hidden;
}

/* END OF FILE: src/pages/TopicPage/TopicPage.css */



================================================================================
### 文件路径: src/pages/TopicPage/TopicPage.tsx
================================================================================

// FILE: src/pages/TopicPage/TopicPage.tsx
import React, { useState } from 'react';
import { useParams } from 'react-router-dom';
import { topics } from '../../topics';
import { TopicSidebar } from './components/TopicSidebar';
import './TopicPage.css';

// [NEW] SVG Icon for the toggle button
const MenuIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
    </svg>
);


export const TopicPage: React.FC = () => {
    const { topicId } = useParams<{ topicId: string }>();
    const topic = topics.find(t => t.id === topicId);
    // [NEW] State to manage sidebar visibility, default to hidden
    const [isSidebarVisible, setIsSidebarVisible] = useState(false);

    if (!topic) {
        return <div style={{textAlign: 'center', padding: '40px'}}>专题 '{topicId}' 未找到！</div>;
    }

    const TopicComponent = topic.component;

    // Some topics like the explorers have their own internal scrolling mechanisms
    // and should not be wrapped in a scrolling container.
    const hasCustomLayout = ['transformer-explorer', 'attention-variants'].includes(topic.id);

    return (
        // [MODIFIED] Add class based on state and a toggle button
        <div className={`topic-page-layout ${isSidebarVisible ? 'sidebar-visible' : ''}`}>
            <button
                className="sidebar-toggle-button"
                onClick={() => setIsSidebarVisible(!isSidebarVisible)}
                title={isSidebarVisible ? '隐藏专题列表' : '显示专题列表'}
            >
                <MenuIcon />
            </button>
            <TopicSidebar />
            <div className="topic-content-area">
                <div className={`topic-component-wrapper ${hasCustomLayout ? 'no-scroll' : ''}`}>
                    <TopicComponent />
                </div>
            </div>
        </div>
    );
};

// END OF FILE: src/pages/TopicPage/TopicPage.tsx



================================================================================
### 文件路径: src/react-app-env.d.ts
================================================================================





================================================================================
### 文件路径: src/topics/attention-variants/AttentionVariantsTopic.css
================================================================================

/* FILE: src/topics/attention-variants/AttentionVariantsTopic.css */
/* This file contains all necessary styles for the attention-variants topic,
   ensuring it is fully self-contained. Many styles are adapted from the
   transformer-explorer topic to maintain visual consistency. */

.main-layout {
    display: flex;
    height: 100%;
    overflow: hidden;
    position: relative;
}

.column {
    height: 100%;
    overflow-y: auto;
    box-sizing: border-box;
}
.column-content {
    padding: 20px;
}
.column.left-column {
    border-right: 1px solid var(--border-color);
}
.column h2 {
    text-align: center;
    margin-top: 0;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
    position: sticky;
    top: -21px; /* Slight overlap to hide scrollbar space */
    background-color: var(--bg-color);
    z-index: 10;
}

.attention-variant-section {
    border: 3px solid var(--border-color);
    border-radius: 12px;
    margin-bottom: 25px;
    background-color: #fdfdfd;
    transition: all 0.3s ease;
    overflow: hidden;
}

.attention-variant-section.active-component {
    border-color: var(--highlight-formula-border);
    box-shadow: 0 0 20px var(--highlight-formula-bg);
}


.attention-variant-section .component-header {
    background-color: var(--component-header-bg);
    padding: 12px 20px;
    font-weight: bold;
    font-size: 1.3em;
    border-bottom: 1px solid var(--border-color);
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.attention-variant-section .component-header:hover {
    background-color: #e9ecef;
}

.attention-variant-section .component-body {
    padding: 20px;
    display: flex;
    flex-direction: column;
    /* [CORE FIX] REMOVED 'align-items: center;' which was the root cause of the bug. */
    gap: 20px;
}

.explanation-subsection {
    width: 100%;
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #f0f2f5;
    border-radius: 8px;
    background: #fcfcfc;
}
.explanation-subsection h5 {
    margin-top: 0;
    font-size: 1.2em;
    color: #303133;
    border-bottom: 2px solid #e4e7ed;
    padding-bottom: 8px;
}
.explanation-subsection p, .explanation-subsection li {
    line-height: 1.7;
    color: #606266;
}
.explanation-subsection code {
    background-color: #e9ecef;
    padding: 2px 5px;
    border-radius: 4px;
    font-family: monospace;
}
.explanation-subsection ul {
    padding-left: 20px;
}


.attention-calculation-step {
    width: 100%;
    border: 1px solid #eef;
    border-radius: 8px;
    padding: 15px;
    background-color: rgba(0,0,0,0.015);
    display: flex;
    flex-direction: column;
    /* [FIXED] REMOVED 'align-items: center;' which caused wide children to be clipped on the left. */
    /* Child elements like titles are now centered using their own properties (e.g., text-align). */
    gap: 10px;
}

/* [MODIFIED] Changed text-align to left for paragraph text */
.attention-calculation-step > p {
    text-align: left;
}


.step-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #303133;
    font-size: 1.1em;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px dashed var(--border-color);
}

/* [MODIFIED] viz-formula-group is now the scrolling container */
.viz-formula-group {
    width: 100%;
    overflow-x: auto;
    padding: 15px 10px;
    border: 1px solid #eef;
    border-radius: 8px;
    background-color: rgba(0,0,0,0.015);
    box-sizing: border-box;
    margin-bottom: 10px;
}

/* [MODIFIED] viz-formula-row must now be max-content width to trigger the scrollbar */
.viz-formula-row {
    display: flex;
    align-items: center;
    gap: 15px;
    width: max-content; /* This is the key change */
    padding: 0 10px 0 10px; /* Add some padding for scroll boundaries */
    min-width: 100%; /* Ensure it at least fills the container if content is small */
    box-sizing: border-box;
}
.viz-formula-row.vertical {
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%; /* Vertical rows don't need max-content */
}

.viz-formula-row > * {
    flex-shrink: 0;
}

/* [REWORKED] The matrix wrapper is now a simple container. */
.matrix-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
}

/* Default: side label is hidden, bottom label is shown */
.matrix-wrapper .matrix-label-side { display: none; }
.matrix-wrapper .matrix-label-container {
    display: flex;
    justify-content: center;
    margin-top: 8px;
}

/* When `side-label` class is added, switch visibility */
.matrix-wrapper.side-label {
    flex-direction: row;
    align-items: center;
    gap: 12px;
}
.matrix-wrapper.side-label .matrix-label-side { display: flex; flex-shrink: 0; }
.matrix-wrapper.side-label .matrix-label-container { display: none; }

/* When `label-bottom` class is added, force bottom label (overrides side-label) */
.matrix-wrapper.label-bottom {
    flex-direction: column;
    align-items: center;
}
.matrix-wrapper.label-bottom .matrix-label-side { display: none; }
.matrix-wrapper.label-bottom .matrix-label-container { display: flex; }


.head-group-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border: 2px dashed;
    border-radius: 8px;
    margin-top: 10px;
}

.q-heads-grid {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
}

.kv-head-pair {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.summary-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
    table-layout: fixed;
    overflow: hidden;
    border: 1px solid var(--border-color);
}
.summary-table th,
.summary-table td {
    border: 1px solid var(--border-color);
    padding: 12px 15px;
    position: relative;
    overflow: hidden;
    resize: both;
    min-width: 100px;
}
.summary-table th {
    background-color: var(--component-header-bg);
    font-weight: bold;
    text-align: center;
}
.summary-table td {
    vertical-align: top;
}
.summary-table th::after,
.summary-table td::after {
    content: '';
    position: absolute;
    bottom: 0;
    right: 0;
    width: 10px;
    height: 10px;
    background:
            linear-gradient(to top left,
            transparent 45%,
            #ccc 45%,
            #ccc 55%,
            transparent 55%
            );
    cursor: nwse-resize;
    opacity: 0.5;
    transition: opacity 0.2s;
}
.summary-table th:hover::after,
.summary-table td:hover::after {
    opacity: 1;
}


/* --- [NEW STYLES] Ported from transformer-explorer for consistency --- */

/* This container adds the border and background to the matrix grid */
.matrix-container {
    display: inline-block;
    border: 1px solid #ccc;
    padding: 5px;
    border-radius: 4px;
    background-color: #f9f9f9;
}
.matrix-grid {
    display: grid;
    gap: 3px;
}
.symbolic-matrix-grid {
    display: grid;
    gap: 2px;
}

/* Shared matrix element style */
.matrix-element {
    width: 45px;
    height: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    font-family: monospace;
    font-size: 0.8em;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    position: relative;
    z-index: 2;
    font-weight: normal;
}
.matrix-ellipsis {
    width: 45px;
    height: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #aaa;
    font-size: 1.2em;
    font-family: monospace;
}

.matrix-element:hover {
    transform: scale(1.1);
    border-color: #007bff;
    box-shadow: 0 0 5px rgba(0,123,255,0.5);
    z-index: 5;
}

.matrix-element.source {
    background-color: var(--highlight-source-bg);
    color: var(--highlight-source-color);
    border: 1.5px solid var(--highlight-source-border);
}
.matrix-element.target {
    background-color: var(--highlight-target-bg);
    color: var(--highlight-target-color);
    border: 1.5px solid var(--highlight-target-border);
}
.matrix-element.prob-max {
    box-shadow: 0 0 8px 2px var(--highlight-target-border);
    font-weight: bold;
    transform: scale(1.15);
    z-index: 6;
}

/* Shared symbolic element style */
.symbolic-element, .symbolic-ellipsis {
    min-width: 60px;
    min-height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9em;
    border-radius: 2px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    transition: all 0.2s ease-in-out;
}
.symbolic-ellipsis {
    border-style: dashed;
    color: #aaa;
}
.symbolic-element.source {
    background-color: var(--highlight-source-bg);
    border-color: var(--highlight-source-border);
}
.symbolic-element.target {
    background-color: var(--highlight-target-bg);
    border-color: var(--highlight-target-border);
}

/* Matrix label styles */
.matrix-label-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}
.matrix-label {
    text-align: center;
    font-weight: bold;
    font-family: monospace;
    font-size: 1.1em;
    margin: 0;
}
.matrix-symbol-tag {
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    font-size: 1.1em;
    border: 1px solid #ced4da;
    line-height: 1;
    font-family: 'Times New Roman', serif;
}
.matrix-label-side .matrix-symbol-tag {
    font-size: 1.2em; /* Make side labels slightly larger */
}

/* Header item styles */
.matrix-header-item, .symbolic-header-item {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5;
    color: #909399;
    font-family: monospace;
    font-size: 0.8em;
    font-weight: bold;
    border-radius: 2px;
    padding: 2px;
    box-sizing: border-box;
    min-height: 15px;
}
.symbolic-header-item {
    background-color: transparent;
}
/* END OF FILE: src/topics/attention-variants/AttentionVariantsTopic.css */



================================================================================
### 文件路径: src/topics/attention-variants/AttentionVariantsTopic.tsx
================================================================================

// FILE: src/topics/attention-variants/AttentionVariantsTopic.tsx
import React, { useState, useCallback, useEffect, useRef } from 'react';
import './AttentionVariantsTopic.css';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { CalculationTooltip } from '../../components/CalculationTooltip/CalculationTooltip';
import { AnimationPanel } from './components/AnimationPanel';
import { TooltipState } from '../../components/CalculationTooltip/types';
import { useAttention } from './hooks/useAttention';
import { useSplitPane } from '../../hooks/useSplitPane';
import { HighlightState, ElementIdentifier, AttentionData } from './types';
import { generateTooltipData, createBackwardHighlight } from './lib/tracing';
import { ViewToggle, ViewMode } from '../../components/ViewToggle/ViewToggle';

export const AttentionVariantsTopic: React.FC = () => {
    const [dims, setDims] = useState({
        seq_len: 4,
        d_model: 16,
        n_q_heads: 4,
        n_kv_heads: 2,
        d_head: 4,
        d_c: 8, // MLA latent dim for KV
        d_c_prime: 12, // MLA latent dim for Q
        d_rope: 2 // MLA rope dim
    });

    const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [] });
    const [tooltip, setTooltip] = useState<TooltipState | null>(null);
    const [animationData, setAnimationData] = useState<TooltipState | null>(null);
    const [viewMode, setViewMode] = useState<ViewMode>('none');
    const [activeElement, setActiveElement] = useState<ElementIdentifier | null>(null);
    const [activeComponent, setActiveComponent] = useState<string | null>(null);

    const vizRefs = useRef<{[key: string]: HTMLDivElement | null}>({});
    const explanationRefs = useRef<{[key: string]: HTMLDivElement | null}>({});

    const { primarySize, separatorProps, containerProps } = useSplitPane(window.innerWidth * 0.45);

    const attentionData: AttentionData | null = useAttention(dims);

    useEffect(() => {
        if (viewMode !== 'none' && activeElement && attentionData) {
            const newHighlight = createBackwardHighlight(activeElement, attentionData, dims);
            setHighlight({ ...newHighlight, activeComponent });
            const newCalculationData = generateTooltipData(activeElement, attentionData, newHighlight.sources);

            if (viewMode === 'decomposition') {
                setTooltip(newCalculationData);
                setAnimationData(null);
            } else { // animation mode
                if (newCalculationData && newCalculationData.opType !== 'info') {
                    setAnimationData(newCalculationData);
                    setTooltip(null);
                } else {
                    setAnimationData(null);
                    setTooltip(newCalculationData);
                }
            }
        }
    }, [viewMode, activeElement, attentionData, dims, activeComponent]);

    const handleInteraction = useCallback((element: ElementIdentifier, event: React.MouseEvent) => {
        if (!attentionData) return;
        const variant = element.name.split('.')[0];
        setActiveComponent(variant);
        const newHighlight = createBackwardHighlight(element, attentionData, dims);
        setHighlight({ ...newHighlight, activeComponent: variant });
        setActiveElement(element);
    }, [attentionData, dims]);

    const handleComponentClick = useCallback((componentId: string) => {
        setActiveComponent(componentId);
        setHighlight({ target: null, sources: [], activeComponent: componentId });
        setTooltip(null);
        setAnimationData(null);
        setActiveElement(null);
        setViewMode('none');

        // Scroll to component
        const vizEl = vizRefs.current[componentId];
        const expEl = explanationRefs.current[componentId];
        if(vizEl) vizEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        if(expEl) expEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, []);

    const closeTooltip = useCallback(() => {
        setTooltip(null);
        setViewMode('none');
        setActiveElement(null);
    }, []);

    const closeAnimationPanel = useCallback(() => {
        setAnimationData(null);
        setViewMode('none');
        setActiveElement(null);
    }, []);

    if (!attentionData) {
        return <div style={{ padding: "20px", textAlign: "center" }}>正在加载或维度设置无效... (确保 d_model = n_q_heads * d_head 且 n_q_heads 能被 n_kv_heads 整除)</div>;
    }

    return (
        <div className="main-layout" {...containerProps}>
            {tooltip && <CalculationTooltip tooltip={tooltip} onClose={closeTooltip} />}
            {animationData && <AnimationPanel animationData={animationData} onClose={closeAnimationPanel} />}
            <Controls dims={dims} setDims={setDims} />
            <ViewToggle viewMode={viewMode} setViewMode={setViewMode} />

            <div className="column left-column" style={{width: primarySize, flex: 'none'}}>
                <div className="column-content">
                    <h2>数值模拟</h2>
                    <Viz data={attentionData} dims={dims} highlight={highlight} onElementClick={handleInteraction} onComponentClick={handleComponentClick} refs={vizRefs} />
                </div>
            </div>
            <div className="split-pane-separator" {...separatorProps} />
            <div className="column right-column" style={{flex: 1}}>
                <div className="column-content">
                    <h2>理论推导</h2>
                    <Explanation dims={dims} highlight={highlight} onSymbolClick={handleInteraction} onComponentClick={handleComponentClick} refs={explanationRefs} />
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/AttentionVariantsTopic.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/AnimationPanel.tsx
================================================================================

// FILE: src/topics/attention-variants/components/AnimationPanel.tsx
import React, { useRef } from 'react';
import { TooltipState } from '../../../components/CalculationTooltip/types';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';
import { InteractiveMatMulVisualizer } from '../../../components/visualizers/InteractiveMatMulVisualizer';
import { SoftmaxVisualizer } from '../../../components/visualizers/SoftmaxVisualizer';
import { getSymbolParts } from '../lib/symbolMapping';
import '../../../components/CalculationTooltip/CalculationTooltip.css'; // Reuse styles

interface AnimationPanelProps {
  animationData: TooltipState | null;
  onClose: () => void;
}

export const AnimationPanel: React.FC<AnimationPanelProps> = ({ animationData, onClose }) => {
    const panelRef = useRef<HTMLDivElement>(null);

    const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
        x: 100,
        y: 100,
        width: 900,
        height: 650,
    }, panelRef);

    if (!animationData) {
        return null;
    }

    // [MODIFIED] Inline styles object
    const styles: { [key: string]: React.CSSProperties } = {
        panel: {
            top: position.y,
            left: position.x,
            width: size.width,
            height: size.height,
            zIndex: 1010, // Ensure it's above other panels
        },
        panelHeader: {
            backgroundColor: '#f0f8ff', // A light blue to distinguish it
            borderBottom: '1px solid #cce5ff',
        },
        panelTitle: {
            color: '#004085',
        },
        panelContentWrapper: {
            flexGrow: 1,
            overflowY: 'auto',
            padding: '10px',
            backgroundColor: '#ffffff',
        },
        visualizerContainer: {
            height: '100%', // Ensure container takes full height
        },
        visualizerRoot: {
            border: 'none',
            boxShadow: 'none',
            width: '100%',
            height: '100%',
            boxSizing: 'border-box',
        },
    };


    const renderVisualizer = () => {
        const step = animationData.steps[0];
        const op = step.op === '·' ? '×' : step.op;

        switch (animationData.opType) {
            case 'matmul':
                return <InteractiveMatMulVisualizer
                    sourceVectorsA={step.aSources!}
                    sourceVectorB={step.bSources![0]}
                    resultSymbolInfo={getSymbolParts(animationData.target.name)}
                    operation={op as '×' | '+'}
                />;
            case 'softmax':
                return <SoftmaxVisualizer
                    inputVector={step.a}
                    inputLabel={step.aLabel}
                    outputLabel={step.resultLabel}
                />;
            default:
                return <div style={{ padding: '20px' }}>此操作类型没有可用的动画。</div>;
        }
    };

    return (
        <div ref={panelRef} style={styles.panel} className="animation-panel resizable-panel">
            <div className="panel-header" {...dragHandleProps} style={styles.panelHeader}>
                <span className="panel-title" style={styles.panelTitle}>{animationData.title}</span>
                <button onClick={onClose} className="tooltip-close-btn">&times;</button>
            </div>
            <div className="panel-content-wrapper" style={styles.panelContentWrapper}>
                <div style={styles.visualizerContainer}>
                    <div style={styles.visualizerRoot}>
                        {renderVisualizer()}
                    </div>
                </div>
            </div>
            <div className="resize-handle br" {...resizeHandleProps.br}></div>
            <div className="resize-handle t" {...resizeHandleProps.t}></div>
            <div className="resize-handle r" {...resizeHandleProps.r}></div>
            <div className="resize-handle b" {...resizeHandleProps.b}></div>
            <div className="resize-handle l" {...resizeHandleProps.l}></div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/AnimationPanel.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/Controls.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Controls.tsx
import React, { useState, useRef } from 'react';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';

interface ControlsProps {
    dims: {
        n_q_heads: number;
        n_kv_heads: number;
        d_head: number;
        d_c: number;
        d_c_prime: number;
        d_rope: number;
    };
    setDims: React.Dispatch<React.SetStateAction<any>>;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims }) => {
    const [isCollapsed, setIsCollapsed] = useState(true);
    const panelRef = useRef<HTMLDivElement>(null);
    const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
        x: window.innerWidth - 450,
        y: 90,
        width: 420,
        height: 320, // Increased height for new controls
    }, panelRef);

    const handleDimChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { id, value } = e.target;
        const numValue = parseInt(value, 10);

        setDims((prevDims: any) => {
            const newDims = { ...prevDims, [id]: numValue };

            if (id === 'n_q_heads') {
                if (numValue % newDims.n_kv_heads !== 0) {
                    let new_kv_heads = newDims.n_kv_heads;
                    while(numValue % new_kv_heads !== 0 && new_kv_heads > 1) {
                        new_kv_heads--;
                    }
                    newDims.n_kv_heads = Math.max(1, new_kv_heads);
                }
            }

            if (id === 'n_kv_heads') {
                if (newDims.n_q_heads % numValue !== 0) {
                    newDims.n_q_heads = numValue * Math.round(newDims.n_q_heads / numValue);
                    if (newDims.n_q_heads === 0) newDims.n_q_heads = numValue;
                }
            }

            newDims.d_model = newDims.n_q_heads * newDims.d_head;
            return newDims;
        });
    };

    const panelStyle: React.CSSProperties = {
        position: 'absolute',
        top: position.y,
        left: position.x,
        width: isCollapsed ? 50 : size.width,
        height: isCollapsed ? 50 : 'auto', // Auto height when not collapsed
    };

    return (
        <div ref={panelRef} style={panelStyle} className={`controls-panel ${isCollapsed ? 'collapsed' : ''} resizable-panel`}>
            <div className="panel-header" {...dragHandleProps}>
                <button className="panel-toggle-btn" onClick={() => setIsCollapsed(!isCollapsed)}>
                    {isCollapsed ? '⚙️' : '×'}
                </button>
                {!isCollapsed && <span className="panel-title">Controls</span>}
            </div>
            {!isCollapsed && (
                <div className="controls-container">
                    <div className="control-group">
                        <label htmlFor="n_q_heads">查询头 (N_q)</label>
                        <input type="number" id="n_q_heads" value={dims.n_q_heads} onChange={handleDimChange} step={1} min={1} max={16} />
                    </div>
                    <div className="control-group">
                        <label htmlFor="n_kv_heads">键/值头 (N_kv)</label>
                        <input type="number" id="n_kv_heads" value={dims.n_kv_heads} onChange={handleDimChange} step={1} min={1} max={dims.n_q_heads} />
                    </div>
                    <div className="control-group">
                        <label htmlFor="d_head">头维度 (d_head)</label>
                        <input type="number" id="d_head" value={dims.d_head} onChange={handleDimChange} step={2} min={2} max={32} />
                    </div>
                    <div className="control-group">
                        <label>模型维度 (d_model)</label>
                        <div className="d_k-value">{dims.n_q_heads * dims.d_head}</div>
                    </div>
                    <hr style={{width: '100%', borderTop: '1px solid #eee', margin: '10px 0'}} />
                    <div className="control-group">
                        <label htmlFor="d_c_prime">MLA Q Latent (d'_c)</label>
                        <input type="number" id="d_c_prime" value={dims.d_c_prime} onChange={handleDimChange} step={2} min={2} max={32} />
                    </div>
                    <div className="control-group">
                        <label htmlFor="d_c">MLA KV Latent (d_c)</label>
                        <input type="number" id="d_c" value={dims.d_c} onChange={handleDimChange} step={2} min={2} max={32} />
                    </div>
                    <div className="control-group">
                        <label htmlFor="d_rope">MLA RoPE Dim (d_r)</label>
                        <input type="number" id="d_rope" value={dims.d_rope} onChange={handleDimChange} step={2} min={2} max={dims.d_head} />
                    </div>
                </div>
            )}
            <div className="resize-handle br" {...resizeHandleProps.br}></div>
            <div className="resize-handle t" {...resizeHandleProps.t}></div>
            <div className="resize-handle r" {...resizeHandleProps.r}></div>
            <div className="resize-handle b" {...resizeHandleProps.b}></div>
            <div className="resize-handle l" {...resizeHandleProps.l}></div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/Controls.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/Element.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isProbMax?: boolean;
}

export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick, isProbMax = false }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col;

  const isSource = highlight.sources.some(s => {
    if (s.name !== name) return false;
    if (s.highlightRow) return s.row === row;
    if (s.highlightCol) return s.col === col;
    return s.row === row && s.col === col;
  });

  const classNames = ['matrix-element'];
  if (isTarget) classNames.push('target');
  if (isSource) classNames.push('source');
  if (isProbMax) classNames.push('prob-max');

  const handleClick = (event: React.MouseEvent) => {
    // Assuming ElementIdentifier needs variant, which should be passed down or derived
    const variant = name.split('.')[0] as 'mha' | 'mqa' | 'gqa' | 'mla';
    onElementClick({ variant, name, row, col }, event);
  };

  const displayValue = () => {
      if (value === -Infinity) return '-∞';
      if (value === Infinity) return '+∞';
      return value.toFixed(2);
  }

  return (
    <div className={classNames.join(' ')} onClick={handleClick}>
      {displayValue()}
    </div>
  );
});

// END OF FILE: src/topics/attention-variants/components/Element.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/ElementwiseCalculation.tsx
================================================================================

// FILE: src/topics/attention-variants/components/ElementwiseCalculation.tsx
import React, { useState, useMemo, useEffect } from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier, HighlightState } from '../types';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface ElementwiseCalculationProps {
  opType: 'softmax' | 'relu';
  inputRow: number[];
  outputRow: number[];
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  baseName: string;
  rowIndex: number;
  variant: 'mha' | 'mqa' | 'gqa' | 'mla';
}

const formatNumber = (num: number, precision = 4) => {
    if (num === -Infinity) return '-∞';
    if (num === Infinity) return '+∞';
    const parsed = parseFloat(num.toFixed(precision));
    return parsed.toString();
}

type SoftmaxStep = 'start' | 'exp' | 'sum' | 'divide';

export const ElementwiseCalculation: React.FC<ElementwiseCalculationProps> = ({
  opType,
  inputRow,
  outputRow,
  highlight,
  onElementClick,
  baseName,
  rowIndex,
  variant,
}) => {
  const [step, setStep] = useState<SoftmaxStep>('start');
  const stepsOrder: SoftmaxStep[] = ['start', 'exp', 'sum', 'divide'];
  const currentStepIndex = stepsOrder.indexOf(step);

  // [FIXED] Reset animation when the target row changes
  useEffect(() => {
    setStep('start');
  }, [rowIndex, baseName]);

  const calculations = useMemo(() => {
    const finiteInputRow = inputRow.filter(v => isFinite(v));
    const maxVal = finiteInputRow.length > 0 ? Math.max(...finiteInputRow) : 0;
    const exps = inputRow.map(val => isFinite(val) ? Math.exp(val - maxVal) : 0);
    const sumExps = exps.reduce((a, b) => a + b, 0);
    return { exps, sumExps };
  }, [inputRow]);

  const handleNext = () => setStep(stepsOrder[Math.min(stepsOrder.length - 1, currentStepIndex + 1)]);
  const handlePrev = () => setStep(stepsOrder[Math.max(0, currentStepIndex - 1)]);
  const handleReset = () => setStep('start');

  const targetCol = highlight.target?.isInternal && highlight.target.row === rowIndex ? highlight.target.col : -1;
  const visibleCols = getVisibleIndices(inputRow.length, targetCol, 2, 5);

  const handleClick = (event: React.MouseEvent, colIndex: number) => {
    onElementClick({
      variant,
      name: `${baseName}.internal`,
      row: rowIndex,
      col: colIndex,
      isInternal: true,
    }, event);
  };

  const isSource = (colIndex: number) => {
      return highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === colIndex && s.name === `${baseName}.internal`);
  }
  const isTarget = (colIndex: number) => {
      return highlight.target?.isInternal && highlight.target.row === rowIndex && highlight.target.col === colIndex;
  }

  const renderVisibleElements = (data: (number | string)[], isHighlighted: boolean) => {
    return visibleCols.map((col, i) => {
      if (col === ELLIPSIS) {
        return <div key={`ellipsis-${i}`} className="elementwise-op-element symbolic-ellipsis">...</div>;
      }
      const value = data[col];
      const className = `elementwise-op-element ${isSource(col) ? 'source' : ''} ${isTarget(col) ? 'target' : ''} ${isHighlighted ? 'highlight-step' : ''}`;
      return (
        <div key={`${i}-${col}`} className={className} onClick={(e) => handleClick(e, col)}>
          {typeof value === 'number' ? formatNumber(value) : value}
        </div>
      );
    });
  };

  const renderSoftmax = () => {
    const fullSumIsSource = isSource(-1);
    return (
      <>
        <div className={`calc-step ${currentStepIndex < 1 ? 'hidden' : ''}`}>
          <div className="calc-label"><InlineMath math="\text{exp}(x_i - \text{max}(\mathbf{x}))" /></div>
          <div className="elementwise-op-row">
            {renderVisibleElements(calculations.exps, step === 'exp')}
          </div>
        </div>
        <div className={`calc-step ${currentStepIndex < 2 ? 'hidden' : ''}`}>
          <div className="calc-label"><InlineMath math="\sum \text{exp}(\dots)" /></div>
          <div className={`elementwise-op-element sum ${fullSumIsSource ? 'source' : ''} ${step === 'sum' ? 'highlight-step' : ''}`} onClick={(e) => handleClick(e, -1)}>
            {formatNumber(calculations.sumExps)}
          </div>
        </div>
        <div className={`calc-step ${currentStepIndex < 3 ? 'hidden' : ''}`}>
          <div className="calc-label"><InlineMath math="\text{exp}(\dots) / \sum" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, step === 'divide')}</div>
        </div>
        <div className="elementwise-controls">
            <button onClick={handlePrev} disabled={currentStepIndex <= 0}>上一步</button>
            <button onClick={handleNext} disabled={currentStepIndex >= stepsOrder.length - 1}>下一步</button>
            <button onClick={handleReset}>重置</button>
        </div>
      </>
    );
  };

  const renderOther = () => (
      <div>Operation {opType} detail view not implemented.</div>
  );

  return (
    <div className="elementwise-calc-container">
      <div className="calc-step">
        <div className="calc-label"><InlineMath math="\text{Input (Scores)}" /></div>
        <div className="elementwise-op-row">{renderVisibleElements(inputRow, step === 'start')}</div>
      </div>
      {opType === 'softmax' ? renderSoftmax() : renderOther()}
    </div>
  );
};
// END OF FILE: src/topics/attention-variants/components/ElementwiseCalculation.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/ElementwiseOperation.tsx
================================================================================

// FILE: src/topics/attention-variants/components/ElementwiseOperation.tsx
import React from 'react';
import { Matrix, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { ElementwiseCalculation } from './ElementwiseCalculation';

interface ElementwiseOperationProps {
    opType: 'softmax';
    inputMatrix: Matrix;
    outputMatrix: Matrix;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    variant: 'mha' | 'mqa' | 'gqa' | 'mla';
}

export const ElementwiseOperation: React.FC<ElementwiseOperationProps> = ({
    opType,
    inputMatrix,
    outputMatrix,
    outputMatrixName,
    highlight,
    onElementClick,
    variant
}) => {
    let targetRowIndex = 0;

    if (highlight.target) {
        if (highlight.target.name === outputMatrixName || highlight.target.name.startsWith(outputMatrixName.split('.')[0] + ".heads." + outputMatrixName.split('.')[2] + ".Scores")) {
             targetRowIndex = highlight.target.row;
        } else if (highlight.target.isInternal && highlight.target.name.startsWith(outputMatrixName)) {
            targetRowIndex = highlight.target.row;
        }
    }

    const inputRow = inputMatrix[targetRowIndex] || [];
    const outputRow = outputMatrix[targetRowIndex] || [];

    const opName = opType.charAt(0).toUpperCase() + opType.slice(1);

    return (
        <div className="elementwise-op-container">
            <div className="elementwise-op-label">
                <InlineMath math={`\\text{Detailed Calculation: } \\text{${opName}}`} />
            </div>
            <p style={{margin: '0', fontSize: '0.8em', color: '#666'}}>* Showing calculation for Row {targetRowIndex}</p>
            <ElementwiseCalculation
                opType={opType}
                inputRow={inputRow}
                outputRow={outputRow}
                highlight={highlight}
                onElementClick={onElementClick}
                baseName={outputMatrixName}
                rowIndex={targetRowIndex}
                variant={variant}
            />
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/ElementwiseOperation.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/Explanation.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Explanation.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { MLASymbolicViz } from './MLASymbolicViz';

interface ExplanationProps {
    dims: { n_q_heads: number, n_kv_heads: number, d_head: number, d_model: number, seq_len: number, d_c: number, d_c_prime: number, d_rope: number };
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    refs: React.MutableRefObject<{ [key: string]: HTMLDivElement | null }>;
}

const renderVariantExplanation = (
    variant: 'mha' | 'mqa' | 'gqa',
    dims: ExplanationProps['dims'],
    highlight: HighlightState,
    onSymbolClick: ExplanationProps['onSymbolClick']
) => {
    const { d_head, d_model, seq_len, n_q_heads } = dims;

    const q_head_name = `${variant}.heads.0.Q`;
    const k_head_name = `${variant}.heads.0.K`;
    const v_head_name = `${variant}.heads.0.V`;
    const scores_name = `${variant}.heads.0.Scores`;
    const weights_name = `${variant}.heads.0.Weights`;
    const output_head_name = `${variant}.heads.0.Output`;
    const combined_name = `${variant}.combined`;
    const final_output_name = `${variant}.output`;

    const break_qkv_proj = (d_model + d_head + d_head) > 8;
    const break_scores = (d_head + seq_len + seq_len) > 8;
    const break_output = (seq_len + d_head + d_head) > 8;
    const break_final = (n_q_heads * d_head + d_model + d_model) > 8;

    return (
        <div className="attention-calculation-step">
            <div className="step-title">1. 线性投影与多头拆分</div>
            <p>输入张量 <strong>H</strong> (代表了富含上下文信息的词向量序列) 通过乘以三个独立的、可学习的权重矩阵 <strong>W</strong>，分别被线性投影到三个不同的子空间，生成查询 (Query, <strong>Q</strong>)、键 (Key, <strong>K</strong>) 和值 (Value, <strong>V</strong>) 矩阵。在MHA中，每个头都有独立的 <InlineMath math="W_{Q,h}, W_{K,h}, W_{V,h}"/>。而在GQA/MQA中，K, V的权重矩阵是分组共享或完全共享的。Q的权重矩阵在所有变体中始终是每个头独立的。</p>
            <div className="viz-formula-group">
                <div className={`viz-formula-row ${break_qkv_proj ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={`${variant}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={`${variant}.wq.0`} rows={d_model} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={q_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </div>
            <div className="viz-formula-group">
                <div className={`viz-formula-row ${break_qkv_proj ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={`${variant}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={`${variant}.wk.0`} rows={d_model} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={k_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </div>
            <div className="viz-formula-group">
                <div className={`viz-formula-row ${break_qkv_proj ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={`${variant}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={`${variant}.wv.0`} rows={d_model} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={v_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </div>

            <div className="step-title">2. 计算注意力分数 (Scaled Dot-Product)</div>
            <p>首先，通过计算每个查询向量与所有键向量的点积来评估它们的相似度。这个结果（原始分数）越大，表示两个向量的关联性越强。然后，为了防止梯度在训练中过小或过大以保持数值稳定性，将这些分数除以 <InlineMath math="\sqrt{d_{\text{head}}}" /> 进行缩放。</p>
            <BlockMath math={"\\text{Scores}_h = \\frac{Q_h K_{\\text{group}(h)}^T}{\\sqrt{d_{\\text{head}}}}"} />
            <div className="viz-formula-group">
                <div className={`viz-formula-row ${break_scores ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={q_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={k_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} transpose={true} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={scores_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </div>
            <p>接下来，应用Softmax函数将缩放后的原始分数矩阵 <InlineMath math="\text{Scores}_h"/> 转换为一个和为1的概率分布。这个新的矩阵被称为“注意力权重” <InlineMath math="A_h"/>，它的每个元素表示一个查询向量应该对相应的值向量“关注”多少。</p>
            <BlockMath math={"A_h = \\text{Softmax}(\\text{Scores}_h)"} />
            <div className="viz-formula-group">
                <div className="viz-formula-row">
                    <InteractiveSymbolicMatrix name={weights_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true} />
                </div>
            </div>

            <div className="step-title">3. 加权求和得到单头输出</div>
            <p>使用上一步计算出的注意力权重 <InlineMath math="A_h"/> 对值向量 <InlineMath math="V_h"/> 进行加权求和。这里的矩阵乘法，本质上是对 <InlineMath math="V"/> 矩阵中所有词的向量进行一次加权平均。注意力权重矩阵 <InlineMath math="A_h"/> 的每一行都提供了一组权重，指导如何将所有词的“内容”(V)混合起来，从而为当前词生成一个全新的、富含上下文信息的向量表示。</p>
            <div className="viz-formula-group">
                <div className={`viz-formula-row ${break_output ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={weights_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={v_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={output_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </div>

            <div className="step-title">4. 合并与最终投影</div>
            <p>将所有 <InlineMath math="N_q"/> 个头的输出 <InlineMath math="H_h"/> 拼接（Concatenate）起来，然后通过一个最终的线性投影矩阵 <InlineMath math="W^O"/> 将其维度变回 <InlineMath math="d_{\text{model}}"/>，得到该子层的最终输出 <InlineMath math="Z"/>。这个输出 <InlineMath math="Z"/> 已经融合了丰富的上下文信息。在完整的Transformer层中，这个输出通常会再经过一个前馈神经网络（FFN）层。FFN会对每个位置的向量独立地进行一次复杂的非线性变换，可以理解为模型在融合了上下文信息后，对每个词的含义进行一次独立的“深入思考和加工”，从而极大地增强了模型的表达能力。</p>
            <BlockMath math={"Z = \\text{Concat}(\\text{head}_0, ..., \\text{head}_{N_q-1}) W_O"} />
            <div className="viz-formula-group">
                <div className={`viz-formula-row ${break_final ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={combined_name} rows={seq_len} cols={n_q_heads * d_head} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={`${variant}.wo`} rows={n_q_heads * d_head} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={final_output_name} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </div>
        </div>
    )
}

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight, onSymbolClick, onComponentClick, refs }) => {
    const { n_q_heads, n_kv_heads } = dims;

    return (
        <div>
            <div className="math-block" ref={el => refs.current['intro'] = el}>
                <h3>引言</h3>
                <p>在深度学习，特别是自然语言处理(NLP)领域，注意力机制(Attention Mechanism)是一个非常重要的概念。注意力机制的起源可以追溯到对生物视觉注意力的模拟以及神经机器翻译的实际需求。Bahdanau等人的工作首次将注意力机制引入自然语言处理领域；而Transformer架构则将注意力机制推向了一个新的高度，使其成为现代自然语言处理的核心技术之一。</p>
                <p>Transformer架构的出现可以说是全球人工智能快速发展的转折点，该架构由Encoder和Decoder两部分组成，其中Encoder部分发展成了Bert、Roberta等模型，Decoder部分发展成了GPT等生成式大模型。此类模型效果强悍，并得到了广泛的应用，这进一步推动了注意力机制的发展。</p>
                <p>然而，随着模型规模的不断扩大和上下文长度的日益增长，传统的注意力机制在推理阶段面临着巨大的计算和内存挑战。特别是，自回归生成任务中<strong>Key-Value (KV) Cache</strong>的指数级增长成为了瓶颈，极大地限制了大型语言模型(LLM)的吞吐量和可服务性。为了解决这些挑战，研究者们不断探索和提出了各种注意力变体，旨在优化性能、降低成本，并提升LLM在实际应用中的效率。</p>
            </div>
            <div className="attention-variant-section" ref={el => refs.current['vars'] = el}>
                <div className="component-header" onClick={() => onComponentClick('vars')}>变量定义</div>
                <div className="component-body">
                    <div className="explanation-subsection">
                        <p>在深入探讨各种注意力机制之前,我们首先统一定义本文中将使用的变量。明确的变量命名有助于我们精确地理解每个计算步骤的含义。</p>
                        <ul>
                            <li><strong>基础维度 (Basic Dimensions)</strong>
                                <ul>
                                    <li><InlineMath math="B"/>: 批处理大小 (Batch Size)</li>
                                    <li><InlineMath math="S"/>: 序列长度 (Sequence Length)</li>
                                    <li><InlineMath math="d_{model}"/>: 模型的隐藏层维度 (Hidden Dimension)</li>
                                    <li><InlineMath math="N_{q\_heads}"/>: 查询头的数量 (Number of Query Heads)</li>
                                    <li><InlineMath math="N_{kv\_heads}"/>: 键/值头的数量 (Number of Key/Value Heads)</li>
                                    <li><InlineMath math="d_{head}"/>: 每个注意力头的维度, 通常 <InlineMath math="d_{head} = d_{model} / N_{q\_heads}"/></li>
                                </ul>
                            </li>
                            <li><strong>张量与向量 (Tensors & Vectors)</strong>
                                <ul>
                                    <li><InlineMath math="H \in \mathbb{R}^{B \times S \times d_{model}}"/>: 输入张量</li>
                                    <li><InlineMath math="W_Q, W_K, W_V \in \mathbb{R}^{d_{model} \times d_{model}}"/>: MHA的总投影矩阵</li>
                                    <li><InlineMath math="W_O \in \mathbb{R}^{d_{model} \times d_{model}}"/>: 输出投影矩阵</li>
                                </ul>
                            </li>
                            <li><strong>精细化QKV向量 (Granular QKV Vectors)</strong>
                                <ul>
                                    <li><InlineMath math="q_{t,h} \in \mathbb{R}^{d_{head}}"/>: 位置t, 头h的查询(Query)向量</li>
                                    <li><InlineMath math="k_{j,h} \in \mathbb{R}^{d_{head}}"/>: 位置j, 头h的键(Key)向量</li>
                                    <li><InlineMath math="v_{j,h} \in \mathbb{R}^{d_{head}}"/>: 位置j, 头h的值(Value)向量</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>


            <div className="attention-variant-section" ref={el => refs.current['mha'] = el}>
                <div className="component-header" onClick={() => onComponentClick('mha')}>MHA (Multi-Head Attention)</div>
                <div className="component-body">
                    <div className="explanation-subsection">
                        <h5>出现原因与设计思路</h5>
                        <p><strong>单头注意力的局限性:</strong> 传统的单头注意力(Single-Head Attention)虽然能捕捉到输入元素之间的关系，但它只能在一个单一的、固定的表示空间中进行。这意味着模型在处理复杂信息时能力可能会受限，难以同时关注到输入序列中不同层面（例如语法结构、语义关系等）的细微特征。</p>
                        <p><strong>并行化与多视角学习:</strong> MHA通过引入多个“注意力头”，将输入的原始维度 <InlineMath math="d_{model}"/> 分割成 <InlineMath math="N_{q\_heads}"/> 个更小的子空间。每个头独立地在自己的子空间中执行注意力计算，学习不同的注意力模式。这种设计允许模型从多个“视角”去理解输入信息，例如，一个头可能关注长距离依赖，另一个头可能关注局部语义，从而捕获更丰富、更复杂的上下文信息。</p>
                    </div>
                    <div className="explanation-subsection">
                        <h5>交互式公式推导 (以头0为例)</h5>
                        {renderVariantExplanation('mha', dims, highlight, onSymbolClick)}
                    </div>
                    <div className="explanation-subsection">
                        <h5>KV Cache: 概念、变化与牺牲</h5>
                        <p><strong>概念与作用:</strong> 在LLM的自回归生成阶段，模型每次生成一个token，然后将新token附加到序列中。为避免重复计算前序token的Key和Value向量，KV Cache会将这些计算过的K/V向量存储起来，在后续步骤中直接复用，从而<strong>节省了大量的计算时间</strong>。这是一种典型的“<strong>以空间换时间</strong>”的优化策略。</p>
                        <p><strong>显存占用:</strong> 在MHA中，每个查询头都有独立的K/V头 (<InlineMath math={`N_q=${n_q_heads}, N_{kv}=${n_q_heads}`}/>)。因此，KV Cache的大小与查询头的数量成正比，公式为：</p>
                        <BlockMath math={"\\text{Cache}_{\\text{MHA}} \\propto S \\times N_{q\\_\\text{heads}} \\times d_{\\text{head}} = S \\times d_{\\text{model}}"} />
                        <p>对于Llama3 70B模型(L=80, <InlineMath math="N_{q\_heads}=64"/>, <InlineMath math="d_{head}=128"/>, 16位精度)，当批处理大小 <InlineMath math="B=8"/> 且序列长度 <InlineMath math="S=1000"/> 时，KV Cache大小约为 <strong>20.97 GB</strong>，随着序列长度线性增长，这很快成为瓶颈。</p>
                    </div>
                </div>
            </div>

            <div className="attention-variant-section" ref={el => refs.current['gqa'] = el}>
                <div className="component-header" onClick={() => onComponentClick('gqa')}>GQA (Grouped-Query Attention)</div>
                <div className="component-body">
                    <div className="explanation-subsection">
                        <h5>出现原因与设计思路</h5>
                        <p>GQA是MHA和MQA之间的折中方案。它认识到MHA的KV头可能存在冗余，而MQA的单一KV头又可能限制了模型性能。因此，GQA将查询头分组，每组共享一对K/V头，旨在保持接近MHA性能的同时，有效减少KV Cache。</p>
                        <p><strong>分组机制:</strong> GQA的核心思想是将 <InlineMath math="N_{q\_heads}"/> 个查询头平均分配到 <InlineMath math="N_{kv\_heads}"/> 个组中。通过调整组的数量，GQA可以灵活地在MHA(<InlineMath math="N_{kv\_heads} = N_{q\_heads}"/>)和MQA(<InlineMath math="N_{kv\_heads} = 1"/>)之间进行权衡。</p>
                    </div>
                    <div className="explanation-subsection">
                        <h5>交互式公式推导 (以头0为例)</h5>
                        {renderVariantExplanation('gqa', dims, highlight, onSymbolClick)}
                    </div>
                    <div className="explanation-subsection">
                        <h5>KV Cache: 变化与牺牲</h5>
                        <p><strong>显存占用:</strong> 在GQA中，查询头被分成 ${n_kv_heads}$ 组，每组共享一个K/V头 (<InlineMath math={`N_q=${n_q_heads}, N_{kv}=${n_kv_heads}`}/>)。KV Cache只存储 <InlineMath math="N_{kv\_heads}"/> 份Key和Value，大小减少为MHA的 <InlineMath math={`${n_kv_heads}/${n_q_heads}`}/> 倍。</p>
                        <BlockMath math={"\\text{Cache}_{\\text{GQA}} \\propto S \\times N_{kv\\_\\text{heads}} \\times d_{\\text{head}}"} />
                        <p>以Llama3 70B为例，若采用GQA并设置 <InlineMath math="N_{kv\_heads}=8"/>，KV Cache将减少8倍，从20.97 GB降至约 <strong>2.62 GB</strong>，这是一个显著的优化。</p>
                        <p><strong>牺牲:</strong> GQA的牺牲主要是设计复杂性和需要对组数 <InlineMath math="N_{kv\_heads}"/> 进行超参数调优。虽然性能显著优于MQA，但理论上仍可能略低于MHA。</p>
                    </div>
                </div>
            </div>

            <div className="attention-variant-section" ref={el => refs.current['mqa'] = el}>
                <div className="component-header" onClick={() => onComponentClick('mqa')}>MQA (Multi-Query Attention)</div>
                <div className="component-body">
                    <div className="explanation-subsection">
                        <h5>出现原因与设计思路</h5>
                        <p>面对MHA高昂的KV Cache成本，MQA提出了一种极致的解决方案：让所有查询头共享<strong>同一份</strong>Key和Value。</p>
                        <p><strong>最大化共享:</strong> MQA的核心是将 <InlineMath math="N_{kv\_heads}"/> 降至1，即所有 <InlineMath math="N_{q\_heads}"/> 个查询头共享同一组Key和Value矩阵。这意味着模型只需要计算和存储一套Key和Value。</p>
                    </div>
                    <div className="explanation-subsection">
                        <h5>交互式公式推导 (以头0为例)</h5>
                        {renderVariantExplanation('mqa', dims, highlight, onSymbolClick)}
                    </div>
                    <div className="explanation-subsection">
                        <h5>KV Cache: 变化与牺牲</h5>
                        <p><strong>显存占用:</strong> 在MQA中，所有查询头共享唯一的K/V头 (<InlineMath math={`N_q=${n_q_heads}, N_{kv}=1`}/>)。这使得KV Cache的大小减少为MHA的 <InlineMath math={`1/${n_q_heads}`}/> 倍，极大地节省了内存。</p>
                        <BlockMath math={"\\text{Cache}_{\\text{MQA}} \\propto S \\times 1 \\times d_{\\text{head}}"} />
                        <p>以Llama3 70B为例，当 <InlineMath math="N_{q\_heads}=64"/> 时，KV Cache将减少64倍，从约20.97 GB降至约 <strong>327.6 MB</strong>。这是一个非常显著的内存节省。</p>
                        <p><strong>牺牲:</strong> MQA的牺牲主要是<strong>模型性能</strong>。由于所有注意力头共享相同的K和V信息，它们无法像MHA那样从多样化的K/V子空间中学习，可能导致表达能力下降或收敛速度变慢。</p>
                    </div>
                </div>
            </div>

            <div className="attention-variant-section active-component" ref={el => refs.current['mla'] = el}>
                <div className="component-header" onClick={() => onComponentClick('mla')}>MLA (Multi-head Latent Attention) - 符号推导</div>
                <div className="component-body">
                    <MLASymbolicViz
                        dims={dims}
                        highlight={highlight}
                        onElementClick={onSymbolClick}
                        onComponentClick={onComponentClick}
                    />
                </div>
            </div>

            <div className="attention-variant-section" ref={el => refs.current['summary'] = el}>
                <div className="component-header" onClick={() => onComponentClick('summary')}>总结: 从MHA到MLA的演进之路</div>
                <div className="component-body">
                    <table className="summary-table">
                        <thead>
                        <tr>
                            <th>特性</th>
                            <th>MHA (Multi-Head Attention)</th>
                            <th>MQA (Multi-Query Attention)</th>
                            <th>GQA (Grouped-Query Attention)</th>
                            <th>MLA (Multi-head Latent Attention)</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td><strong>核心思想</strong></td>
                            <td>并行多子空间学习</td>
                            <td>极致KV共享，压缩Cache</td>
                            <td>在性能和效率间折中</td>
                            <td>低秩压缩KV，推理时吸收权重</td>
                        </tr>
                        <tr>
                            <td><strong>KV头数量</strong></td>
                            <td><InlineMath math="N_{q\_heads}"/></td>
                            <td>1</td>
                            <td><InlineMath math="N_{kv\_heads}"/> (1 ≤ <InlineMath math="N_{kv\_heads}"/> ≤ <InlineMath math="N_{q\_heads}"/>)</td>
                            <td>推理时等效为1个共享<strong>潜在</strong>K/V</td>
                        </tr>
                        <tr>
                            <td><strong>KV Cache大小 (相对MHA)</strong></td>
                            <td>1x</td>
                            <td><InlineMath math="1/N_{q\_heads}"/></td>
                            <td><InlineMath math="N_{kv\_heads}/N_{q\_heads}"/></td>
                            <td>极小 (约1/25至1/60)</td>
                        </tr>
                        <tr>
                            <td><strong>优点</strong></td>
                            <td>强大的表达能力，训练效果佳</td>
                            <td>极低的KV Cache，显著加速推理</td>
                            <td>灵活的性能-效率权衡，性能接近MHA</td>
                            <td>极致的KV Cache压缩，同时保持高性能</td>
                        </tr>
                        <tr>
                            <td><strong>缺点</strong></td>
                            <td>KV Cache巨大，推理瓶颈</td>
                            <td>可能损失模型性能</td>
                            <td>实现复杂度略增，需调参</td>
                            <td>结构复杂，训练难度高</td>
                        </tr>
                        <tr>
                            <td><strong>适用场景</strong></td>
                            <td>训练，对性能要求高的场景</td>
                            <td>对推理速度和显存极度敏感的场景</td>
                            <td>大多数现代大模型的通用选择</td>
                            <td>对效率和性能都有极致要求的超长序列场景</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/Explanation.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/InteractiveSymbolicElement.tsx
================================================================================

// FILE: src/topics/attention-variants/components/InteractiveSymbolicElement.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { HighlightState } from '../types';
import { useHighlighting } from '../hooks/useHighlighting';

interface InteractiveSymbolicElementProps {
  name: string;
  base: string;
  subscript?: string;
  row?: number;
  col?: number;
  highlight: HighlightState;
  onClick: (event: React.MouseEvent) => void;
}

export const InteractiveSymbolicElement: React.FC<InteractiveSymbolicElementProps> = React.memo(({ name, base, subscript, row, col, highlight, onClick }) => {
  const { isTarget, isSource } = useHighlighting(name, row ?? 0, col ?? 0, highlight);

  const elementBase = base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
  const subscriptContent = [subscript, row, col].filter(s => s !== undefined && s !== null).join(',');
  const mathString = `${elementBase}_{${subscriptContent}}`;

  const className = `symbolic-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''}`;

  return (
    <div className={className} onClick={onClick} style={{cursor: 'pointer'}}>
      <InlineMath math={mathString} />
    </div>
  );
});

// END OF FILE: src/topics/attention-variants/components/InteractiveSymbolicElement.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/InteractiveSymbolicMatrix.tsx
================================================================================

// FILE: src/topics/attention-variants/components/InteractiveSymbolicMatrix.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';
import { getSymbolParts } from '../lib/symbolMapping';

interface InteractiveSymbolicMatrixProps {
    name: string;
    rows: number;
    cols: number;
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    transpose?: boolean;
    isPlaceholder?: boolean;
    sideLabel?: boolean; // For explicit side-labeling
}

export const InteractiveSymbolicMatrix: React.FC<InteractiveSymbolicMatrixProps> = React.memo(({ name, rows, cols, highlight, onSymbolClick, transpose = false, isPlaceholder = false, sideLabel = false }) => {
    const symbol = getSymbolParts(name);
    const variant = name.split('.')[0] as ElementIdentifier['variant'];

    // [NEW] Logic for dynamic label positioning
    const useBottomLabel = cols > 8;
    const wrapperClasses = ['matrix-wrapper'];
    if (sideLabel && !useBottomLabel) {
        wrapperClasses.push('side-label');
    }
    if (useBottomLabel) {
        wrapperClasses.push('label-bottom');
    }

    const displayRows = transpose ? cols : rows;
    const displayCols = transpose ? rows : cols;

    let focusRow = -1;
    let focusCol = -1;

    if (highlight.target?.name === name) {
        focusRow = highlight.target.row;
        focusCol = highlight.target.col;
    }

    const isTargetMatrix = !!highlight.target && highlight.target.name === name;
    const isSourceMatrix = highlight.sources.some(s => s.name === name);
    const shouldShowHeaders = isTargetMatrix || isSourceMatrix;

    const visibleRowIndices = getVisibleIndices(displayRows, transpose ? focusCol : focusRow);
    const visibleColIndices = getVisibleIndices(displayCols, transpose ? focusRow : focusCol);

    let mathSymbol = symbol.base;
    if (symbol.superscript) mathSymbol += `^{${symbol.superscript}}`;
    if (transpose) mathSymbol += '^T';

    const subscriptParts = [];
    if (symbol.subscript) subscriptParts.push(symbol.subscript);
    subscriptParts.push(`${rows} \\times ${cols}`);
    mathSymbol += `_{${subscriptParts.join(',')}}`;

    const containerClassName = isPlaceholder ? 'placeholder-matrix' : '';

    const matrixGrid = (
        // [MODIFIED] Renamed symbolic-matrix-grid to matrix-grid to share styles
        // but kept symbolic-specific styles inside symbolic-matrix-grid for element sizing
        <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: shouldShowHeaders ? `auto repeat(${visibleColIndices.length}, auto)` : `repeat(${visibleColIndices.length}, auto)` }}>
            {/* Top-left corner & Column Headers */}
            {shouldShowHeaders && <div key="corner" />}
            {shouldShowHeaders && visibleColIndices.map((c, cIdx) => (
                <div key={`ch-${cIdx}`} className="symbolic-header-item">{c}</div>
            ))}

            {/* Row Headers and Matrix Elements */}
            {visibleRowIndices.map((r, rIdx) => (
                <React.Fragment key={`row-frag-${rIdx}`}>
                    {shouldShowHeaders && <div className="symbolic-header-item">{r}</div>}
                    {visibleColIndices.map((c, cIdx) => {
                        if (r === ELLIPSIS || c === ELLIPSIS) {
                            return <div key={`ellipsis-r${rIdx}-c${cIdx}`} className="symbolic-ellipsis">{r === ELLIPSIS && c === ELLIPSIS ? '⋱' : '…'}</div>;
                        }
                        const originalRow = transpose ? c : r;
                        const originalCol = transpose ? r : c;
                        return (
                            <InteractiveSymbolicElement
                                key={`elem-r${r}-c${c}`}
                                name={name}
                                base={symbol.base}
                                subscript={symbol.subscript}
                                row={originalRow}
                                col={originalCol}
                                highlight={highlight}
                                onClick={(event) => onSymbolClick({ variant, name, row: originalRow, col: originalCol }, event)}
                            />
                        );
                    })}
                </React.Fragment>
            ))}
        </div>
    );

    return (
        <div className={wrapperClasses.join(' ')}>
            <div className="matrix-label-side"><InlineMath math={`${mathSymbol}`} /></div>
            {/* [MODIFIED] Wrap grid in the .matrix-container to get shared border/bg style */}
            <div className={`${containerClassName} matrix-container`}>
                {matrixGrid}
            </div>
            <div className="matrix-label-container">
                <div className="matrix-label"><InlineMath math={`${mathSymbol}`} /></div>
            </div>
        </div>
    );
});
// END OF FILE: src/topics/attention-variants/components/InteractiveSymbolicMatrix.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/InteractiveSymbolicVector.tsx
================================================================================

// FILE: src/topics/attention-variants/components/InteractiveSymbolicVector.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { Vector as VectorType } from '../types';
import { getSymbolParts } from '../lib/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicVectorProps {
    name: string;
    data: VectorType;
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    sideLabel?: boolean; // For explicit override
}

export const InteractiveSymbolicVector: React.FC<InteractiveSymbolicVectorProps> = React.memo(({ name, data, highlight, onSymbolClick, sideLabel = false }) => {
    const displayCols = data.length;
    const symbol = getSymbolParts(name);
    const variant = name.split('.')[0] as ElementIdentifier['variant'];

    let focusCol = -1;
    if (highlight.target?.name === name) {
        focusCol = highlight.target.col;
    }

    const visibleColIndices = getVisibleIndices(displayCols, focusCol);

    const gridElements = visibleColIndices.map((c, cIdx) => {
        if (c === ELLIPSIS) {
            return <div key={`ellipsis-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
        }

        return (
            <InteractiveSymbolicElement
                key={`elem-${c}`}
                name={name}
                base={symbol.base}
                subscript={symbol.subscript}
                col={c}
                highlight={highlight}
                onClick={(event) => onSymbolClick({ variant, name, row: 0, col: c }, event)}
            />
        );
    });

    let mathSymbol = symbol.base;

    const subscriptParts = [];
    if (symbol.subscript) {
        subscriptParts.push(symbol.subscript);
    }
    subscriptParts.push(`1 \\times ${displayCols}`);
    mathSymbol += `_{${subscriptParts.join(',')}}`;

    const matrixGrid = (
        <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${gridElements.length}, auto)` }}>
            {gridElements}
        </div>
    );

    return (
        <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`}>
            <div className="matrix-label-side"><InlineMath math={`${mathSymbol}`} /></div>
            <div className="symbolic-matrix-container">
                {matrixGrid}
            </div>
            <div className="matrix-label"><InlineMath math={`${mathSymbol}`} /></div>
        </div>
    );
});
// END OF FILE: src/topics/attention-variants/components/InteractiveSymbolicVector.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/Matrix.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';
import { getSymbolParts } from '../lib/symbolMapping';

interface MatrixProps {
    name: string;
    data: MatrixType;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    sideLabel?: boolean; // For explicit side-labeling when not in a vertical row
    isTransposed?: boolean;
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, sideLabel = false, isTransposed = false }) => {
    if (!data || data.length === 0 || data[0].length === 0) {
        return <div>Invalid matrix data for {name}</div>;
    }

    const numRows = data.length;
    const numCols = data[0].length;

    // [NEW] Logic for dynamic label positioning
    const useBottomLabel = numCols > 8;
    const wrapperClasses = ['matrix-wrapper'];
    if (sideLabel && !useBottomLabel) {
        wrapperClasses.push('side-label');
    }
    if (useBottomLabel) {
        wrapperClasses.push('label-bottom');
    }


    const displayRows = isTransposed ? numCols : numRows;
    const displayCols = isTransposed ? numRows : numCols;


    let focusRow = -1;
    let focusCol = -1;

    const isTargetMatrix = !!highlight.target && highlight.target.name === name;
    const isSourceMatrix = highlight.sources.some(s => s.name === name);
    const shouldShowHeaders = isTargetMatrix || isSourceMatrix;

    if (isTargetMatrix) {
        focusRow = highlight.target!.row;
        focusCol = highlight.target!.col;
    } else if (isSourceMatrix) {
        const relevantSource = highlight.sources.find(s => s.name === name)!;
        focusRow = relevantSource.row === -1 ? focusRow : relevantSource.row;
        focusCol = relevantSource.col === -1 ? focusCol : relevantSource.col;
    }

    const visibleRowIndices = getVisibleIndices(displayRows, isTransposed ? focusCol : focusRow);
    const visibleColIndices = getVisibleIndices(displayCols, isTransposed ? focusRow : focusCol);

    const symbolParts = getSymbolParts(name);
    let mathSymbol = symbolParts.base;
    if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
    if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;
    if(isTransposed) mathSymbol = `${mathSymbol}^T`;


    const matrixGrid = (
        // [MODIFIED] Add the matrix-container wrapper for styles
        <div className="matrix-container">
            <div className="matrix-grid" data-name={name} style={{ gridTemplateColumns: shouldShowHeaders ? `auto repeat(${visibleColIndices.length}, auto)` : `repeat(${visibleColIndices.length}, auto)` }}>
                {shouldShowHeaders && <div key="corner" />}
                {shouldShowHeaders && visibleColIndices.map((c, cIdx) => (
                    <div key={`ch-${cIdx}`} className="matrix-header-item">{c}</div>
                ))}
                {visibleRowIndices.map((r, rIdx) => (
                    <React.Fragment key={`row-frag-${rIdx}`}>
                        {shouldShowHeaders && <div className="matrix-header-item">{r}</div>}
                        {visibleColIndices.map((c, cIdx) => {
                            if (r === ELLIPSIS) {
                                return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                            }
                            if (c === ELLIPSIS) {
                                return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">…</div>;
                            }
                            const originalRow = isTransposed ? c : r;
                            const originalCol = isTransposed ? r : c;
                            return (
                                <Element
                                    key={`${name}-${originalRow}-${originalCol}`}
                                    name={name}
                                    row={originalRow}
                                    col={originalCol}
                                    value={data[originalRow][originalCol]}
                                    highlight={highlight}
                                    onElementClick={onElementClick}
                                />
                            );
                        })}
                    </React.Fragment>
                ))}
            </div>
        </div>
    );

    return (
        <div className={wrapperClasses.join(' ')} data-name={name}>
            <div className="matrix-label-side">
                <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
            </div>

            {/* The grid is no longer wrapped in a separate scrolling container */}
            {matrixGrid}

            <div className="matrix-label-container">
                <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/Matrix.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/MLANumericViz.tsx
================================================================================

// FILE: src/topics/attention-variants/components/MLANumericViz.tsx
import React from 'react';
import { HighlightState, ElementIdentifier, AttentionData } from '../types';
import { Matrix } from './Matrix';
import { BlockMath } from 'react-katex';

interface MLANumericVizProps {
    data: AttentionData;
    dims: any;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MLANumericViz: React.FC<MLANumericVizProps> = ({ data, dims, highlight, onElementClick, onComponentClick }) => {
    const variantName = 'mla';
    const { d_model, d_head, seq_len, n_q_heads, d_c, d_c_prime, d_rope } = dims;

    const break_compress = (d_c_prime + d_c + d_rope) > 15;
    const break_scores = (d_head + d_rope + seq_len) > 15;
    const break_output = (seq_len + d_head) > 15;
    const break_final = (n_q_heads * d_head + d_model) > 15;

    const headData = data.mla.heads[0];

    return (
        <div className={`attention-variant-section ${highlight.activeComponent === 'mla' ? 'active-component' : ''}`} id="viz-mla">
            <div className="component-header" onClick={() => onComponentClick('mla')}>MLA (Multi-head Latent Attention) - 数值模拟</div>
            <div className="component-body">
                <div className="attention-calculation-step">
                    <div className="step-title">1. 低秩压缩 (Low-Rank Compression)</div>
                    <p>将输入H({seq_len}x{d_model})分别投影到Q和KV的低维潜在空间。</p>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_compress ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.C_q_prime`} data={data.mla.C_q_prime} highlight={highlight} onElementClick={onElementClick} sideLabel={true} />
                            <Matrix name={`${variantName}.C_kv`} data={data.mla.C_kv} highlight={highlight} onElementClick={onElementClick} sideLabel={true}/>
                            <Matrix name={`${variantName}.K_rope`} data={data.mla.K_rope} highlight={highlight} onElementClick={onElementClick} sideLabel={true}/>
                        </div>
                    </div>
                </div>

                <div className="attention-calculation-step">
                    <div className="step-title">2. 注意力计算 (以头 0 为例)</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_scores ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.heads.0.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.heads.0.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.heads.0.Scores`} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                        </div>
                    </div>
                    <div className="arrow-down"><BlockMath math="\xrightarrow{\text{Softmax}}" /></div>
                    <div className="viz-formula-group">
                        <div className="viz-formula-row">
                            <Matrix name={`${variantName}.heads.0.Weights`} data={headData.Weights} highlight={highlight} onElementClick={onElementClick} sideLabel={true}/>
                        </div>
                    </div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_output ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.heads.0.Weights`} data={headData.Weights} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.heads.0.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.heads.0.Output`} data={headData.Output} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>

                <div className="attention-calculation-step">
                    <div className="step-title">3. 合并与最终投影</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_final ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.combined`} data={data.mla.CombinedOutput} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.wo`} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.output`} data={data.mla.FinalOutput} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/MLANumericViz.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/MLASymbolicViz.tsx
================================================================================

// FILE: src/topics/attention-variants/components/MLASymbolicViz.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import { BlockMath, InlineMath } from 'react-katex';

interface MLASymbolicVizProps {
    dims: any;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MLASymbolicViz: React.FC<MLASymbolicVizProps> = ({ dims, highlight, onElementClick }) => {
    const variantName = 'mla';
    const { d_model, d_head, seq_len, n_q_heads, d_c, d_c_prime, d_rope } = dims;

    const break_compress_q = (d_model + d_c_prime + d_c_prime) > 8;
    const break_compress_kv = (d_model + d_c + d_c) > 8;
    const break_k_rope = (d_model + d_rope + d_rope) > 8;
    const break_scores = (d_head + d_rope + seq_len + seq_len) > 8;
    const break_output = (seq_len + d_head + d_head) > 8;
    const break_final = (n_q_heads * d_head + d_model + d_model) > 8;

    const q_head_name = `${variantName}.heads.0.Q`;
    const k_head_name = `${variantName}.heads.0.K`;
    const v_head_name = `${variantName}.heads.0.V`;
    const scores_name = `${variantName}.heads.0.Scores`;
    const weights_name = `${variantName}.heads.0.Weights`;
    const output_head_name = `${variantName}.heads.0.Output`;
    const combined_name = `${variantName}.combined`;
    const final_output_name = `${variantName}.output`;

    return (
        <>
            <div className="explanation-subsection">
                <h5>出现原因与设计思路</h5>
                <p><strong>GQA的局限:</strong> 尽管MQA和GQA在KV Cache优化方面取得了显著进展，但它们仍受限于将原始高维KV信息直接绑定到注意力头的数量。当追求更长的上下文时，即使是GQA的KV Cache仍然可能过大。</p>
                <p><strong>低秩压缩与矩阵吸收:</strong> MLA (来自DeepSeek-V2) 是一种更激进的优化。其核心思想是：</p>
                <ul>
                    <li><strong>低秩压缩KV:</strong> MLA假设Key和Value的原始高维表示中存在大量冗余，其有效信息可以被压缩到一个低维的“潜在空间”。它通过一个下投影矩阵将每个token的 <InlineMath math="d_{model}"/> 维隐藏状态投影成一个极小的共享潜在向量 <InlineMath math="\boldsymbol{c}^{KV}"/>。KV Cache只存储这些低维向量。</li>
                    <li><strong>“矩阵吸收”实现计算效率:</strong> MLA利用矩阵乘法结合律的巧妙特性，将重建K、V所需的上投影矩阵“吸收”到Query侧的计算中，从而在推理时避免K、V的显式高维重建，直接在低维潜在空间进行部分计算。</li>
                    <li><strong>解耦RoPE兼容性:</strong> 为兼容“矩阵吸收”技巧，MLA将Q、K向量解耦为<strong>内容(Content)部分</strong>和<strong>RoPE部分</strong>。内容部分采用低秩压缩；RoPE部分则独立处理，通常采用类似MQA的共享K方式。</li>
                </ul>
            </div>
            <div className="explanation-subsection">
                <h5>交互式公式推导</h5>
                <div className="attention-calculation-step">
                    <div className="step-title">1. 低秩压缩 (Low-Rank Compression)</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_compress_q ? 'vertical' : ''}`}>
                            <InteractiveSymbolicMatrix name={`${variantName}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="\times" />
                            <InteractiveSymbolicMatrix name={`${variantName}.Wc_prime`} rows={d_model} cols={d_c_prime} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="=" />
                            <InteractiveSymbolicMatrix name={`${variantName}.C_q_prime`} rows={seq_len} cols={d_c_prime} highlight={highlight} onSymbolClick={onElementClick} />
                        </div>
                    </div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_compress_kv ? 'vertical' : ''}`}>
                            <InteractiveSymbolicMatrix name={`${variantName}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="\times" />
                            <InteractiveSymbolicMatrix name={`${variantName}.Wc`} rows={d_model} cols={d_c} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="=" />
                            <InteractiveSymbolicMatrix name={`${variantName}.C_kv`} rows={seq_len} cols={d_c} highlight={highlight} onSymbolClick={onElementClick} />
                        </div>
                    </div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_k_rope ? 'vertical' : ''}`}>
                            <InteractiveSymbolicMatrix name={`${variantName}.input`} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="\times" />
                            <InteractiveSymbolicMatrix name={`${variantName}.W_k_rope`} rows={d_model} cols={d_rope} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="=" />
                            <InteractiveSymbolicMatrix name={`${variantName}.K_rope`} rows={seq_len} cols={d_rope} highlight={highlight} onSymbolClick={onElementClick} />
                        </div>
                    </div>

                    <div className="step-title">2. 重建 Q, K, V (以头 0 为例)</div>
                    <p>Q, K, V 通过上投影矩阵从低维潜在向量重建。注意K的RoPE部分直接来自输入H。</p>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row`}>
                            <InteractiveSymbolicMatrix name={q_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onElementClick} sideLabel={true}/>
                            <InteractiveSymbolicMatrix name={k_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onElementClick} sideLabel={true}/>
                            <InteractiveSymbolicMatrix name={v_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onElementClick} sideLabel={true}/>
                        </div>
                    </div>

                    <div className="step-title">3. 计算注意力分数 (头 0)</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_scores ? 'vertical' : ''}`}>
                            <InteractiveSymbolicMatrix name={q_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="\times" />
                            <InteractiveSymbolicMatrix name={k_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onElementClick} transpose={true}/>
                            <BlockMath math="=" />
                            <InteractiveSymbolicMatrix name={scores_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onElementClick} />
                        </div>
                    </div>
                    <div className="viz-formula-group">
                        <div className="arrow-down"><BlockMath math="\xrightarrow{\text{Softmax}}" /></div>
                        <div className="viz-formula-row">
                            <InteractiveSymbolicMatrix name={weights_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onElementClick} sideLabel={true}/>
                        </div>
                    </div>

                    <div className="step-title">4. 加权求和 (头 0)</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_output ? 'vertical' : ''}`}>
                            <InteractiveSymbolicMatrix name={weights_name} rows={seq_len} cols={seq_len} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="\times" />
                            <InteractiveSymbolicMatrix name={v_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="=" />
                            <InteractiveSymbolicMatrix name={output_head_name} rows={seq_len} cols={d_head} highlight={highlight} onSymbolClick={onElementClick} />
                        </div>
                    </div>

                    <div className="step-title">5. 合并与最终投影</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_final ? 'vertical' : ''}`}>
                            <InteractiveSymbolicMatrix name={combined_name} rows={seq_len} cols={n_q_heads * d_head} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="\times" />
                            <InteractiveSymbolicMatrix name={`${variantName}.wo`} rows={n_q_heads * d_head} cols={d_model} highlight={highlight} onSymbolClick={onElementClick} />
                            <BlockMath math="=" />
                            <InteractiveSymbolicMatrix name={final_output_name} rows={seq_len} cols={d_model} highlight={highlight} onSymbolClick={onElementClick} />
                        </div>
                    </div>
                </div>
            </div>
        </>
    );
};
// END OF FILE: src/topics/attention-variants/components/MLASymbolicViz.tsx



================================================================================
### 文件路径: src/topics/attention-variants/components/Viz.tsx
================================================================================

// FILE: src/topics/attention-variants/components/Viz.tsx
import React from 'react';
import { AttentionData, HighlightState, ElementIdentifier, AttentionVariantData } from '../types';
import { Matrix } from './Matrix';
import { BlockMath } from 'react-katex';
import 'katex/dist/katex.min.css';
import { MLANumericViz } from './MLANumericViz';

interface VizProps {
    data: AttentionData;
    dims: any;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    refs: React.MutableRefObject<{ [key: string]: HTMLDivElement | null }>;
}

const StandardAttentionViz: React.FC<{
    variantName: 'mha' | 'mqa' | 'gqa';
    title: string;
    variantData: AttentionVariantData;
    commonData: { input: any; Wo: any; Wq: any; Wk: any; Wv: any };
    dims: { n_q_heads: number, n_kv_heads: number, d_head: number, d_model: number, seq_len: number };
    highlight: HighlightState;
    onElementClick: VizProps['onElementClick'];
    onComponentClick: VizProps['onComponentClick'];
}> = ({ variantName, title, variantData, commonData, dims, highlight, onElementClick, onComponentClick }) => {

    const { d_model, d_head, seq_len, n_q_heads } = dims;
    const break_qkv_proj = (d_model + d_head) > 15;
    const break_scores = (d_head + seq_len) > 15;
    const break_output = (seq_len + d_head) > 15;
    const break_final = (n_q_heads * d_head + d_model) > 15;

    return (
        <div className={`attention-variant-section ${highlight.activeComponent === variantName ? 'active-component' : ''}`} id={`viz-${variantName}`}>
            <div className="component-header" onClick={() => onComponentClick(variantName)}>{title}</div>
            <div className="component-body">
                <div className="attention-calculation-step">
                    <div className="step-title">1. 生成 Q, K, V 头 (以头 0 为例)</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_qkv_proj ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.input`} data={commonData.input} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.wq.0`} data={commonData.Wq[0]} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.heads.0.Q`} data={variantData.heads[0].Q} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_qkv_proj ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.input`} data={commonData.input} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.wk.0`} data={commonData.Wk[0]} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.heads.0.K`} data={variantData.heads[0].K} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_qkv_proj ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.input`} data={commonData.input} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.wv.0`} data={commonData.Wv[0]} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.heads.0.V`} data={variantData.heads[0].V} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>
                <div className="attention-calculation-step">
                    <div className="step-title">2. 注意力计算 (以头 0 为例)</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_scores ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.heads.0.Q`} data={variantData.heads[0].Q} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.heads.0.K`} data={variantData.heads[0].K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.heads.0.Scores`} data={variantData.heads[0].Scores} highlight={highlight} onElementClick={onElementClick}/>
                        </div>
                    </div>
                    <div className="arrow-down"><BlockMath math="\xrightarrow{\text{Softmax}}" /></div>
                    <div className="viz-formula-group">
                        <div className="viz-formula-row">
                            <Matrix name={`${variantName}.heads.0.Weights`} data={variantData.heads[0].Weights} highlight={highlight} onElementClick={onElementClick}/>
                        </div>
                    </div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_output ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.heads.0.Weights`} data={variantData.heads[0].Weights} highlight={highlight} onElementClick={onElementClick}/>
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.heads.0.V`} data={variantData.heads[0].V} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.heads.0.Output`} data={variantData.heads[0].Output} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>
                <div className="attention-calculation-step">
                    <div className="step-title">3. 合并与最终投影</div>
                    <div className="viz-formula-group">
                        <div className={`viz-formula-row ${break_final ? 'vertical' : ''}`}>
                            <Matrix name={`${variantName}.combined`} data={variantData.CombinedOutput} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="\times" />
                            <Matrix name={`${variantName}.wo`} data={commonData.Wo} highlight={highlight} onElementClick={onElementClick} />
                            <BlockMath math="=" />
                            <Matrix name={`${variantName}.output`} data={variantData.FinalOutput} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};


export const Viz: React.FC<VizProps> = ({ data, dims, highlight, onElementClick, onComponentClick, refs }) => {
    const commonData = { input: data.input, Wo: data.Wo, Wq: data.Wq, Wk: data.Wk, Wv: data.Wv };

    return (
        <div>
            <div ref={el => refs.current['mha'] = el}>
                <StandardAttentionViz variantName="mha" title="MHA (Multi-Head Attention)" variantData={data.mha} commonData={commonData} dims={dims} highlight={highlight} onElementClick={onElementClick} onComponentClick={onComponentClick} />
            </div>
            <div ref={el => refs.current['gqa'] = el}>
                <StandardAttentionViz variantName="gqa" title="GQA (Grouped-Query Attention)" variantData={data.gqa} commonData={commonData} dims={dims} highlight={highlight} onElementClick={onElementClick} onComponentClick={onComponentClick} />
            </div>
            <div ref={el => refs.current['mqa'] = el}>
                <StandardAttentionViz variantName="mqa" title="MQA (Multi-Query Attention)" variantData={data.mqa} commonData={commonData} dims={dims} highlight={highlight} onElementClick={onElementClick} onComponentClick={onComponentClick} />
            </div>
            <div ref={el => refs.current['mla'] = el}>
                <MLANumericViz data={data} dims={dims} highlight={highlight} onElementClick={onElementClick} onComponentClick={onComponentClick}/>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/attention-variants/components/Viz.tsx



================================================================================
### 文件路径: src/topics/attention-variants/config/matrixNames.ts
================================================================================

// FILE: src/topics/attention-variants/config/matrixNames.ts

// This file is the single source of truth for all matrix and vector names in the Attention Variants topic.

const generateHeadNames = (base: string) => ({
    Wq: `${base}.Wq`, Wk: `${base}.Wk`, Wv: `${base}.Wv`,
    Q: `${base}.Q`, K: `${base}.K`, V: `${base}.V`,
    Scores: `${base}.Scores`,
    Weights: `${base}.Weights`,
    Output: `${base}.Output`,
});

export const matrixNames = {
    // Common Input
    input: (variant: string) => `${variant}.input`,

    // Standard Attention Variants (MHA, MQA, GQA)
    standard: (variant: 'mha' | 'mqa' | 'gqa') => ({
        wq: (headIndex: number) => `${variant}.wq.${headIndex}`,
        wk: (headIndex: number) => `${variant}.wk.${headIndex}`,
        wv: (headIndex: number) => `${variant}.wv.${headIndex}`,
        wo: `${variant}.wo`,
        combined: `${variant}.combined`,
        output: `${variant}.output`,
        head: (headIndex: number) => generateHeadNames(`${variant}.heads.${headIndex}`),
    }),

    // Multi-head Latent Attention (MLA)
    mla: {
        Wc_prime: 'mla.Wc_prime',
        Wc: 'mla.Wc',
        W_k_rope: 'mla.W_k_rope',
        W_q_rope: (headIndex: number) => `mla.W_q_rope.${headIndex}`,
        W_v_mla: (headIndex: number) => `mla.W_v_mla.${headIndex}`,
        C_q_prime: 'mla.C_q_prime',
        C_kv: 'mla.C_kv',
        K_rope: 'mla.K_rope',
        wo: 'mla.wo',
        combined: 'mla.combined',
        output: 'mla.output',
        head: (headIndex: number) => generateHeadNames(`mla.heads.${headIndex}`),
    }
};
// END OF FILE: src/topics/attention-variants/config/matrixNames.ts



================================================================================
### 文件路径: src/topics/attention-variants/hooks/useAttention.ts
================================================================================

// FILE: src/topics/attention-variants/hooks/useAttention.ts
import { useMemo } from 'react';
import { AttentionData } from '../types';
import { calculateAttentionVariants } from '../lib/attention';

// [FIXED] The Dims type here must match the one expected by calculateAttentionVariants
// It was missing the MLA-specific dimensions.
interface Dims {
    seq_len: number;
    d_model: number;
    d_head: number;
    n_q_heads: number;
    n_kv_heads: number;
    d_c: number;
    d_c_prime: number;
    d_rope: number;
}

export const useAttention = (dims: Dims): AttentionData | null => {
    return useMemo(() => {
        try {
            return calculateAttentionVariants(dims);
        } catch (e) {
            console.error("在注意力计算中发生错误:", e);
            return null;
        }
    }, [dims]);
};
// END OF FILE: src/topics/attention-variants/hooks/useAttention.ts



================================================================================
### 文件路径: src/topics/attention-variants/hooks/useHighlighting.ts
================================================================================

// FILE: src/topics/attention-variants/hooks/useHighlighting.ts
import { useMemo } from 'react';
import { HighlightState } from '../types';

export const useHighlighting = (
  name: string,
  row: number,
  col: number,
  highlight: HighlightState
) => {
  return useMemo(() => {
    const { target, sources } = highlight;

    const isTarget =
      !!target &&
      target.name === name &&
      target.row === row &&
      target.col === col;

    const isSource = sources.some(s => {
      if (s.name !== name) return false;
      if (s.highlightRow) return s.row === row;
      if (s.highlightCol) return s.col === col;
      return s.row === row && s.col === col;
    });

    return { isTarget, isSource };
  }, [name, row, col, highlight]);
};

// END OF FILE: src/topics/attention-variants/hooks/useHighlighting.ts



================================================================================
### 文件路径: src/topics/attention-variants/lib/attention.ts
================================================================================

// FILE: src/topics/attention-variants/lib/attention.ts
import { AttentionData, AttentionVariantData, Matrix, Vector, MLAData } from '../types';

// ----------------- 辅助数学函数 -----------------

const createMatrix = (rows: number, cols: number, seed: number): Matrix => {
    const random = createSeededRandom(seed);
    return Array.from({ length: rows }, () => Array.from({ length: cols }, () => parseFloat(random().toFixed(2))));
};

const createSeededRandom = (seed: number) => {
    let state = seed;
    return () => {
        state = (state * 9301 + 49297) % 233280;
        return (state / 233280.0) * 2 - 1;
    };
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
    const rowsA = A.length, colsA = A[0].length, colsB = B[0].length;
    const C: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));
    for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
            let sum = 0;
            for (let k = 0; k < colsA; k++) {
                sum += A[i][k] * B[k][j];
            }
            C[i][j] = sum;
        }
    }
    return C;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => A.map(row => row.map(val => val * scalar));

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row);
        const exps = row.map(val => Math.exp(val - maxVal));
        const sumExps = exps.reduce((a, b) => a + b, 0);
        return exps.map(exp => exp / sumExps);
    });
};

const concatMatricesHorizontally = (...matrices: Matrix[]): Matrix => {
    const numRows = matrices[0].length;
    const result: Matrix = Array(numRows).fill(0).map(() => []);
    for (let i = 0; i < numRows; i++) {
        for (const matrix of matrices) {
            result[i].push(...matrix[i]);
        }
    }
    return result;
};

// ----------------- 核心计算逻辑 -----------------

interface Dims {
    seq_len: number;
    d_model: number;
    d_head: number;
    n_q_heads: number;
    n_kv_heads: number;
    d_c: number;
    d_c_prime: number;
    d_rope: number;
}

function calculateAttention(input: Matrix, Wq: Matrix[], Wk: Matrix[], Wv: Matrix[], Wo: Matrix, dims: Dims, n_kv_heads_variant: number): AttentionVariantData {
    const { seq_len, d_head, n_q_heads } = dims;
    const q_heads_per_kv = n_q_heads / n_kv_heads_variant;

    const Q_proj = concatMatricesHorizontally(...Wq.map(wq => multiplyMatrices(input, wq)));
    const K_proj = concatMatricesHorizontally(...Wk.slice(0, n_kv_heads_variant).map(wk => multiplyMatrices(input, wk)));
    const V_proj = concatMatricesHorizontally(...Wv.slice(0, n_kv_heads_variant).map(wv => multiplyMatrices(input, wv)));

    const heads = [];
    for (let i = 0; i < n_q_heads; i++) {
        const q_head = Q_proj.map(row => row.slice(i * d_head, (i + 1) * d_head));

        const kv_group_index = Math.floor(i / q_heads_per_kv);
        const k_head = K_proj.map(row => row.slice(kv_group_index * d_head, (kv_group_index + 1) * d_head));
        const v_head = V_proj.map(row => row.slice(kv_group_index * d_head, (kv_group_index + 1) * d_head));

        const k_head_T = k_head[0].map((_, colIndex) => k_head.map(row => row[colIndex]));

        const scores = scaleMatrix(multiplyMatrices(q_head, k_head_T), 1 / Math.sqrt(d_head));
        const weights = softmaxByRow(scores);
        const output = multiplyMatrices(weights, v_head);

        heads.push({ Q: q_head, K: k_head, V: v_head, Scores: scores, Weights: weights, Output: output });
    }

    const CombinedOutput = concatMatricesHorizontally(...heads.map(h => h.Output));
    const FinalOutput = multiplyMatrices(CombinedOutput, Wo);

    return { Q_proj, K_proj, V_proj, heads, CombinedOutput, FinalOutput };
}

function calculateMLA(input: Matrix, Wo: Matrix, Wc: Matrix, Wc_prime: Matrix, W_k_rope: Matrix, W_q_rope: Matrix[], W_v_mla: Matrix[], Wk: Matrix[], Wq: Matrix[], dims: Dims): MLAData {
    const { seq_len, d_head, n_q_heads, d_c, d_c_prime, d_rope } = dims;

    const C_q_prime = multiplyMatrices(input, Wc_prime);
    const C_kv = multiplyMatrices(input, Wc);
    const K_rope = multiplyMatrices(input, W_k_rope); // RoPE part from original input

    const heads = [];
    for(let i=0; i < n_q_heads; i++) {
        // Reconstruct Q, K, V from latent vectors
        const Q_content = multiplyMatrices(C_q_prime, Wq[i]);
        const Q_rope = multiplyMatrices(C_q_prime, W_q_rope[i]);
        const Q = concatMatricesHorizontally(Q_content, Q_rope);

        const K_content = multiplyMatrices(C_kv, Wk[i]);
        const K = concatMatricesHorizontally(K_content, K_rope);

        const V = multiplyMatrices(C_kv, W_v_mla[i]);

        const K_T = K[0].map((_, colIndex) => K.map(row => row[colIndex]));

        const scores = scaleMatrix(multiplyMatrices(Q, K_T), 1 / Math.sqrt(d_head + d_rope));
        const weights = softmaxByRow(scores);
        const output = multiplyMatrices(weights, V);
        heads.push({ Q, K, V, Scores: scores, Weights: weights, Output: output });
    }
    const CombinedOutput = concatMatricesHorizontally(...heads.map(h => h.Output));
    const FinalOutput = multiplyMatrices(CombinedOutput, Wo);

    return { C_q_prime, C_kv, K_rope, heads, CombinedOutput, FinalOutput };
}


export const calculateAttentionVariants = (dims: Dims): AttentionData | null => {
    const { seq_len, d_model, d_head, n_q_heads, n_kv_heads, d_c, d_c_prime, d_rope } = dims;

    if (d_model !== n_q_heads * d_head) return null;

    const input = createMatrix(seq_len, d_model, 1);
    const Wq = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_model, d_head, 10 + i));
    const Wk = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_model, d_head, 100 + i));
    const Wv = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_model, d_head, 200 + i));
    const Wo = createMatrix(d_model, d_model, 999);

    const mha = calculateAttention(input, Wq, Wk, Wv, Wo, dims, n_q_heads);
    const mqa = calculateAttention(input, Wq, Wk, Wv, Wo, dims, 1);
    const gqa = calculateAttention(input, Wq, Wk, Wv, Wo, dims, n_kv_heads);

    // MLA specific weights
    const Wc = createMatrix(d_model, d_c, 300);
    const Wc_prime = createMatrix(d_model, d_c_prime, 400);
    const W_k_rope = createMatrix(d_model, d_rope, 500);
    const W_q_rope = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_c_prime, d_rope, 600 + i));
    const W_v_mla = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_c, d_head, 700 + i));
    // Re-using Wq and Wk for content projection part of MLA
    const Wq_mla = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_c_prime, d_head, 800 + i));
    const Wk_mla = Array.from({ length: n_q_heads }, (_, i) => createMatrix(d_c, d_head, 900 + i));
    // Re-using Wo for final projection
    const Wo_mla = createMatrix(n_q_heads * d_head, d_model, 1000);

    const mla = calculateMLA(input, Wo_mla, Wc, Wc_prime, W_k_rope, W_q_rope, W_v_mla, Wk_mla, Wq_mla, dims);


    return { input, Wq, Wk, Wv, Wo, Wc, Wc_prime, W_k_rope, W_q_rope, W_v_mla, mha, mqa, gqa, mla };
};
// END OF FILE: src/topics/attention-variants/lib/attention.ts



================================================================================
### 文件路径: src/topics/attention-variants/lib/symbolMapping.ts
================================================================================

// FILE: src/topics/attention-variants/lib/symbolMapping.ts
interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

export const getSymbolParts = (name: string): SymbolParts => {
    const parts = name.split('.');
    const variant = parts[0] as 'mha' | 'mqa' | 'gqa' | 'mla';
    const conceptualName = parts[parts.length - 1];

    let base: string;
    let superscript: string | undefined;
    let newSubscripts: (string | number)[] = [];

    // Base symbol mapping
    const baseMap: { [key: string]: string } = {
        'input': 'H',
        'wo': 'W', 'Wc': 'W', 'Wc_prime': 'W', 'W_k_rope': 'W',
        'combined': 'H_{cat}',
        'output': 'Z',
        'Q': 'Q', 'K': 'K', 'V': 'V',
        'Scores': 'S', 'Weights': 'A', 'Output': 'H',
        'C_q_prime': 'C', 'C_kv': 'C', 'K_rope': 'K'
    };

    // Default or mapped base
    base = baseMap[conceptualName] || `W_{${conceptualName}}`;

    // Handle existing subscripts in base
    const baseMatch = base.match(/([A-Za-z]+)_\{(.*)\}/);
    if (baseMatch) {
        base = baseMatch[1];
        newSubscripts.push(baseMatch[2]);
    }

    // Handle weight matrices like 'gqa.wq.0' or 'mha.wo'
    if (parts[1] && parts[1].startsWith('w') || conceptualName.startsWith('W_')) {
        base = 'W';
        if (parts[1] === 'wq' || parts[1] === 'wk' || parts[1] === 'wv' || parts[1] === 'W_q_rope' || parts[1] === 'W_v_mla') {
            superscript = conceptualName.includes('q') ? 'Q' : (conceptualName.includes('k') ? 'K' : 'V');
            if(parts[1] === 'W_q_rope') newSubscripts.push('qr');
            if(parts[1] === 'W_v_mla') newSubscripts.push('v');
            if (parts[2]) newSubscripts.push(parts[2]);
        } else if (conceptualName === 'Wc') {
            newSubscripts.push('c');
        } else if (conceptualName === 'Wc_prime') {
            superscript = "'";
            newSubscripts.push('c');
        } else if (conceptualName === 'W_k_rope') {
            newSubscripts.push('kr');
        } else { // wo
            superscript = 'O';
        }
    }

    if(conceptualName === 'C_q_prime') superscript = "'";
    if(conceptualName === 'C_kv') newSubscripts.push('kv');
    if(conceptualName === 'K_rope') newSubscripts.push('rope');


    // Handle head-specific matrices
    if (parts.length === 4 && parts[1] === 'heads') {
        const headIndex = parts[2];
        newSubscripts.push(headIndex);
    }

    // Add variant subscript for final output
    if (conceptualName === 'output') {
        newSubscripts.push(variant.toUpperCase());
    }

    const subscript = newSubscripts.length > 0 ? newSubscripts.join(',') : undefined;

    return { base, superscript, subscript };
};
// END OF FILE: src/topics/attention-variants/lib/symbolMapping.ts



================================================================================
### 文件路径: src/topics/attention-variants/lib/tracing.ts
================================================================================

// FILE: src/topics/attention-variants/lib/tracing.ts
import { TooltipState } from '../../../components/CalculationTooltip/types';
import { HighlightState, ElementIdentifier, AttentionData, HighlightSource, AttentionVariantData } from '../types';
import { getSymbolParts } from './symbolMapping';

const getMatrixByName = (name: string, data: AttentionData): number[][] | undefined => {
    const parts = name.split('.');
    if (parts.length === 0) return undefined;

    const variant = parts[0] as 'mha' | 'mqa' | 'gqa' | 'mla';
    const component = parts[1];
    const conceptualName = parts[parts.length - 1];

    const headIndexMatch = name.match(/heads\.(\d+)/);
    const headIndex = headIndexMatch ? parseInt(headIndexMatch[1], 10) : 0;

    if (name === `${variant}.input`) return data.input;

    // Handle MLA-specific matrices first
    if(variant === 'mla') {
        const mlaData = data.mla;
        if(name === 'mla.C_q_prime') return mlaData.C_q_prime;
        if(name === 'mla.C_kv') return mlaData.C_kv;
        if(name === 'mla.K_rope') return mlaData.K_rope;
        if(name === 'mla.Wc') return data.Wc;
        if(name === 'mla.Wc_prime') return data.Wc_prime;
        if(name === 'mla.W_k_rope') return data.W_k_rope;
        if(component === 'W_q_rope') return data.W_q_rope[headIndex];
        if(component === 'W_v_mla') return data.W_v_mla[headIndex];
        if(name === 'mla.output') return mlaData.FinalOutput;
        if(name === 'mla.combined') return mlaData.CombinedOutput;
        if(name === 'mla.wo') return data.Wo; // Assume shared Wo for simplicity for now
        if (component === 'heads') {
            const headData = mlaData.heads[headIndex];
            if (!headData) return undefined;
            return headData[conceptualName as keyof typeof headData] as number[][] | undefined;
        }
    }

    if (variant !== 'mha' && variant !== 'gqa' && variant !== 'mqa') return undefined;
    const variantData = data[variant] as AttentionVariantData;
    if (!variantData) return undefined;

    if (component === 'heads') {
        const headData = variantData.heads[headIndex];
        if (!headData) return undefined;
        return headData[conceptualName as keyof typeof headData] as number[][] | undefined;
    }

    if (conceptualName === 'wo') return data.Wo;
    if (conceptualName === 'combined') return variantData.CombinedOutput;
    if (conceptualName === 'output') return variantData.FinalOutput;

    if(component?.startsWith('w')) {
        const type = component.charAt(1);
        const index = parseInt(parts[2] || '0', 10);
        if (type === 'q') return data.Wq[index];
        if (type === 'k') return data.Wk[index];
        if (type === 'v') return data.Wv[index];
    }

    return undefined;
};


export const generateTooltipData = (element: ElementIdentifier, data: AttentionData, sources: HighlightSource[]): TooltipState | null => {
    const { name, row, col } = element;
    let opType: TooltipState['opType'] = 'info';
    let steps: TooltipState['steps'] = [];

    const targetMatrix = getMatrixByName(name, data);
    if (!targetMatrix || targetMatrix[row]?.[col] === undefined) return null;
    const targetValue = targetMatrix[row][col];

    const conceptualName = name.split('.').pop() || '';

    if (['output', 'combined', 'Q', 'K', 'V', 'Scores', 'Output', 'C_q_prime', 'C_kv', 'K_rope'].includes(conceptualName)) {
        opType = 'matmul';
        const sourceRow = sources.find(s => s.highlightRow);
        const sourceCol = sources.find(s => s.highlightCol);

        if (sourceRow && sourceCol) {
            const matrixA = getMatrixByName(sourceRow.name, data);
            const matrixB = getMatrixByName(sourceCol.name, data);

            if (matrixA && matrixB) {
                const vecA = matrixA[sourceRow.row];
                const vecB = matrixB.map(r => r[sourceCol.col]);

                let aSources, bSources;

                // Handle 'combined' output by splitting the source row vector
                if (sourceRow.name.endsWith('.combined')) {
                    const numHeads = data[element.variant].heads.length;
                    const d_head = matrixA[0].length / numHeads;
                    aSources = [];
                    for (let i = 0; i < numHeads; i++) {
                        const headOutputName = `${element.variant}.heads.${i}.Output`;
                        aSources.push({
                            data: vecA.slice(i * d_head, (i + 1) * d_head),
                            symbolInfo: getSymbolParts(headOutputName)
                        });
                    }
                } else {
                    aSources = [{ data: vecA, symbolInfo: getSymbolParts(sourceRow.name) }];
                }

                bSources = [{ data: vecB, symbolInfo: getSymbolParts(sourceCol.name) }];

                steps.push({
                    a: vecA, b: vecB, op: '·', result: targetValue,
                    aSources, bSources,
                    aSymbolInfo: getSymbolParts(sourceRow.name),
                    bSymbolInfo: getSymbolParts(sourceCol.name)
                });
            }
        }
    } else if (conceptualName === 'Weights') {
        opType = 'softmax';
        const scoresSource = sources.find(s => s.name.endsWith('.Scores'));
        if(scoresSource){
            const matrixA = getMatrixByName(scoresSource.name, data);
            if(matrixA) {
                const vecA = matrixA[row];
                steps.push({
                    a: vecA, b: [], op: 'softmax', result: targetValue,
                    aSymbolInfo: getSymbolParts(scoresSource.name), bSymbolInfo: { base: '' },
                    aLabel: 'Scores', resultLabel: 'Weights'
                });
            }
        }
    }

    if (steps.length === 0) {
        opType = 'info';
        steps.push({
            a: [], b: [], op: '', result: targetValue,
            aSymbolInfo: {base: 'Info'}, bSymbolInfo: {base: ''},
            title: 'This value is a direct weight or was generated by a complex operation not yet visualizable (e.g., MLA Q/K/V reconstruction).'
        });
    }

    const symbol = getSymbolParts(name);
    element.symbol = `${symbol.base}${symbol.subscript ? `_{${symbol.subscript}}` : ''}${symbol.superscript ? `^{${symbol.superscript}}` : ''}`;

    return { target: element, opType, steps, title: `Calculation for ${element.symbol}[${row},${col}]` };
};

export const createBackwardHighlight = (element: ElementIdentifier, data: AttentionData, dims: any): HighlightState => {
    const { variant, name, row, col, isInternal } = element;
    const sources: HighlightSource[] = [];

    const conceptualName = name.split('.').pop() || '';
    const headIndexMatch = name.match(/heads\.(\d+)/);
    const headIndex = headIndexMatch ? parseInt(headIndexMatch[1], 10) : 0;

    if (isInternal) {
        const baseName = name.replace('.internal', '');
        const baseElementName = `${baseName.split('.')[0]}.heads.${headIndex}.Scores`;
        if (col === -1) {
            sources.push({ ...element, name: baseElementName, row: row, col: -1, highlightRow: true, isInternal: true });
        } else {
            sources.push({ ...element, name: `${baseName.split('.')[0]}.heads.${headIndex}.Scores`, row: row, col: col, isInternal: true });
        }
        return { target: element, sources: sources, activeComponent: null };
    }

    if(variant === 'mla') {
        if(conceptualName === 'output') { sources.push({ variant, name: 'mla.combined', row, col: -1, highlightRow: true}); sources.push({ variant, name: 'mla.wo', row: -1, col, highlightCol: true}); }
        else if (conceptualName === 'combined') { const headIdx = Math.floor(col / dims.d_head); sources.push({variant, name: `mla.heads.${headIdx}.Output`, row, col: col % dims.d_head});}
        else if (conceptualName === 'Output') { sources.push({variant, name: `mla.heads.${headIndex}.Weights`, row, col: -1, highlightRow: true}); sources.push({variant, name: `mla.heads.${headIndex}.V`, row: -1, col, highlightCol: true});}
        else if (conceptualName === 'Weights') { sources.push({variant, name: `mla.heads.${headIndex}.Scores`, row, col: -1, highlightRow: true});}
        else if (conceptualName === 'Scores') { sources.push({variant, name: `mla.heads.${headIndex}.Q`, row, col: -1, highlightRow: true}); sources.push({variant, name: `mla.heads.${headIndex}.K`, row: col, col: -1, highlightRow: true});}
        else if (conceptualName === 'Q') { sources.push({variant, name: 'mla.C_q_prime', row, col: -1, highlightRow: true}); /* TODO: Trace to Wq_c and Wq_r */}
        else if (conceptualName === 'K') { sources.push({variant, name: 'mla.C_kv', row, col: -1, highlightRow: true}); sources.push({variant, name: 'mla.K_rope', row, col: -1, highlightRow: true}); /* TODO: Trace to Wk_c and Wk_r */}
        else if (conceptualName === 'V') { sources.push({variant, name: 'mla.C_kv', row, col: -1, highlightRow: true}); sources.push({variant, name: `mla.W_v_mla.${headIndex}`, row: -1, col, highlightCol: true});}
        else if (conceptualName === 'C_q_prime') { sources.push({variant, name: 'mla.input', row, col: -1, highlightRow: true}); sources.push({variant, name: 'mla.Wc_prime', row: -1, col, highlightCol: true});}
        else if (conceptualName === 'C_kv') { sources.push({variant, name: 'mla.input', row, col: -1, highlightRow: true}); sources.push({variant, name: 'mla.Wc', row: -1, col, highlightCol: true});}
        else if (conceptualName === 'K_rope') { sources.push({variant, name: 'mla.input', row, col: -1, highlightRow: true}); sources.push({variant, name: 'mla.W_k_rope', row: -1, col, highlightCol: true});}
    } else {
        if (conceptualName === 'output') {
            sources.push({ ...element, variant, name: `${variant}.combined`, row: row, col: -1, highlightRow: true });
            sources.push({ ...element, variant, name: `${variant}.wo`, row: -1, col: col, highlightCol: true });
        }
        else if (conceptualName === 'combined') {
            const d_head = data.mha.heads[0].Output[0].length;
            const headIndexForCol = Math.floor(col / d_head);
            sources.push({ ...element, name: `${variant}.heads.${headIndexForCol}.Output`, row: row, col: col % d_head });
        }
        else if (conceptualName === 'Output') {
            sources.push({ ...element, name: `${variant}.heads.${headIndex}.Weights`, row: row, col: -1, highlightRow: true });
            sources.push({ ...element, name: `${variant}.heads.${headIndex}.V`, row: -1, col: col, highlightCol: true });
        }
        else if (conceptualName === 'Weights') {
            sources.push({ ...element, name: `${variant}.heads.${headIndex}.Scores`, row: row, col: -1, highlightRow: true });
        }
        else if (conceptualName === 'Scores') {
            sources.push({ ...element, name: `${variant}.heads.${headIndex}.Q`, row: row, col: -1, highlightRow: true });
            sources.push({ ...element, name: `${variant}.heads.${headIndex}.K`, row: col, col: -1, highlightRow: true }); // [FIXED] K's row is the target's col
        }
        else if (['Q', 'K', 'V'].includes(conceptualName)) {
            const type = conceptualName.toLowerCase() as 'q' | 'k' | 'v';
            let weightIndex = 0;
            const q_heads_per_kv = dims.n_q_heads / dims.n_kv_heads;

            if (type === 'q') {
                weightIndex = headIndex;
            } else { // K or V
                if (variant === 'mha') weightIndex = headIndex;
                else if (variant === 'gqa') weightIndex = Math.floor(headIndex / q_heads_per_kv);
            }

            sources.push({ ...element, name: `${variant}.input`, row: row, col: -1, highlightRow: true });
            sources.push({ ...element, name: `${variant}.w${type}.${weightIndex}`, row: -1, col: col, highlightCol: true });
        }
    }

    return { target: element, sources };
};
// END OF FILE: src/topics/attention-variants/lib/tracing.ts



================================================================================
### 文件路径: src/topics/attention-variants/types.ts
================================================================================

// FILE: src/topics/attention-variants/types.ts
import { SymbolInfo as GenericSymbolInfo } from '../../components/visualizers/types';
import { ElementIdentifier as GenericElementIdentifier, CalculationComponent as GenericCalculationComponent } from '../../components/CalculationTooltip/types';

// 该文件为注意力变体专题定义了所有必要的类型
export type SymbolInfo = GenericSymbolInfo;
export type Matrix = number[][];
export type Vector = number[];
export type CalculationComponent = GenericCalculationComponent;


// 用于标识被点击的元素, 继承自通用的 ElementIdentifier
export interface ElementIdentifier extends GenericElementIdentifier {
    variant: 'mha' | 'mqa' | 'gqa' | 'mla'; // 所属的注意力变体
}

// 用于定义高亮的来源
export interface HighlightSource extends ElementIdentifier {
    highlightRow?: boolean;
    highlightCol?: boolean;
}

// 全局高亮状态
export interface HighlightState {
    target: ElementIdentifier | null;
    sources: HighlightSource[];
    activeComponent?: string | null; // e.g., "mha", "gqa"
}

// 单个注意力头的计算结果
export interface AttentionHeadData {
    Q: Matrix;
    K: Matrix;
    V: Matrix;
    Scores: Matrix;
    Weights: Matrix;
    Output: Matrix;
}

// MHA, MQA, GQA 的计算结果结构
export interface AttentionVariantData {
    Q_proj: Matrix;
    K_proj: Matrix;
    V_proj: Matrix;
    heads: AttentionHeadData[];
    CombinedOutput: Matrix;
    FinalOutput: Matrix;
}

// MLA 的特定计算结果结构
export interface MLAData {
    C_q_prime: Matrix;
    C_kv: Matrix;
    K_rope: Matrix;
    heads: AttentionHeadData[];
    CombinedOutput: Matrix;
    FinalOutput: Matrix;
}

// 包含所有注意力变体计算结果的总数据结构
export interface AttentionData {
    input: Matrix;
    // Standard weights
    Wq: Matrix[]; // N_q_heads 个 Wq 矩阵
    Wk: Matrix[]; // N_kv_heads 个 Wk 矩阵
    Wv: Matrix[]; // N_kv_heads 个 Wv 矩阵
    Wo: Matrix;
    // MLA specific weights
    Wc: Matrix;
    Wc_prime: Matrix;
    W_k_rope: Matrix;
    W_q_rope: Matrix[];
    W_v_mla: Matrix[];
    // Attention variant results
    mha: AttentionVariantData;
    mqa: AttentionVariantData;
    gqa: AttentionVariantData;
    mla: MLAData;
}
// END OF FILE: src/topics/attention-variants/types.ts



================================================================================
### 文件路径: src/topics/attention-variants/utils/matrixView.ts
================================================================================

// FILE: src/topics/attention-variants/utils/matrixView.ts
export const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12;

export const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {

  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }

  const visible = new Set<number>();

  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }

  // [NEW] Also include the middle index when there's no specific focus
  if (focusIndex === -1 && totalSize >= MIN_SIZE_FOR_TRUNCATION) {
    visible.add(Math.floor((totalSize - 1) / 2));
  }

  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }

  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];

  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }

  return result;
};
// END OF FILE: src/topics/attention-variants/utils/matrixView.ts



================================================================================
### 文件路径: src/topics/index.tsx
================================================================================

// FILE: src/topics/index.tsx
import React from 'react'; // 必须导入 React 才能使用 React.FC
import { TransformerExplorerTopic } from './transformer-explorer/TransformerExplorerTopic';
import { AttentionVariantsTopic } from './attention-variants/AttentionVariantsTopic';

export interface Topic {
    id: string;
    title: string;
    description: string;
    date: string;
    tags: string[];
    component: React.FC;
}

export const topics: Topic[] = [
    {
        id: 'attention-variants',
        title: '多头注意力变体: 从MHA, MQA, GQA到MLA',
        description: '通过交互式图表，深入探讨注意力机制从Multi-Head到Multi-head Latent的演进过程，直观理解其设计理念以及对KV Cache效率和性能的影响。',
        date: '2025年9月7日',
        tags: ['Attention', 'LLM', 'GQA', 'MLA', 'Visualization'],
        component: AttentionVariantsTopic,
    },
    {
        id: 'transformer-explorer',
        title: 'Transformer 深度探索器',
        description: '一个完全交互式的可视化工具，带您深入探索Transformer模型内部的数据流动、矩阵变换和数学原理。点击任何数字，追溯它的计算来源。',
        date: '2025年9月6日',
        tags: ['Transformer', 'Visualization', 'Interactive', 'PyTorch'],
        component: TransformerExplorerTopic,
    },
    // 未来可以在这里添加更多专题...
];

// [最终修复] 即使已有其他 export 语句，在 .tsx 文件中再添加一个空的 export
// 是最明确、最可靠地将其标记为模块的方式，可以彻底解决 TS1208 错误。
export {};

// END OF FILE: src/topics/index.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/AddNorm.tsx
================================================================================

// FILE: src/components/AddNorm.tsx
import React from 'react';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { ResidualBlock } from './ResidualBlock';

interface AddNormProps {
    residualInput: MatrixType; // [MODIFIED] Pass the full residual input matrix
    residualInputName: string; // [MODIFIED] Name of the residual input matrix
    inputSublayer: MatrixType;
    output: MatrixType;
    sublayerMatrixName: string;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    activeId: string;
    residualId: string;
    residualMatrixSymbol: string;
    residualMatrixDims: string;
}

export const AddNorm: React.FC<AddNormProps> = ({
    residualInput,
    residualInputName,
    inputSublayer,
    output,
    sublayerMatrixName,
    outputMatrixName,
    highlight,
    onElementClick,
    onComponentClick,
    activeId,
    residualId,
    residualMatrixSymbol,
    residualMatrixDims,
}) => {
    const isActive = highlight.activeComponent === activeId;

    return (
         <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick(activeId)}>Add & LayerNorm</div>
            <div className="component-body add-norm-component-body">
                <div className="add-norm-inputs">
                    {/* [MODIFIED] Show the full matrix for the residual connection */}
                    <Matrix name={residualInputName} data={residualInput} highlight={highlight} onElementClick={onElementClick} />
                    <ResidualBlock
                        id={residualId}
                        type="end"
                        highlight={highlight}
                        onElementClick={(el, e) => onElementClick(el, e)}
                        matrixSymbol={residualMatrixSymbol}
                        matrixDims={residualMatrixDims}
                    />
                    <div className="op-symbol">+</div>
                    <Matrix name={sublayerMatrixName} data={inputSublayer} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down"><InlineMath math="\xrightarrow{\text{LayerNorm}}" /></div>

                <Matrix name={outputMatrixName} data={output} highlight={highlight} onElementClick={onElementClick} />
            </div>
        </div>
    );
};
// END OF FILE: src/components/AddNorm.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/AnimationPanel.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/AnimationPanel.tsx
import React, { useRef } from 'react';
import { TooltipState } from '../../../components/CalculationTooltip/types';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';
import { InteractiveMatMulVisualizer } from '../../../components/visualizers/InteractiveMatMulVisualizer';
import { SoftmaxVisualizer } from '../../../components/visualizers/SoftmaxVisualizer';
import { ActivationFunctionVisualizer } from '../../../components/visualizers/ActivationFunctionVisualizer';
import { ElementWiseOpVisualizer } from '../../../components/visualizers/ElementWiseOpVisualizer';
import { LayerNormVisualizer } from '../../../components/visualizers/LayerNormVisualizer';
import { WxPlusBVisualizer } from '../../../components/visualizers/WxPlusBVisualizer';
import { getSymbolParts } from '../lib/symbolMapping';
import '../../../components/CalculationTooltip/CalculationTooltip.css';
import {InlineMath} from "react-katex";

interface AnimationPanelProps {
    animationData: TooltipState | null;
    onClose: () => void;
}

export const AnimationPanel: React.FC<AnimationPanelProps> = ({ animationData, onClose }) => {
    const panelRef = useRef<HTMLDivElement>(null);

    const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
        x: 100,
        y: 100,
        width: 900,
        height: 650,
    }, panelRef);

    if (!animationData) {
        return null;
    }

    const styles: { [key: string]: React.CSSProperties } = {
        panel: {
            top: position.y,
            left: position.x,
            width: size.width,
            height: size.height,
            zIndex: 1010,
        },
        panelHeader: {
            backgroundColor: '#f0f8ff',
            borderBottom: '1px solid #cce5ff',
        },
        panelTitle: {
            color: '#004085',
        },
        panelContentWrapper: {
            flexGrow: 1,
            overflowY: 'auto',
            padding: '10px',
            backgroundColor: '#ffffff',
        },
        visualizerContainer: {
            height: '100%',
        },
        visualizerRoot: {
            border: 'none',
            boxShadow: 'none',
            width: '100%',
            height: '100%',
            boxSizing: 'border-box',
        },
    };

    const renderVisualizer = () => {
        const step = animationData.steps[0];
        const op = step.op === '·' ? '×' : step.op;

        // [MODIFIED] Specific handling for 'wx-plus-b'
        if (animationData.opType === 'wx-plus-b' && animationData.steps.length === 2) {
            const matmulStep = animationData.steps[0];
            const addStep = animationData.steps[1];
            return <WxPlusBVisualizer
                sourceVectorsA={matmulStep.aSources!}
                sourceVectorB={matmulStep.bSources![0]}
                biasVector={addStep.bSources![0]}
                resultSymbolInfo={getSymbolParts(animationData.target.name)}
            />;
        }


        switch (animationData.opType) {
            case 'matmul':
                const matmulStep = animationData.steps.find(s => s.op === '·' || s.op === '×') || step;
                return <InteractiveMatMulVisualizer
                    sourceVectorsA={matmulStep.aSources!}
                    sourceVectorB={matmulStep.bSources![0]}
                    resultSymbolInfo={getSymbolParts(animationData.target.name)}
                    operation={op as '×' | '+'}
                />;
            case 'add':
                const addStep = animationData.steps.find(s => s.op === '+') || step;
                return <ElementWiseOpVisualizer
                    matrixA={[addStep.a]}
                    matrixB={[addStep.b]}
                    operation="+"
                    labelA={addStep.aLabel || addStep.aSymbolInfo.base}
                    labelB={addStep.bLabel || addStep.bSymbolInfo.base}
                    labelC={addStep.resultLabel || 'Sum'}
                />;
            case 'layernorm':
                return <LayerNormVisualizer
                    inputVector={step.a}
                    inputLabel={step.aLabel}
                    outputLabel={step.resultLabel}
                />;
            case 'softmax':
                return <SoftmaxVisualizer
                    inputVector={step.a}
                    inputLabel={step.aLabel}
                    outputLabel={step.resultLabel}
                />;
            case 'relu':
                return <ActivationFunctionVisualizer
                    functionType="relu"
                    inputVector={step.a}
                    inputLabel={step.aLabel}
                    outputLabel={step.resultLabel}
                />;
            default:
                return <div style={{ padding: '20px' }}>此操作类型没有可用的动画。</div>;
        }
    };

    return (
        <div ref={panelRef} style={styles.panel} className="animation-panel resizable-panel">
            <div className="panel-header" {...dragHandleProps} style={styles.panelHeader}>
                <span className="panel-title" style={styles.panelTitle}>
                     <InlineMath>{`Calculation for ${animationData.target.symbol || ''}[${animationData.target.row},${animationData.target.col}]`}</InlineMath>
                </span>
                <button onClick={onClose} className="tooltip-close-btn">&times;</button>
            </div>
            <div className="panel-content-wrapper" style={styles.panelContentWrapper}>
                <div style={styles.visualizerContainer}>
                    <div style={styles.visualizerRoot}>
                        {renderVisualizer()}
                    </div>
                </div>
            </div>
            <div className="resize-handle br" {...resizeHandleProps.br}></div>
            <div className="resize-handle t" {...resizeHandleProps.t}></div>
            <div className="resize-handle r" {...resizeHandleProps.r}></div>
            <div className="resize-handle b" {...resizeHandleProps.b}></div>
            <div className="resize-handle l" {...resizeHandleProps.l}></div>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/AnimationPanel.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/Controls.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/Controls.tsx
import React, { useState, useRef } from 'react';
import { useDraggableAndResizable } from '../../../hooks/useDraggableAndResizable';

interface ControlsProps {
  dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
  setDims: (dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number }) => void;
  inputText: string;
  setInputText: (text: string) => void;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims, inputText, setInputText }) => {
  const [isCollapsed, setIsCollapsed] = useState(true);
  const panelRef = useRef<HTMLDivElement>(null); // Create a ref
  const { position, size, dragHandleProps, resizeHandleProps } = useDraggableAndResizable({
    x: window.innerWidth - 450, // Initial position top-right
    y: 90,
    width: 420,
    height: 300,
  }, panelRef); // Pass the ref to the hook


  const handleDimChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    let newDims = { ...dims, [id]: parseInt(value, 10) || 1 };

    if (id === 'h') {
        if (newDims.d_model % newDims.h !== 0) {
             newDims.d_model = Math.max(newDims.h, Math.ceil(newDims.d_model / newDims.h) * newDims.h);
        }
    }
    if (id === 'd_model') {
         if (newDims.d_model % newDims.h !== 0) {
             let best_h = 1;
             for (let i = 1; i <= newDims.d_model; i++) {
                 if (newDims.d_model % i === 0) {
                    if (Math.abs(i - newDims.h) < Math.abs(best_h - newDims.h)) {
                       best_h = i;
                    }
                 }
             }
             newDims.h = best_h;
         }
    }

    if(id === 'd_model') {
        newDims.d_ff = newDims.d_model * 4;
    }

    setDims(newDims);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      setInputText(e.target.value);
  }

  const d_k = dims.d_model % dims.h === 0 ? dims.d_model / dims.h : 'N/A';

  const panelStyle: React.CSSProperties = {
    position: 'absolute', // Changed from fixed to absolute
    top: position.y,
    left: position.x,
    width: isCollapsed ? 50 : size.width,
    height: isCollapsed ? 50 : size.height,
  };

  return (
    <div ref={panelRef} style={panelStyle} className={`controls-panel ${isCollapsed ? 'collapsed' : ''} resizable-panel`}>
      <div className="panel-header" {...dragHandleProps}>
        <button className="panel-toggle-btn" onClick={() => setIsCollapsed(!isCollapsed)}>
          {isCollapsed ? '⚙️' : '×'}
        </button>
        {!isCollapsed && <span className="panel-title">Controls</span>}
      </div>
      {!isCollapsed && (
          <div className="controls-container">
            <div className="control-group">
              <label htmlFor="inputText">输入文本 (Encoder Input)</label>
              <input type="text" id="inputText" value={inputText} onChange={handleInputChange} />
            </div>
            <div className="control-group">
              <label htmlFor="seq_len">解码器长度 (Decoder Len)</label>
              <input type="number" id="seq_len" value={dims.seq_len} onChange={handleDimChange} min="1" max="4" />
            </div>
            <div className="control-group">
              <label htmlFor="d_model">模型维度 (d_model)</label>
              <input type="number" id="d_model" value={dims.d_model} onChange={handleDimChange} step={1} min={2} max="16"/>
            </div>
            <div className="control-group">
              <label htmlFor="h">注意力头数 (h)</label>
              <input type="number" id="h" value={dims.h} onChange={handleDimChange} min="1" max={dims.d_model}/>
            </div>
            <div className="control-group">
              <label htmlFor="n_layers">层数 (N)</label>
              <input type="number" id="n_layers" value={dims.n_layers} onChange={handleDimChange} min="1" max="3"/>
            </div>
            <div className="control-group">
              <label>键/查询维度 (d_k)</label>
              <div className="d_k-value">{d_k}</div>
            </div>
          </div>
      )}
        <div className="resize-handle br" {...resizeHandleProps.br}></div>
        <div className="resize-handle t" {...resizeHandleProps.t}></div>
        <div className="resize-handle r" {...resizeHandleProps.r}></div>
        <div className="resize-handle b" {...resizeHandleProps.b}></div>
        <div className="resize-handle l" {...resizeHandleProps.l}></div>
    </div>
  );
};
// END OF FILE: src/topics/transformer-explorer/components/Controls.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/DecoderLayer.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/DecoderLayer.tsx
import React from 'react';
import { DecoderLayerData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../lib/symbolMapping';
import { Matrix } from './Matrix';
import { MaskedMultiHeadAttention } from './MaskedMultiHeadAttention';
import { EncoderDecoderAttention } from './EncoderDecoderAttention';

interface DecoderLayerProps {
  layerIndex: number;
  data: DecoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  onComponentClick: (componentId: string) => void;
  finalEncoderOutput: MatrixType;
}

export const DecoderLayer: React.FC<DecoderLayerProps> = ({ layerIndex, data, highlight, onElementClick, onComponentClick, finalEncoderOutput }) => {
  const baseName = `decoder.${layerIndex}`;
  const LN = MATRIX_NAMES.decoderLayer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.decoder_input);
  const dimsRes1 = `${data.decoder_input.length}x${data.decoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  const symbolRes3 = getSymbolParts(LN.add_norm_2_output);
  const dimsRes3 = `${data.add_norm_2_output.length}x${data.add_norm_2_output[0].length}`;
  const mathSymbolRes3 = symbolRes3.base + (symbolRes3.subscript ? `_{${symbolRes3.subscript}}` : '') + (symbolRes3.superscript ? `^{${symbolRes3.superscript}}` : '');

  return (
    <div className="decoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#d1c4e9', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#ede7f6'}}>解码器层 (Decoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                <Matrix name={LN.decoder_input} data={data.decoder_input} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-d1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MaskedMultiHeadAttention
                    baseName={`${baseName}.masked_mha`}
                    data={data.masked_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.decoder_input}
                    residualInputName={LN.decoder_input}
                    inputSublayer={data.masked_mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.masked_mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_1_dec"
                    residualId={`res-l${layerIndex}-d1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />
                <div className="arrow-down">↓</div>

                <ResidualBlock id={`res-l${layerIndex}-d2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <EncoderDecoderAttention
                    baseName={`${baseName}.enc_dec_mha`}
                    data={data.enc_dec_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    decoderAddNorm1Output={data.add_norm_1_output}
                    finalEncoderOutput={finalEncoderOutput}
                />
                <AddNorm
                    residualInput={data.add_norm_1_output}
                    residualInputName={LN.add_norm_1_output}
                    inputSublayer={data.enc_dec_mha_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.enc_dec_mha_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_2_dec"
                    residualId={`res-l${layerIndex}-d2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />
                <div className="arrow-down">↓</div>

                <ResidualBlock id={`res-l${layerIndex}-d3`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes3} matrixDims={dimsRes3} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_2_output}
                    inputName={LN.add_norm_2_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.add_norm_2_output}
                    residualInputName={LN.add_norm_2_output}
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_3_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_3_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_3_dec"
                    residualId={`res-l${layerIndex}-d3`}
                    residualMatrixSymbol={mathSymbolRes3}
                    residualMatrixDims={dimsRes3}
                />
            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/topics/transformer-explorer/components/DecoderLayer.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/Decoding.tsx
================================================================================

// FILE: src/components/Decoding.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { EmbeddingLookup } from './EmbeddingLookup';

interface DecodingProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    isActive: boolean;
}

export const Decoding: React.FC<DecodingProps> = ({ data, highlight, onElementClick, onComponentClick, isActive }) => {
    // Create a list of ElementIdentifier for the output tokens
    const outputTokensForLookup: ElementIdentifier[] = data.outputText.map((token, i) => {
        const correspondingProbRow = data.outputProbabilities[i];
        const maxProb = Math.max(...correspondingProbRow);
        return {
            name: "outputToken",
            row: i,
            col: -1, // Not a cell in a matrix
            tokenId: data.decodedTokens[i],
            tokenStr: token,
            probValue: maxProb
        };
    });

    const shouldBreak = (data.embeddingMatrix[0]?.length || 0) > 10;

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('decoding')}>Output: Decoding Probabilities to Text</div>
            <div className="component-body">

                <div className="decoding-step">
                    <div className="viz-step-title">1. Find Index of Max Probability per Row (Argmax)</div>
                    <p style={{textAlign: 'center', margin: '0 0 10px 0', fontSize: '0.9em', color: '#555'}}>Click a row in the probability matrix to see which token it generates.</p>
                     <Matrix name="outputProbabilities" data={data.outputProbabilities} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down">↓</div>

                <div className="decoding-step">
                     <div className="viz-step-title">2. Use Token IDs to Lookup Text from Vocabulary</div>
                     <EmbeddingLookup
                        mode="id-to-token"
                        tokens={outputTokensForLookup}
                        embeddingMatrix={data.embeddingMatrix}
                        vocab={data.vocab}
                        matrixName="embeddingMatrix"
                        highlight={highlight}
                        onElementClick={onElementClick}
                        shouldBreak={shouldBreak}
                     />
                </div>

            </div>
        </div>
    );
};
// END OF FILE: src/components/Decoding.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/Element.tsx
================================================================================

// FILE: src/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isProbMax?: boolean; // [NEW] To specifically highlight the argmax result
}

export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick, isProbMax = false }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col && !highlight.target.isInternal;

  const isSource = highlight.sources.some(s => {
    if (s.name !== name || s.isInternal) return false;
    if (s.highlightRow) return s.row === row;
    if (s.highlightCol) return s.col === col;
    return s.row === row && s.col === col;
  });

  const isDestination = highlight.destinations?.some(d => {
    if (d.name !== name || d.isInternal) return false;
    if (d.highlightRow) return d.row === row;
    if (d.highlightCol) return d.col === col;
    return d.row === row && d.col === col;
  });

  const classNames = ['matrix-element'];
  if (isTarget) classNames.push('target');
  if (isSource) classNames.push('source');
  if (isDestination) classNames.push('destination');
  if (isProbMax) classNames.push('prob-max');

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({ name, row, col }, event);
  };

  const displayValue = () => {
      if (value === -Infinity) return '-∞';
      if (value === Infinity) return '+∞';
      return value.toFixed(2);
  }

  return (
    <div className={classNames.join(' ')} onClick={handleClick}>
      {displayValue()}
    </div>
  );
});
// END OF FILE: src/components/Element.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/ElementwiseCalculation.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/ElementwiseCalculation.tsx
import React, { useState, useMemo, useEffect } from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier, HighlightState } from '../types';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface ElementwiseCalculationProps {
  opType: 'softmax' | 'relu';
  inputRow: number[];
  outputRow: number[];
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  baseName: string; // e.g., "encoder.0.mha.h0.AttentionWeights"
  rowIndex: number;
}

const formatNumber = (num: number, precision = 2) => {
    const fixed = num.toFixed(precision);
    return parseFloat(fixed).toString(); // Removes trailing zeros
};

type AnimStep = 'start' | 'exp' | 'sum' | 'divide' | 'relu';

export const ElementwiseCalculation: React.FC<ElementwiseCalculationProps> = ({
  opType,
  inputRow,
  outputRow,
  highlight,
  onElementClick,
  baseName,
  rowIndex,
}) => {
  const [step, setStep] = useState<AnimStep>('start');
  const stepsOrder: AnimStep[] = opType === 'softmax' ? ['start', 'exp', 'sum', 'divide'] : ['start', 'relu'];
  const currentStepIndex = stepsOrder.indexOf(step);

  // Reset animation when the target row changes
  useEffect(() => {
    setStep('start');
  }, [rowIndex, baseName]);

  const calculations = useMemo(() => {
    if (opType === 'softmax') {
      const maxVal = Math.max(...inputRow.filter(isFinite));
      const exps = inputRow.map(val => isFinite(val) ? Math.exp(val - maxVal) : 0);
      const sumExps = exps.reduce((a, b) => a + b, 0);
      return { exps, sumExps };
    }
    return { exps: [], sumExps: 0 };
  }, [inputRow, opType]);

  const handleNext = () => setStep(stepsOrder[Math.min(stepsOrder.length - 1, currentStepIndex + 1)]);
  const handlePrev = () => setStep(stepsOrder[Math.max(0, currentStepIndex - 1)]);
  const handleReset = () => setStep('start');

  const targetCol = highlight.target?.isInternal && highlight.target.row === rowIndex ? highlight.target.col : -1;
  const visibleCols = getVisibleIndices(inputRow.length, targetCol, 2, 5);

  const handleClick = (event: React.MouseEvent, colIndex: number) => {
    onElementClick({
      name: `${baseName}.internal`,
      row: rowIndex,
      col: colIndex,
      isInternal: true,
    }, event);
  };

  const isSource = (colIndex: number) => {
      return highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === colIndex);
  }
  const isTarget = (colIndex: number) => {
      return highlight.target?.isInternal && highlight.target.row === rowIndex && highlight.target.col === colIndex;
  }

  const renderVisibleElements = (data: number[], isHighlighted: boolean) => {
    return visibleCols.map((col, i) => {
      if (col === ELLIPSIS) {
        return <div key={`ellipsis-${i}`} className="elementwise-op-element symbolic-ellipsis">...</div>;
      }
      const value = data[col];
      const className = `elementwise-op-element ${isSource(col) ? 'source' : ''} ${isTarget(col) ? 'target' : ''} ${isHighlighted ? 'highlight-step' : ''}`;
      return (
        <div key={`${i}-${col}`} className={className} onClick={(e) => handleClick(e, col)}>
          {formatNumber(value, 2)}
        </div>
      );
    });
  };

  const renderSoftmax = () => {
    const fullSumIsSource = highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === -1);
    return (
      <>
        <div className={`calc-step ${currentStepIndex < 1 ? 'hidden' : ''}`}>
          <div className="calc-label"><InlineMath math="\text{exp}(x_i - \text{max}(\mathbf{x}))" /></div>
          <div className="elementwise-op-row">
            {renderVisibleElements(calculations.exps, step === 'exp')}
          </div>
        </div>
        <div className={`calc-step ${currentStepIndex < 2 ? 'hidden' : ''}`}>
          <div className="calc-label"><InlineMath math="\sum \text{exp}(\dots)" /></div>
          <div className={`elementwise-op-element sum ${fullSumIsSource ? 'source' : ''} ${step === 'sum' ? 'highlight-step' : ''}`} onClick={(e) => handleClick(e, -1)}>
            {formatNumber(calculations.sumExps, 4)}
          </div>
        </div>
        <div className={`calc-step ${currentStepIndex < 3 ? 'hidden' : ''}`}>
          <div className="calc-label"><InlineMath math="\text{exp}(\dots) / \sum" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, step === 'divide')}</div>
        </div>
      </>
    );
  };

  const renderReLU = () => (
    <div className={`calc-step ${currentStepIndex < 1 ? 'hidden' : ''}`}>
        <div className="calc-label"><InlineMath math="\text{Output}" /></div>
        <div className="elementwise-op-row">{renderVisibleElements(outputRow, step === 'relu')}</div>
    </div>
  );

  return (
    <div className="elementwise-calc-container">
      <div className="calc-step">
        <div className="calc-label"><InlineMath math="\text{Input}" /></div>
        <div className="elementwise-op-row">{renderVisibleElements(inputRow, step === 'start')}</div>
      </div>

      {opType === 'softmax' ? renderSoftmax() : renderReLU()}

      <div className="elementwise-controls">
          <button onClick={handlePrev} disabled={currentStepIndex <= 0}>上一步</button>
          <button onClick={handleNext} disabled={currentStepIndex >= stepsOrder.length - 1}>下一步</button>
          <button onClick={handleReset}>重置</button>
      </div>
    </div>
  );
};
// END OF FILE: src/topics/transformer-explorer/components/ElementwiseCalculation.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/ElementwiseOperation.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/ElementwiseOperation.tsx
import React from 'react';
import { Matrix, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { ElementwiseCalculation } from './ElementwiseCalculation';

interface ElementwiseOperationProps {
    opType: 'softmax' | 'relu';
    inputMatrix: Matrix;
    inputMatrixName: string;
    outputMatrix: Matrix;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    layerIndex: number;
    headIndex?: number;
}

export const ElementwiseOperation: React.FC<ElementwiseOperationProps> = ({
                                                                              opType,
                                                                              inputMatrix,
                                                                              inputMatrixName,
                                                                              outputMatrix,
                                                                              outputMatrixName,
                                                                              highlight,
                                                                              onElementClick,
                                                                              layerIndex,
                                                                              headIndex,
                                                                          }) => {
    let targetRowIndex = 0;

    if (highlight.target) {
        if (highlight.target.name === inputMatrixName || highlight.target.name === outputMatrixName) {
            targetRowIndex = highlight.target.row;
        } else if (highlight.target.isInternal && highlight.target.name.startsWith(outputMatrixName)) {
            targetRowIndex = highlight.target.row;
        }
    }

    const inputRow = inputMatrix[targetRowIndex] || [];
    const outputRow = outputMatrix[targetRowIndex] || [];

    const opName = opType.charAt(0).toUpperCase() + opType.slice(1);
    const opFunction = opType === 'relu' ? 'max(0, x)' : 'softmax(x_i)';

    return (
        <div className="elementwise-op-container">
            <div className="elementwise-op-label">
                <InlineMath math={`\\text{Detailed Calculation: } ${opName}(x_i) = ${opFunction}`} />
            </div>
            <p style={{margin: '0', fontSize: '0.8em', color: '#666'}}>* Showing calculation for Row {targetRowIndex}</p>
            <ElementwiseCalculation
                opType={opType}
                inputRow={inputRow}
                outputRow={outputRow}
                highlight={highlight}
                onElementClick={onElementClick}
                baseName={outputMatrixName}
                rowIndex={targetRowIndex}
            />
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/ElementwiseOperation.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/EmbeddingLookup.tsx
================================================================================

// FILE: src/components/EmbeddingLookup.tsx
import React, { useRef, useEffect, useState } from 'react';
import { TransformerData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { Token } from './Token';

interface EmbeddingLookupProps {
    mode: 'token-to-vector' | 'id-to-token';
    tokens: ElementIdentifier[];
    embeddingMatrix: MatrixType;
    matrixName: string;
    vocab?: TransformerData['vocab']; // For id-to-token mode
    outputVectors?: MatrixType; // For token-to-vector mode
    outputMatrixName?: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    shouldBreak: boolean; // [ADDED] Prop to control layout
}

export const EmbeddingLookup: React.FC<EmbeddingLookupProps> = ({
    mode,
    tokens,
    embeddingMatrix,
    matrixName,
    vocab,
    outputVectors,
    outputMatrixName,
    highlight,
    onElementClick,
    shouldBreak,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [lines, setLines] = useState<any[]>([]);

    useEffect(() => {
        const calculateLines = () => {
            if (!containerRef.current) return;

            const newLines: any[] = [];
            const tokenElements = Array.from(containerRef.current.querySelectorAll('.token-container'));
            const matrixRowElements = Array.from(containerRef.current.querySelectorAll(`.matrix-grid[data-name="${matrixName}"] .matrix-element`));
            const outputElements = Array.from(containerRef.current.querySelectorAll(mode === 'token-to-vector' ? `.matrix-wrapper[data-name="${outputMatrixName}"]` : '.token-container.output-token'));

            const matrixGridEl = containerRef.current.querySelector(`.matrix-wrapper[data-name="${matrixName}"]`);
            if (!matrixGridEl) return;
            const matrixRect = matrixGridEl.getBoundingClientRect();
            const containerRect = containerRef.current.getBoundingClientRect();

            tokens.forEach((token, index) => {
                const tokenId = token.tokenId!;
                const isHighlighted = highlight.sources.some(s => s.name === 'inputToken' && s.row === index) ||
                                      highlight.target?.name === 'inputToken' && highlight.target?.row === index ||
                                      highlight.sources.some(s => s.name === 'outputProbabilities' && s.row === index) ||
                                      highlight.target?.name === 'outputToken' && highlight.target?.row === index;

                const tokenEl = tokenElements[index];

                // Find the corresponding matrix row element (might be virtualized)
                // Added null check for containerRef.current here to satisfy TypeScript
                const matrixRowEl = containerRef.current?.querySelector(`.matrix-element[data-row="${tokenId}"]`);
                const outputEl = outputElements[index];

                if (tokenEl && matrixRowEl && outputEl) {
                    const tokenRect = tokenEl.getBoundingClientRect();
                    const matrixRowRect = matrixRowEl.getBoundingClientRect();
                    const outputRect = outputEl.getBoundingClientRect();

                    let path1, path2;

                    if (shouldBreak) { // Vertical layout paths
                        const startX1 = tokenRect.left + tokenRect.width / 2 - containerRect.left;
                        const startY1 = tokenRect.bottom - containerRect.top;
                        const endX1 = matrixRect.left + matrixRect.width / 2 - containerRect.left;
                        const endY1 = matrixRect.top - containerRect.top;
                        path1 = `M ${startX1} ${startY1} C ${startX1} ${startY1 + 40} ${endX1} ${endY1 - 40} ${endX1} ${endY1}`;

                        const startX2 = endX1;
                        const startY2 = matrixRect.bottom - containerRect.top;
                        const endX2 = outputRect.left + outputRect.width / 2 - containerRect.left;
                        const endY2 = outputRect.top - containerRect.top;
                        path2 = `M ${startX2} ${startY2} C ${startX2} ${startY2 + 40} ${endX2} ${endY2 - 40} ${endX2} ${endY2}`;
                    } else { // Horizontal layout paths
                        const startX1 = tokenRect.right - containerRect.left;
                        const startY1 = tokenRect.top + tokenRect.height / 2 - containerRect.top;
                        const endX1 = matrixRect.left - containerRect.left;
                        const endY1 = matrixRowRect.top + matrixRowRect.height / 2 - containerRect.top;
                        path1 = `M ${startX1} ${startY1} C ${startX1 + 50} ${startY1} ${endX1 - 50} ${endY1} ${endX1} ${endY1}`;

                        const startX2 = matrixRect.right - containerRect.left;
                        const startY2 = endY1; // Same Y as the matrix row
                        const endX2 = outputRect.left - containerRect.left;
                        const endY2 = outputRect.top + outputRect.height / 2 - containerRect.top;
                        path2 = `M ${startX2} ${startY2} C ${startX2 + 50} ${startY2} ${endX2 - 50} ${endY2} ${endX2} ${endY2}`;
                    }

                    newLines.push({ id: `line-${index}`, path1, path2, highlighted: isHighlighted });
                }
            });
            setLines(newLines);
        };
        calculateLines();
        const resizeObserver = new ResizeObserver(calculateLines);
        if (containerRef.current) {
            resizeObserver.observe(containerRef.current);
        }
        return () => resizeObserver.disconnect();
    }, [highlight, tokens, matrixName, outputMatrixName, mode, shouldBreak]);


    return (
        <div className={`embedding-lookup-container ${shouldBreak ? 'vertical' : ''}`} ref={containerRef}>
            <svg className="embedding-lookup-svg">
                {lines.map(line => (
                    <React.Fragment key={line.id}>
                        <path d={line.path1} className={line.highlighted ? 'highlighted' : ''} />
                        <path d={line.path2} className={line.highlighted ? 'highlighted' : ''} />
                    </React.Fragment>
                ))}
            </svg>

            {/* Input Column */}
            <div className="embedding-lookup-column">
                {tokens.map((token, i) => (
                    mode === 'token-to-vector'
                        ? <Token key={i} tokenStr={token.tokenStr!} tokenId={token.tokenId!} position={i} name={token.name} highlight={highlight} onElementClick={onElementClick} />
                        : <div key={i} style={{height: '59px', display: 'flex', alignItems: 'center', fontFamily: 'monospace'}}>ID: {token.tokenId}</div> // Placeholder for IDs
                ))}
            </div>

            {shouldBreak && <div className="arrow-down">↓</div>}

            {/* Vocabulary Matrix Column */}
            <div className="embedding-lookup-vocab" data-name={matrixName}>
                 <Matrix name={matrixName} data={embeddingMatrix} highlight={highlight} onElementClick={onElementClick} />
            </div>

            {shouldBreak && <div className="arrow-down">↓</div>}

            {/* Output Column */}
            <div className="embedding-lookup-column">
                 {mode === 'token-to-vector' && outputVectors && outputMatrixName ? (
                    <Matrix name={outputMatrixName} data={outputVectors} highlight={highlight} onElementClick={onElementClick} />
                 ) : (
                    tokens.map((token, i) => (
                         <Token key={i} tokenStr={token.tokenStr!} tokenId={token.tokenId!} position={i} name={token.name} highlight={highlight} onElementClick={onElementClick} />
                    ))
                 )}
            </div>
        </div>
    );
};
// END OF FILE: src/components/EmbeddingLookup.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/EncoderDecoderAttention.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/EncoderDecoderAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';

interface EncDecAttentionProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    decoderAddNorm1Output: MatrixType;
    finalEncoderOutput: MatrixType;
}

export const EncoderDecoderAttention: React.FC<EncDecAttentionProps> = ({ baseName, data, highlight, onElementClick, onComponentClick, decoderAddNorm1Output, finalEncoderOutput }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0;
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'enc_dec_mha';
    const numHeads = data.heads.length;
    const LNd = MATRIX_NAMES.decoderLayer(layerIndex);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex);

    const renderConcatHeads = () => {
        const headsToShow = [];
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.encDecMhaHead(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        if (numHeads > 2) {
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.encDecMhaHead(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.encDecMhaHead(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('enc_dec_mha')}>Encoder-Decoder Attention</div>
            <div className="component-body">
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Prepare Inputs</div>
                    <div className="viz-formula-row">
                        <div style={{display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px'}}>
                            <span style={{fontWeight: 'bold'}}>Q Input (from Decoder)</span>
                            <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).add_norm_1_output} data={decoderAddNorm1Output} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                        <div style={{display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px'}}>
                            <span style={{fontWeight: 'bold'}}>K & V Input (from Encoder)</span>
                            <Matrix name={MATRIX_NAMES.finalEncoderOutput} data={finalEncoderOutput} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Generate Q, K, V (Head 0)</div>
                    <div className="viz-formula-row">
                        <span>(Q Input) ×</span>
                        <Matrix name={HNd_encdec.Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNd_encdec.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="viz-formula-row">
                        <span>(K Input) ×</span>
                        <Matrix name={HNd_encdec.Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNd_encdec.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="viz-formula-row">
                        <span>(V Input) ×</span>
                        <Matrix name={HNd_encdec.Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNd_encdec.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Scaled Dot-Product Attention (Head 0)</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_encdec.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={HNd_encdec.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_encdec.Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_encdec.ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Softmax}}" /></div>

                    <div className="viz-formula-row">
                        <Matrix name={HNd_encdec.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={HNd_encdec.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_encdec.HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">4. Concat Heads</div>
                    <div className="viz-formula-row">
                        <InlineMath math="\text{Concat}(" />
                        {renderConcatHeads()}
                        <InlineMath math=")" />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LNd.ConcatOutput_enc_dec} data={data.ConcatOutput} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">5. Final Projection</div>
                    <div className="viz-formula-row">
                        <Matrix name={LNd.ConcatOutput_enc_dec} data={data.ConcatOutput} highlight={highlight} onElementClick={onElementClick} />
                        <span className="op-symbol">×</span>
                        <Matrix name={LNd.Wo_enc_dec} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LNd.enc_dec_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/EncoderDecoderAttention.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/EncoderLayer.tsx
================================================================================

// FILE: src/components/EncoderLayer.tsx
import React from 'react';
import { EncoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { MultiHeadAttention } from './MultiHeadAttention';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../lib/symbolMapping';
import { Matrix } from './Matrix';

interface EncoderLayerProps {
  layerIndex: number;
  data: EncoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  onComponentClick: (componentId: string) => void;
}

export const EncoderLayer: React.FC<EncoderLayerProps> = ({ layerIndex, data, highlight, onElementClick, onComponentClick }) => {
  const baseName = `encoder.${layerIndex}`;
  const LN = MATRIX_NAMES.layer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.encoder_input);
  const dimsRes1 = `${data.encoder_input.length}x${data.encoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  return (
    <div className="encoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#e3f2fd', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#e3f2fd'}}>编码器层 (Encoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- MHA Sub-layer with Residual Connection --- */}
                <ResidualBlock id={`res-l${layerIndex}-1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MultiHeadAttention
                    baseName={`${baseName}.mha`}
                    data={data.mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.encoder_input}
                    residualInputName={LN.encoder_input}
                    inputSublayer={data.mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_1"
                    residualId={`res-l${layerIndex}-1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />

                {/* --- FFN Sub-layer with Residual Connection --- */}
                <div className="arrow-down">↓</div>
                <ResidualBlock id={`res-l${layerIndex}-2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_1_output}
                    inputName={LN.add_norm_1_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.add_norm_1_output}
                    residualInputName={LN.add_norm_1_output}
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_2"
                    residualId={`res-l${layerIndex}-2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />

            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/EncoderLayer.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/Explanation.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/Explanation.tsx
import React from 'react';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import { InteractiveSymbolicVector } from './InteractiveSymbolicVector';
import { HighlightState, ElementIdentifier } from '../types';
import { MATRIX_NAMES } from '../config/matrixNames';

interface ExplanationProps {
    dims: { d_model: number; h: number, n_layers: number, d_ff: number, encoder_seq_len: number, decoder_seq_len: number, vocab_size: number };
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

interface MathBlockProps {
    id: string;
    title: string;
    children: React.ReactNode;
    highlight: HighlightState;
}

const MathBlock: React.FC<MathBlockProps> = ({ id, title, children, highlight }) => {
    const isActive = highlight.activeComponent === id;
    return (
        <div id={`math_${id}`} className={`math-block ${isActive ? 'active' : ''}`}>
            <h3>{title}</h3>
            {children}
        </div>
    );
};

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight, onSymbolClick }) => {
    const LNe = MATRIX_NAMES.layer(0);
    const FinalLNe = MATRIX_NAMES.layer(dims.n_layers - 1);
    const HNe = MATRIX_NAMES.head(0, 0);
    const LNd = MATRIX_NAMES.decoderLayer(0);
    const FinalLNd = MATRIX_NAMES.decoderLayer(dims.n_layers - 1);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(0, 0);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(0, 0);
    const d_k = dims.d_model / dims.h;

    const shouldBreakAddNorm = dims.d_model > 8;
    const shouldBreakMhaProj = (dims.d_model * dims.h) > 128;
    const shouldBreakFFN1 = dims.d_model + dims.d_ff > 8;
    const shouldBreakFFN2 = dims.d_ff + dims.d_model > 8;
    const shouldBreakFinalOutput = dims.d_model + dims.vocab_size > 8;

    const shouldBreakEncDecScores = d_k + dims.encoder_seq_len > 8;
    const shouldBreakEncDecHeadOutput = dims.encoder_seq_len + d_k > 8;


    return (
        <div>
            <div className="math-block">
                <h3>Transformer 架构概览</h3>
                <p>Transformer 模型由两个核心部分组成:<b>编码器 (Encoder)</b> 和 <b>解码器 (Decoder)</b>. 它的出现革命性地解决了传统循环神经网络(RNN)在处理长序列时难以并行计算和捕捉长期依赖的问题。</p>
                <p><b>编码器的任务</b>是“理解”输入的整个句子(例如,"I am a student"),并将其转化为一组富含上下文信息的数字表示(向量). 这好比一位翻译官在动笔前，完整地阅读并消化了整个原文的含义。</p>
                <p><b>解码器的任务</b>是利用这些数字表示,并结合已经生成的内容,一次一个词地生成目标句子(例如,“我 是 一个 学生”). 这就像翻译官在理解了原文后，开始逐字逐句地写出译文。</p>
                <p>在2017年的原始论文《Attention Is All You Need》中,编码器和解码器都由 N 个相同的层堆叠而成. 这种堆叠结构允许模型在不同层次上学习从简单到复杂的抽象特征。此可视化工具将带您深入探索其内部的数据流动和数学原理。</p>
            </div>

            <h2 style={{textAlign: 'center', margin: '30px 0'}}>编码器 (Encoder)</h2>
            <MathBlock id="token_embed" title="编码器第0步:分词与词嵌入" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将您在上方控件中输入的自然语言文本,转换为模型可以处理的数值矩阵. 这是所有后续计算的起点,是连接人类语言与机器世界的桥梁。</p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>分词 (Tokenization):</b> 使用简单的空格分词器,将输入句子分解为一个个独立的词元(Token). 真实世界的模型（如BERT, GPT）会使用更复杂的分词算法（如WordPiece, BPE）来处理未知词和构词法。</li>
                    <li><b>ID映射 (ID Mapping):</b> 使用一个预先构建好的词汇表(Vocabulary),将每个词元映射到一个唯一的整数ID. 任何未知的词汇都会被映射为 <code>[UNK]</code> (Unknown). 这个词汇表是在模型训练前通过扫描海量文本语料库构建的。</li>
                    <li><b>词嵌入 (Embedding Lookup):</b> 使用一个巨大的、可学习的“查询表”(Embedding Matrix),根据每个词元的ID,从中“提取”出对应的向量. 这个向量就是该词元的初始数值表示。</li>
                </ol>
                <h5>深入理解:从文本到向量的“魔法”</h5>
                <p>您可能会问:“一个词(比如'student')是如何变成一长串数字(向量)的？” 关键在于那块巨大的 <b>词嵌入矩阵 (Embedding Matrix)</b>. </p>
                <p>您可以把这个矩阵想象成一本**模型在训练中自己学会编写的“超级词典”**:</p>
                <ul>
                    <li><b>词条编号 (Token ID):</b> 词汇表中的每个词都有一个独一无二的ID,比如 `student` 的ID是 `6`. 这就像是词典里的页码或词条号. </li>
                    <li><b>词条释义 (Embedding Vector):</b> 矩阵中**第 `6` 行**的那一整行向量,就是 `student` 这个词的“释义”. 这个释义不是用人类语言写的,而是用一串数字(例如一个长度为 {dims.d_model} 的向量)来定义的。这个向量捕捉了 `student` 这个词的丰富语义信息——它和 `school`、`learn` 在语义空间中比较接近,但和 `apple`、`sky` 比较疏远。这种将离散的词语映射到连续向量空间的过程，使得模型能够理解和利用词语之间的语义关系。</li>
                </ul>
                <p>所以,整个过程并不是“计算”出一个向量,而是一个高效的**“查词典”**的过程. 模型通过海量数据的训练,学会了如何为每个词编写最精准的、富含信息的“数字释义”,我们在这里只是根据ID去查询而已. </p>
            </MathBlock>
            <MathBlock id="input_embed" title="编码器第1步:输入预处理" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将输入的文本序列(一串文字)转换为模型可以处理的、包含“词义”和“位置”信息的数值向量矩阵. 当前输入序列长度为 {dims.encoder_seq_len},模型维度 <InlineMath math={`d_{model}=${dims.d_model}`}/>. </p>
                <h5>为什么需要位置编码?</h5>
                <p>Transformer的核心机制——自注意力(Self-Attention)，在处理输入时是“无视顺序”的。也就是说，打乱输入句子中词的顺序，自注意力的计算结果不会改变。但这显然不符合自然语言的规律（“学生是我”和“我是学生”含义完全不同）。因此，我们需要一种方法告诉模型每个词在句子中的位置。<b>位置编码 (Positional Encoding)</b> 就是为了解决这个问题而生的。</p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>词嵌入 (Token Embedding):</b> 从上一步获得的矩阵,代表了每个词的“词义”. </li>
                    <li><b>位置编码 (Positional Encoding):</b> 为模型注入关于序列顺序的绝对位置信息. 这是一个固定的、根据三角函数(sine 和 cosine)生成的矩阵。这种设计允许模型轻易地学习到相对位置关系，并且理论上可以扩展到比训练时更长的序列。</li>
                    <li><b>逐元素相加:</b> 将词义信息和位置信息相加，得到编码器最终的输入表示 <InlineMath math="Z"/>. </li>
                </ol>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.inputEmbeddings} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.posEncodings} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="mha" title="编码器子层1:多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此机制的核心目的是计算句子中每个词与其他所有词的“关注度”或“相关性”,并根据这个关注度重新计算每个词的向量表示,从而让每个词的向量都融入其上下文信息。例如，在句子 "The animal didn't cross the street because it was too tired" 中，自注意力能帮助模型理解 "it" 指的是 "animal" 而不是 "street"。</p>
                <h5>输入矩阵 (Input Matrix)</h5>
                <div className="formula-display">
                    <InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false} sideLabel={true} />
                </div>
                <h5>计算流程 (以单个注意力头为例)</h5>
                <p>输入矩阵 <InlineMath math="Z"/> 被并行地送入 {dims.h} 个独立的注意力头. 每个头都拥有三块自己专属、可学习的权重矩阵. 通过矩阵乘法,将输入 <InlineMath math="Z"/> 投影到三个新的矩阵:查询 (Query, <InlineMath math="Q"/>), 键 (Key, <InlineMath math="K"/>), 和 值 (Value, <InlineMath math="V"/>)。这可以类比于一个信息检索系统：</p>
                <ul>
                    <li><b>Query (Q):</b> 代表当前词为了更好地理解自己，向其他词发出的“查询请求”。例如，"it" 这个词的Query向量可能在问：“句子中谁可能是疲惫的？”</li>
                    <li><b>Key (K):</b> 代表句子中每个词用于被检索的“标签”或“索引”。例如，"animal" 这个词的Key向量会表明：“我是一个名词，一个生物。”</li>
                    <li><b>Value (V):</b> 代表每个词实际携带的“内容”或“信息”。</li>
                </ul>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.Q} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>然后计算注意力分数, 进行缩放和Softmax得到权重, 最后加权求和。 <InlineMath math="Q"/> 和 <InlineMath math="K"/> 的点积计算了每个词的“查询”与所有词的“标签”之间的相似度。除以 <InlineMath math="\sqrt{d_k}"/> 是为了在训练中保持梯度稳定。Softmax则将这些原始的相似度分数转换成一个和为1的概率分布，即“注意力权重”。最后，将这些权重与 <InlineMath math="V"/> 相乘，相当于对所有词的信息进行加权求和，得到一个融合了全句上下文信息的新向量。</p>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNe.Q} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} transpose={true}/><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.Scores} rows={dims.encoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><BlockMath math={`\\text{Scale }(/\\sqrt{d_k})`} /></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNe.ScaledScores} rows={dims.encoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><BlockMath math={`\\text{Softmax}`} /></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNe.AttentionWeights} rows={dims.encoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.HeadOutput} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <h5>拼接与最终投影</h5>
                <p>“多头”的“多”体现在这里。{dims.h} 个头并行地执行上述计算，每个头都可能关注到输入关系的不同方面（比如有的头关注语法关系，有的头关注语义关系）。最后，将所有 {dims.h} 个头的输出矩阵 <InlineMath math="H_i"/> 拼接 (Concatenate) 起来, 然后通过一个最终的投影权重矩阵 <InlineMath math="W^O"/> 将其维度变回 <InlineMath math="d_{model}"/>，得到该子层的最终输出 <InlineMath math="M"/>。</p>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" /><BlockMath math="=" /><InteractiveSymbolicMatrix name={LNe.ConcatOutput} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={LNe.ConcatOutput} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNe.Wo} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNe.mha_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_1" title="组件:残差连接与层归一化 (1)" highlight={highlight}>
                <p>在每个子层之后,都会跟随一个“Add & Norm”模块. 它包含两个关键步骤:<b>残差连接 (Residual Connection)</b> 和 <b>层归一化 (Layer Normalization)</b>。这是训练深度神经网络的关键技巧。</p>
                <ul>
                    <li><b>残差连接:</b> 将子层的输入与输出直接相加。这创建了一条信息的“高速公路”，允许梯度在反向传播时直接流过，极大地缓解了深度网络中的梯度消失问题，使得训练更深的模型成为可能。它也保证了即使子层（如注意力）的输出为零，原始信息也能得以保留。</li>
                    <li><b>层归一化:</b> 对残差连接后的结果进行归一化处理。它独立地对每个样本的特征进行归一化，使其均值为0，方差为1。这有助于稳定每一层的输入分布，减少所谓的“内部协变量偏移”(Internal Covariate Shift)，从而加速训练过程并提高模型的泛化能力。</li>
                </ul>
                <BlockMath math={`\\mu = \\frac{1}{d_{model}} \\sum_{i=1}^{d_{model}} x_i`} />
                <BlockMath math={`\\sigma^2 = \\frac{1}{d_{model}} \\sum_{i=1}^{d_{model}} (x_i - \\mu)^2`} />
                <BlockMath math={`\\text{LayerNorm}(x) = \\gamma \\frac{x - \\mu}{\\sqrt{\\sigma^2 + \\epsilon}} + \\beta`} />
                <p>其中 <InlineMath math="\gamma"/> (gamma) 和 <InlineMath math="\beta"/> (beta) 是可学习的缩放和平移参数，<InlineMath math="\epsilon"/> (epsilon) 是一个很小的常数以防止除零。在这个可视化中，我们简化了 <InlineMath math="\gamma=1, \beta=0"/>。</p>
                <BlockMath math={`Z' = \\text{LayerNorm}(Z + \\text{MultiHeadAttention}(Z))`} />
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.mha_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="ffn" title="编码器子层2:位置前馈网络" highlight={highlight}>
                <p>前馈网络 (FFN) 对每个位置的向量独立地进行一次复杂的非线性变换,极大地增加了模型的表达能力。如果说自注意力层是负责在不同词之间“交流和汇总信息”，那么FFN层就是每个词在接收了上下文信息后，进行独立的“深入思考和加工”。</p>
                <p>它由两个线性层和一个ReLU激活函数组成。第一个线性层将维度从 <InlineMath math="d_{model}"/> 扩展到 <InlineMath math="d_{ff}"/> (通常是 <InlineMath math="4 \times d_{model}"/>), ReLU引入非线性，然后第二个线性层再将其投影回 <InlineMath math="d_{model}"/> 维度。这种“扩展-激活-压缩”的结构被证明在增强模型表示能力方面非常有效。</p>
                <BlockMath math={`F = \\text{ReLU}(Z' W_1 + b_1) W_2 + b_2`} />
                <h5>第一次线性变换 & ReLU</h5>
                <div className={`formula-display ${shouldBreakFFN1 ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNe.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                <div className="formula-display vertical">
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Intermediate} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Activated} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                </div>
                <h5>第二次线性变换</h5>
                <div className={`formula-display ${shouldBreakFFN2 ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Activated} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.W2} rows={dims.d_ff} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNe.b2} data={Array(dims.d_model).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="="/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.ffn_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_2" title="组件:残差连接与层归一化 (2)" highlight={highlight}>
                <p>与第一个 "Add & Norm" 层完全相同,此步骤将 FFN 子层的输出与输入结合,产生该编码器层的最终输出。经过这一步，一个完整的编码器层就完成了它的使命：接收一组向量表示，并通过自注意力和前馈网络对其进行信息提炼和加工，最终输出一组包含了更丰富上下文信息的新向量表示。这个输出将作为下一个编码器层的输入，或者在最后一层，成为整个编码器的最终输出。</p>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.ffn_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_2_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>

            <h2 style={{textAlign: 'center', margin: '30px 0'}}>解码器 (Decoder)</h2>
            <MathBlock id="output_embed" title="解码器第1步:输出预处理" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤与编码器输入预处理类似,但作用于目标语言序列(即解码器要生成的内容). 它将目标序列(通常是已经生成的词加上一个起始符 <code>&lt;SOS&gt;</code>)转换为模型可以处理的数值向量矩阵。在推理（生成）阶段，解码器的输入是它上一步自己生成的词。</p>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputEmbeddings} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.decoderPosEncodings} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.decoder_input} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="masked_mha" title="解码器子层1:带掩码的多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是解码器的第一个关键子层. 它与编码器的自注意力机制几乎完全相同,但有一个至关重要的区别:<b>前瞻遮罩 (Look-Ahead Mask)</b>. </p>
                <h5>设计思路</h5>
                <p>在生成任务中,模型在预测第 <code>i</code> 个词时,只能看到第 <code>i</code> 个词之前(包括第 <code>i</code> 个词)的内容,绝不能“偷看”未来的词。这模拟了人类说话或写作时，无法预知下一个要说什么词的自然过程。为了在并行的矩阵运算中实现这一点,我们在计算注意力分数后,会应用一个遮罩. 这个遮罩将分数矩阵 <InlineMath math="S"/> 的上三角部分(代表未来位置)设置为一个非常大的负数(-∞). 这样,在经过 Softmax 运算后,这些位置的注意力权重将变为0,从而确保了模型无法关注未来的信息. 这就是所谓的“自回归”(Auto-regressive)特性。</p>
                <h5>计算流程 (以单个注意力头为例)</h5>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="Y" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_masked.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_masked.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Y" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_masked.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_masked.K} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Y" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_masked.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_masked.V} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>在应用掩码后，后续计算与编码器自注意力完全相同。</p>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNd_masked.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_masked.K} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} transpose={true}/><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_masked.Scores} rows={dims.decoder_seq_len} cols={dims.decoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><BlockMath math={`\\text{Mask} + \\text{Scale }(/\\sqrt{d_k})`} /></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNd_masked.ScaledScores} rows={dims.decoder_seq_len} cols={dims.decoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><BlockMath math={`\\text{Softmax}`} /></div>
                    <div className="viz-formula-row"><BlockMath math="\downarrow" /></div>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNd_masked.AttentionWeights} rows={dims.decoder_seq_len} cols={dims.decoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_masked.V} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_masked.HeadOutput} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" /><BlockMath math="=" /><InteractiveSymbolicMatrix name={LNd.ConcatOutput_masked} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={LNd.ConcatOutput_masked} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNd.Wo_masked} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNd.masked_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_1_dec" title="解码器组件:残差连接与层归一化 (1)" highlight={highlight}>
                <p>此模块接收解码器输入 <InlineMath math="Y"/> 和带掩码自注意力子层的输出 <InlineMath math="M_{mmha}"/>,将它们相加后进行层归一化。其原理和作用与编码器中的 Add & Norm 模块完全一致，旨在稳定训练并保留信息。</p>
                <BlockMath math={`Y' = \\text{LayerNorm}(Y + \\text{Masked-MHA}(Y))`} />
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.decoder_input} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.masked_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="enc_dec_mha" title="解码器子层2:编码器-解码器注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是连接编码器和解码器的桥梁,也是 Transformer 架构的精髓所在. 在这一层,解码器会“审视”编码器的全部输出,并判断输入序列中的哪些部分对于生成当前目标词最重要。这也被称为“交叉注意力”(Cross-Attention)。</p>
                <h5>输入矩阵</h5>
                <div className="formula-display vertical">
                    <div>
                        <p style={{textAlign: 'center', marginBottom: '5px'}}>Query Input (from Decoder):</p>
                        <InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false} sideLabel={true}/>
                    </div>
                    <div style={{marginTop: '15px'}}>
                        <p style={{textAlign: 'center', marginBottom: '5px'}}>Key/Value Input (from Encoder):</p>
                        <InteractiveSymbolicMatrix name={FinalLNe.add_norm_2_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false} sideLabel={true}/>
                    </div>
                </div>
                <h5>计算流程 (以单个注意力头为例)</h5>
                <ol>
                    <li><b>Query (<InlineMath math="Q"/>)</b>: 来自解码器前一层的输出 (<InlineMath math="Y'"/>). 它代表了“我当前需要什么信息来生成下一个词？”。这个查询是基于解码器已经生成的内容。</li>
                    <li><b>Key (<InlineMath math="K"/>) 和 Value (<InlineMath math="V"/>)</b>: <b>均来自编码器的最终输出 (<InlineMath math="Z_{final}"/>)</b>. 它们代表了整个输入序列的、经过深度处理的上下文信息。</li>
                </ol>
                <h5>为什么Q和K/V的序列长度可以不同？</h5>
                <p>
                    这是交叉注意力的核心特征。Query 来自解码器，它的序列长度等于当前已生成的 token 数量（例如 {dims.decoder_seq_len}）。Key 和 Value 来自编码器，它们的序列长度等于完整的输入句子长度（例如 {dims.encoder_seq_len}）。
                    计算 <InlineMath math={`Q \\cdot K^T`}/> 时，矩阵维度为 <InlineMath math={`(${dims.decoder_seq_len} \\times d_k) \\cdot (d_k \\times ${dims.encoder_seq_len})`}/>，最终得到的注意力分数矩阵维度为 <InlineMath math={`(${dims.decoder_seq_len} \\times ${dims.encoder_seq_len})`}/>。
                    这个分数矩阵的每一行 `i` 代表解码器的第 `i` 个 token 对编码器所有 `j` 个 token 的关注度分布。这使得解码器在生成每个新词时，都能“回顾”整个输入句子，并决定重点关注哪些部分。
                </p>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="Y'" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z_{final}" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z_{final}" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>通过计算 <InlineMath math="Q_{dec} \cdot K_{enc}^T"/>,解码器能够评估其当前的生成需求与输入序列中每个词的相关性,然后利用这个相关性(注意力权重)从 <InlineMath math="V_{enc}"/> 中加权提取最需要的信息来辅助生成。例如，在将 "I am a student" 翻译成中文时，当解码器准备生成“学生”时，它的 Query 会与编码器输出中 "student" 对应的 Key 产生很高的相似度，从而更多地关注 "student" 的 Value 信息。</p>
                <h5>注意力计算与输出</h5>
                <div className={`formula-display ${shouldBreakEncDecScores ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} transpose={true}/></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.Scores} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\xrightarrow{\text{Scale}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.ScaledScores} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\xrightarrow{\text{Softmax}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.AttentionWeights} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                <div className={`formula-display ${shouldBreakEncDecHeadOutput ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.AttentionWeights} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.HeadOutput} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" /><BlockMath math="=" /><InteractiveSymbolicMatrix name={LNd.ConcatOutput_enc_dec} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InteractiveSymbolicMatrix name={LNd.ConcatOutput_enc_dec} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNd.Wo_enc_dec} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNd.enc_dec_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_2_dec" title="解码器组件:残差连接与层归一化 (2)" highlight={highlight}>
                <p>此步骤结合了编码器-解码器注意力子层的输入 (<InlineMath math="Y'"/>) 与其输出 (<InlineMath math="M_{ed}"/>),并进行层归一化,以稳定训练过程并融合来自编码器的信息。这是解码器层中信息融合的关键一步。</p>
                <BlockMath math={`Y'' = \\text{LayerNorm}(Y' + \\text{Enc-Dec-MHA}(Y', Z_{final}))`} />
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.enc_dec_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="ffn_dec" title="解码器子层3:前馈网络" highlight={highlight}>
                <p>与编码器中的 FFN 类似,解码器中的前馈网络 (FFN) 也对每个位置的向量 (<InlineMath math="Y''"/>) 独立地进行一次复杂的非线性变换,进一步增强模型的表达能力,为最终的输出预测做准备。在这一步，模型对融合了自身历史信息和编码器上下文信息的新向量进行深入的、非线性的“思考”。</p>
                <BlockMath math={`F = \\text{ReLU}(Y'' W_1 + b_1) W_2 + b_2`} />
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                    <BlockMath math="\times"/>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="viz-formula-row"><InteractiveSymbolicVector name={LNd.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="="/>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.Intermediate} rows={dims.decoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.Activated} rows={dims.decoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_3_dec" title="解码器组件:残差连接与层归一化 (3)" highlight={highlight}>
                <p>这是解码器层中的最后一个 Add & Norm 步骤,它将 FFN 的输入 (<InlineMath math="Y''"/>) 与其输出 (<InlineMath math="F"/>) 相结合,产生该解码器层的最终输出 <InlineMath math="Y_{final}"/>. 这个输出将作为下一个解码器层的输入，或者在最后一层，将进入最终的预测阶段。</p>
                <BlockMath math={`Y_{final} = \\text{LayerNorm}(Y'' + \\text{FFN}(Y''))`} />
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.ffn_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_3_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="final_output" title="最终输出层:线性层与Softmax" highlight={highlight}>
                <h5>做什么？</h5>
                <p>在经过所有解码器层的处理后,我们得到一个最终的输出矩阵。此步骤将其转换为每个位置上词汇表中所有单词的概率分布，将模型内部的抽象表示映射回人类可理解的词汇空间。</p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>线性层 (Linear Layer):</b> 将解码器输出矩阵通过一个大的线性投影层,将其维度从 <InlineMath math="d_{model}"/> 扩展到词汇表大小 (<InlineMath math="V_{size}"/>). 这会为每个位置生成一个分数向量,称为 Logits。这个Logits向量的每个元素对应词汇表中的一个词，其数值代表模型认为该词是下一个正确词的“置信度分数”，分数越高，可能性越大。</li>
                    <li><b>Softmax:</b> 对 Logits 矩阵的每一行应用 Softmax 函数,将其转换为规范的概率分布。转换后，每一行的所有元素和为1，每个元素代表对应单词的出现概率。</li>
                </ol>
                <div className={`formula-display ${shouldBreakFinalOutput ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={FinalLNd.add_norm_3_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.finalLinear} rows={dims.d_model} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                <div className="formula-display">
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.logits} rows={dims.decoder_seq_len} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                    <BlockMath math="\xrightarrow{\text{Softmax}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputProbabilities} rows={dims.decoder_seq_len} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick} sideLabel={true}/></div>
                </div>
                <p>现在,矩阵 <InlineMath math="P"/> 中的每一行都是一个概率分布,代表了在那个位置上生成词汇表中任何一个单词的可能性. </p>
            </MathBlock>
            <MathBlock id="decoding" title="最终解码:Argmax 与文本生成" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是生成过程的最后一步,将代表概率的数字变回人类可读的文本. </p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>Argmax:</b> 对概率矩阵 <InlineMath math="P"/> 的每一行,找到其中概率值最大的那个元素的<b>索引 (index)</b>. 这个索引就对应了词汇表中该位置最有可能的词元ID. 这个过程通常被称为“贪心解码 (Greedy Decoding)”. </li>
                    <li><b>ID到文本映射:</b> 将得到的词元ID序列,通过反向查询词汇表,映射回原始的文本词元. </li>
                </ol>
                <h5>深入理解:从向量到文本的“翻译”</h5>
                <p>这里是“魔法”发生逆转的地方. 我们手上有一个 <b>概率矩阵</b> <code>P</code>,它告诉我们在每个输出位置上,词汇表里每个单词的可能性. </p>
                <p>以第一个输出位置为例,我们关注矩阵 <code>P</code> 的<b>第一行</b> (下标为0的那一行). 这一行是一个概率向量,其长度等于整个词汇表的大小. 向量中第 <code>j</code> 个位置的数值,就代表词汇表中 ID 为 <code>j</code> 的单词是正确答案的概率. </p>
                <p><b>Argmax</b> 函数的作用非常简单:它会扫描这一整行,找到那个最大的概率值,然后返回它的<b>位置索引</b>. 这个索引就是模型预测出的 <b>Token ID！</b></p>
                <p>虽然贪心解码简单高效，但它只关注当前步的最优选择，可能会错失全局最优解。更高级的解码策略，如<b>集束搜索 (Beam Search)</b>，会同时保留多个最可能的候选序列，在生成结束时选择整体概率最高的序列，通常能产生更流畅、更合理的文本。</p>
                <p>最后一步,我们拿着这个ID,去反查我们的“超级词典”(词汇表),就能找到ID对应的单词. 于是,模型就成功地将一串概率数字“翻译”回了人类能懂的单词. 对每一行都重复这个过程,就能生成整个句子. </p>
            </MathBlock>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/Explanation.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/FeedForward.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/FeedForward.tsx
import React from 'react';
import { FFNData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { MATRIX_NAMES } from '../config/matrixNames';
import { InlineMath } from 'react-katex';

interface FFNProps {
    baseName: string;
    input: MatrixType;
    inputName: string;
    data: FFNData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const FeedForward: React.FC<FFNProps> = ({ baseName, input, inputName, data, highlight, onElementClick, onComponentClick }) => {
    const isEncoder = baseName.includes('encoder');
    const componentId = isEncoder ? 'ffn' : 'ffn_dec';
    const isActive = highlight.activeComponent === componentId;
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const LN = isEncoder ? MATRIX_NAMES.layer(layerIndex) : MATRIX_NAMES.decoderLayer(layerIndex);

    // --- Layout Breaking Logic ---
    const inputCols1 = input[0]?.length || 0;
    const w1Cols = data.W1[0]?.length || 0;
    const breakStep1 = inputCols1 > 8 || w1Cols > 8 || (inputCols1 + w1Cols > 15);

    const activatedCols = data.Activated[0]?.length || 0;
    const w2Cols = data.W2[0]?.length || 0;
    const breakStep2 = activatedCols > 8 || w2Cols > 8 || (activatedCols + w2Cols > 15);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick(componentId)}>Feed-Forward Network</div>
            <div className="component-body">
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. First Linear Layer & ReLU</div>
                     <div className={`viz-formula-row ${breakStep1 ? 'vertical' : ''}`}>
                         <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                         <span className="op-symbol">×</span>
                         <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b1} data={[data.b1]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.Intermediate} data={data.Intermediate} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    {/* [REMOVED] ElementwiseOperation for ReLU is now handled in tooltip */}
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{ReLU}}" /></div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Second Linear Layer</div>
                    <div className={`viz-formula-row ${breakStep2 ? 'vertical' : ''}`}>
                        <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                        <span className="op-symbol">×</span>
                        <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b2} data={[data.b2]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LN.ffn_output} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/FeedForward.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicElement.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicElement.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { HighlightState } from '../types';
import { useHighlighting } from '../hooks/useHighlighting';

interface InteractiveSymbolicElementProps {
  name: string; // [ADDED] Pass the full matrix name for the hook
  base: string;
  subscript?: string;
  row?: number;
  col?: number;
  highlight: HighlightState; // [ADDED] Pass the full highlight state
  onClick: (event: React.MouseEvent) => void;
}

export const InteractiveSymbolicElement: React.FC<InteractiveSymbolicElementProps> = React.memo(({ name, base, subscript, row, col, highlight, onClick }) => {
  // [MODIFIED] Centralized highlighting logic by using the new hook.
  // We handle undefined row/col for vectors.
  // [FIXED] Removed the 5th argument 'true' which caused the compilation error.
  const { isTarget, isSource, isDestination } = useHighlighting(name, row ?? 0, col ?? 0, highlight);

  const elementBase = base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
  const subscriptContent = [subscript, row, col].filter(s => s !== undefined && s !== null).join(',');
  const mathString = `${elementBase}_{${subscriptContent}}`;

  const className = `symbolic-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''} ${isDestination ? 'destination' : ''}`;

  return (
    <div className={className} onClick={onClick} style={{cursor: 'pointer'}}>
      <InlineMath math={mathString} />
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicElement.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicMatrix.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/InteractiveSymbolicMatrix.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../lib/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicMatrixProps {
    name: string;
    rows: number;
    cols: number;
    highlight: HighlightState;
    transpose?: boolean;
    truncate?: boolean;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    sideLabel?: boolean; // For explicit override
}

export const InteractiveSymbolicMatrix: React.FC<InteractiveSymbolicMatrixProps> = React.memo(({ name, rows, cols, highlight, transpose = false, truncate = true, onSymbolClick, sideLabel = false }) => {
    const displayRows = transpose ? cols : rows;
    const displayCols = transpose ? rows : cols;
    const symbol = getSymbolParts(name);

    let focusRow = -1;
    let focusCol = -1;

    if (highlight.target?.name === name) {
        focusRow = highlight.target.row;
        focusCol = highlight.target.col;
    }

    const highlightedTarget = (highlight.target?.name === name) ? highlight.target : null;

    const visibleRowIndices = truncate ? getVisibleIndices(displayRows, transpose ? focusCol : focusRow) : Array.from({ length: displayRows }, (_, i) => i);
    const visibleColIndices = truncate ? getVisibleIndices(displayCols, transpose ? focusRow : focusCol) : Array.from({ length: displayCols }, (_, i) => i);

    const isTargetMatrix = !!highlightedTarget;

    const gridStyle: React.CSSProperties = {
        gridTemplateColumns: isTargetMatrix
            ? `auto repeat(${visibleColIndices.length}, auto)`
            : `repeat(${visibleColIndices.length}, auto)`,
    };


    let mathSymbol = symbol.base;
    if (symbol.superscript) mathSymbol += `^{${symbol.superscript}}`;
    if (transpose) mathSymbol += '^T';

    const subscriptParts = [];
    if (symbol.subscript) {
        subscriptParts.push(symbol.subscript);
    }
    subscriptParts.push(`${rows} \\times ${cols}`);
    mathSymbol += `_{${subscriptParts.join(',')}}`;

    const matrixGrid = (
        <div className="symbolic-matrix-grid" style={gridStyle}>
            {isTargetMatrix && <div key="corner" />}
            {isTargetMatrix && visibleColIndices.map((c, cIdx) => (
                <div key={`ch-${cIdx}`} className="symbolic-header-item">{c}</div>
            ))}
            {visibleRowIndices.map((r, rIdx) => (
                <React.Fragment key={`row-frag-${rIdx}`}>
                    {isTargetMatrix && <div className="symbolic-header-item">{r}</div>}
                    {visibleColIndices.map((c, cIdx) => {
                        if (r === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                        if (c === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
                        const originalRow = transpose ? c : r;
                        const originalCol = transpose ? r : c;
                        return (
                            <InteractiveSymbolicElement
                                key={`elem-r${r}-c${c}`}
                                name={name}
                                base={symbol.base}
                                subscript={symbol.subscript}
                                row={originalRow}
                                col={originalCol}
                                highlight={highlight}
                                onClick={(event) => onSymbolClick({ name, row: originalRow, col: originalCol }, event)}
                            />
                        );
                    })}
                </React.Fragment>
            ))}
        </div>
    );

    return (
        <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`}>
            {/* [MODIFIED] Applied the .matrix-symbol-tag wrapper */}
            <div className="matrix-label-side">
                <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
            </div>
            <div className="symbolic-matrix-container">
                {matrixGrid}
            </div>
            {/* [MODIFIED] Applied the .matrix-symbol-tag wrapper */}
            <div className="matrix-label-container">
                <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
            </div>
        </div>
    );
});
// END OF FILE: src/topics/transformer-explorer/components/InteractiveSymbolicMatrix.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicVector.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/InteractiveSymbolicVector.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { Vector as VectorType } from '../types';
import { getSymbolParts } from '../lib/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicVectorProps {
    name: string;
    data: VectorType;
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    sideLabel?: boolean; // For explicit override
}

export const InteractiveSymbolicVector: React.FC<InteractiveSymbolicVectorProps> = React.memo(({ name, data, highlight, onSymbolClick, sideLabel = false }) => {
    const displayCols = data.length;
    const symbol = getSymbolParts(name);

    let focusCol = -1;
    if (highlight.target?.name === name) {
        focusCol = highlight.target.col;
    }

    const visibleColIndices = getVisibleIndices(displayCols, focusCol);

    const gridElements = visibleColIndices.map((c, cIdx) => {
        if (c === ELLIPSIS) {
            return <div key={`ellipsis-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
        }

        return (
            <InteractiveSymbolicElement
                key={`elem-${c}`}
                name={name}
                base={symbol.base}
                subscript={symbol.subscript}
                col={c}
                highlight={highlight}
                onClick={(event) => onSymbolClick({ name, row: 0, col: c }, event)}
            />
        );
    });

    let mathSymbol = symbol.base;

    const subscriptParts = [];
    if (symbol.subscript) {
        subscriptParts.push(symbol.subscript);
    }
    subscriptParts.push(`1 \\times ${displayCols}`);
    mathSymbol += `_{${subscriptParts.join(',')}}`;

    const matrixGrid = (
        <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${gridElements.length}, auto)` }}>
            {gridElements}
        </div>
    );

    return (
        <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`}>
            {/* [MODIFIED] Applied the .matrix-symbol-tag wrapper */}
            <div className="matrix-label-side">
                <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
            </div>
            <div className="symbolic-matrix-container">
                {matrixGrid}
            </div>
            {/* [MODIFIED] Applied the .matrix-symbol-tag wrapper */}
            <div className="matrix-label-container">
                <div className="matrix-symbol-tag"><InlineMath math={mathSymbol} /></div>
            </div>
        </div>
    );
});
// END OF FILE: src/topics/transformer-explorer/components/InteractiveSymbolicVector.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/MaskedMultiHeadAttention.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/MaskedMultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';

interface MHAProps {
    baseName: string; // e.g., decoder.0.masked_mha
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MaskedMultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick, onComponentClick }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Assume we visualize head 0
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'masked_mha';
    const LNd = MATRIX_NAMES.decoderLayer(layerIndex);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex);
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.maskedMhaHead(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        if (numHeads > 2) {
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.maskedMhaHead(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.maskedMhaHead(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('masked_mha')}>Masked Multi-Head Attention</div>
            <div className="component-body">
                {/* Visualizations for Q, K, V generation */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                    <div className="viz-formula-row">
                        <span>(Input) ×</span>
                        <Matrix name={HNd_masked.Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNd_masked.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="viz-formula-row">
                        <span>(Input) ×</span>
                        <Matrix name={HNd_masked.Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNd_masked.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="viz-formula-row">
                        <span>(Input) ×</span>
                        <Matrix name={HNd_masked.Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNd_masked.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                {/* Scaled Dot-Product Attention */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={HNd_masked.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">= (Scores)</div>
                    <div className="arrow-down" style={{fontSize: '1em', color: '#e63946', fontWeight: 'bold'}}>Apply Look-Ahead Mask</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    {/* [REMOVED] ElementwiseOperation for Softmax is now handled in tooltip */}
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Softmax}}" /></div>

                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={HNd_masked.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat Heads</div>
                    <div className="viz-formula-row">
                        <InlineMath math="\text{Concat}(" />
                        {renderConcatHeads()}
                        <InlineMath math=")" />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LNd.ConcatOutput_masked} data={data.ConcatOutput} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">4. Final Projection</div>
                    <div className="viz-formula-row">
                        <Matrix name={LNd.ConcatOutput_masked} data={data.ConcatOutput} highlight={highlight} onElementClick={onElementClick} />
                        <span className="op-symbol">×</span>
                        <Matrix name={LNd.Wo_masked} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LNd.masked_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

            </div>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/MaskedMultiHeadAttention.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/Matrix.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../lib/symbolMapping';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isTransposed?: boolean;
  sideLabel?: boolean; // For explicit override
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, isTransposed = false, sideLabel = false }) => {

  const maxProbCols = React.useMemo(() => {
    const maxCols: { [key: number]: number } = {};
    if (!data) return maxCols;

    const probSources = highlight.sources.filter(s => s.name === name && s.highlightProbCol);
    for (const source of probSources) {
        if (source.row !== -1 && data[source.row]) {
            const rowData = data[source.row];
            const maxVal = Math.max(...rowData);
            maxCols[source.row] = rowData.indexOf(maxVal);
        }
    }
    return maxCols;
  }, [highlight.sources, name, data]);

  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const numRows = data.length;
  const numCols = data[0].length;

  const displayRows = isTransposed ? numCols : numRows;
  const displayCols = isTransposed ? numRows : numCols;

  let focusRow = -1;
  let focusCol = -1;

  if(highlight.target?.name === name && !highlight.target.isInternal) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const relevantSource = highlight.sources.find(s => s.name === name && !s.isInternal);
  if (relevantSource) {
      focusRow = relevantSource.row === -1 ? focusRow : relevantSource.row;
      focusCol = relevantSource.col === -1 ? focusCol : relevantSource.col;
  }

  const relevantDestination = highlight.destinations?.find(d => d.name === name && !d.isInternal);
    if (relevantDestination) {
        focusRow = relevantDestination.row === -1 ? focusRow : relevantDestination.row;
        focusCol = relevantDestination.col === -1 ? focusCol : relevantDestination.col;
    }

  const visibleRowIndices = getVisibleIndices(displayRows, isTransposed ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, isTransposed ? focusRow : focusCol);

  const symbolParts = getSymbolParts(name);
  let mathSymbol = symbolParts.base;
  if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
  if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;
  if(isTransposed) mathSymbol = `${mathSymbol}^T`;

  const isTargetMatrix = highlight.target?.name === name && !highlight.target.isInternal;

   const gridContainerStyle: React.CSSProperties = {
      gridTemplateColumns: isTargetMatrix
          ? `auto repeat(${visibleColIndices.length}, auto)`
          : `repeat(${visibleColIndices.length}, auto)`,
  };

  const matrixGrid = (
      <div className="matrix-container">
        <div className="matrix-grid" data-name={name} style={gridContainerStyle}>
            {isTargetMatrix && <div key="corner" />}
            {isTargetMatrix && visibleColIndices.map((c, cIdx) => (
                <div key={`ch-${cIdx}`} className="matrix-header-item">{c}</div>
            ))}
            {visibleRowIndices.map((r, rIdx) => (
                <React.Fragment key={`row-frag-${rIdx}`}>
                    {isTargetMatrix && <div className="matrix-header-item">{r}</div>}
                    {visibleColIndices.map((c, cIdx) => {
                        if (r === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                        if (c === ELLIPSIS) return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">…</div>;
                        const originalRow = isTransposed ? c : r;
                        const originalCol = isTransposed ? r : c;
                        return (
                            <Element
                                key={`${name}-${originalRow}-${originalCol}`}
                                name={name}
                                row={originalRow}
                                col={originalCol}
                                value={data[originalRow][originalCol]}
                                highlight={highlight}
                                onElementClick={onElementClick}
                                isProbMax={maxProbCols[originalRow] === originalCol}
                            />
                        );
                    })}
                </React.Fragment>
            ))}
        </div>
      </div>
  );

  return (
    <div className={`matrix-wrapper ${sideLabel ? 'side-label' : ''}`} data-name={name}>
        <div className="matrix-label-side">
            <div className="matrix-symbol-tag"><InlineMath>{mathSymbol}</InlineMath></div>
        </div>
        {matrixGrid}
        <div className="matrix-label-container">
            <div className="matrix-symbol-tag"><InlineMath>{mathSymbol}</InlineMath></div>
        </div>
    </div>
  );
};
// END OF FILE: src/topics/transformer-explorer/components/Matrix.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/MultiHeadAttention.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/MultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';

interface MHAProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick, onComponentClick }) => {
    const headData = data.heads[0];
    const isActive = highlight.activeComponent === 'mha';

    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Visualizing head 0
    const LN = MATRIX_NAMES.layer(layerIndex);
    const HNe = MATRIX_NAMES.head(layerIndex, headIndex);
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.head(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        if (numHeads > 2) {
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.head(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.head(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };

    const inputCols = data.heads[0].Wq.length;
    const wqCols = headData.Wq[0]?.length || 0;
    const breakQ = inputCols > 8 || wqCols > 8 || (inputCols + wqCols > 15);

    const wkCols = headData.Wk[0]?.length || 0;
    const breakK = inputCols > 8 || wkCols > 8 || (inputCols + wkCols > 15);

    const wvCols = headData.Wv[0]?.length || 0;
    const breakV = inputCols > 8 || wvCols > 8 || (inputCols + wvCols > 15);

    const qCols = headData.Q[0]?.length || 0;
    const kTransposedCols = headData.K.length;
    const breakScores = qCols > 8 || kTransposedCols > 8 || (qCols + kTransposedCols > 15);

    const attnWeightsCols = headData.AttentionWeights[0]?.length || 0;
    const vCols = headData.V[0]?.length || 0;
    const breakHeadOutput = attnWeightsCols > 8 || vCols > 8 || (attnWeightsCols + vCols > 15);

    const concatOutputCols = data.ConcatOutput[0]?.length || 0;
    const woCols = data.Wo[0]?.length || 0;
    const breakFinalProj = concatOutputCols > 8 || woCols > 8 || (concatOutputCols + woCols > 15);


    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('mha')}>Multi-Head Attention</div>
            <div className="component-body">

                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Showing Head 0 as example)</div>
                    <div className={`viz-formula-row ${breakQ ? 'vertical' : ''}`}>
                        <span>(Input) ×</span>
                        <Matrix name={HNe.Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNe.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className={`viz-formula-row ${breakK ? 'vertical' : ''}`}>
                        <span>(Input) ×</span>
                        <Matrix name={HNe.Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNe.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className={`viz-formula-row ${breakV ? 'vertical' : ''}`}>
                        <span>(Input) ×</span>
                        <Matrix name={HNe.Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                        <Matrix name={HNe.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 0)</div>
                    <div className={`viz-formula-row ${breakScores ? 'vertical' : ''}`}>
                        <Matrix name={HNe.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={HNe.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Softmax}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className={`viz-formula-row ${breakHeadOutput ? 'vertical' : ''}`}>
                        <Matrix name={HNe.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={HNe.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat Heads</div>
                    <div className="viz-formula-row">
                        <InlineMath math="\text{Concat}(" />
                        {renderConcatHeads()}
                        <InlineMath math=")" />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LN.ConcatOutput} data={data.ConcatOutput} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">4. Final Projection</div>
                    <div className={`viz-formula-row ${breakFinalProj ? 'vertical' : ''}`}>
                        <Matrix name={LN.ConcatOutput} data={data.ConcatOutput} highlight={highlight} onElementClick={onElementClick} />
                        <span className="op-symbol">×</span>
                        <Matrix name={LN.Wo} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LN.mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/MultiHeadAttention.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/ResidualBlock.tsx
================================================================================

// FILE: src/components/ResidualBlock.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';
import { InlineMath } from 'react-katex';

interface ResidualBlockProps {
  id: string; // e.g., "res1"
  type: 'start' | 'end';
  matrixSymbol: string;
  matrixDims: string;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const ResidualBlock: React.FC<ResidualBlockProps> = ({ id, type, matrixSymbol, matrixDims, highlight, onElementClick }) => {
  const isActive = highlight.activeResidual === id;
  const isStart = type === 'start';
  const icon = isStart ? '↓' : '←'; // [MODIFIED] Changed end icon to left arrow

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({
      name: `residual.${id}.${type}`,
      row: -1,
      col: -1,
      matrixSymbol,
      matrixDims,
    }, event);
  };

  return (
    <div
      className={`residual-block ${isActive ? 'active' : ''}`}
      onClick={handleClick}
      title={`Residual Connection (${matrixSymbol})`}
    >
      <div className="residual-icon">{icon}</div>
      <div className="residual-info">
          <div className="residual-matrix-symbol"><InlineMath math={matrixSymbol} /></div>
          <div className="residual-matrix-dims">{matrixDims}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/ResidualBlock.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/Token.tsx
================================================================================

// FILE: src/components/Token.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';

interface TokenProps {
  tokenStr: string;
  tokenId: number;
  position: number;
  name: string; // "inputToken" or "outputToken"
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const Token: React.FC<TokenProps> = ({
  tokenStr,
  tokenId,
  position,
  name,
  highlight,
  onElementClick,
}) => {
  const isTarget =
    highlight.target?.name === name && highlight.target?.row === position;
  const isSource = highlight.sources.some(
    (s) => s.name === name && s.row === position
  );

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({ name, row: position, col: -1, tokenStr, tokenId }, event);
  };

  const className = `token-container ${isTarget ? 'target' : ''} ${
    isSource ? 'source' : ''
  }`;

  return (
    <div className={className} onClick={handleClick}>
      <div className="token-text">{tokenStr}</div>
      <div className="token-id">ID: {tokenId}</div>
    </div>
  );
};
// END OF FILE: src/components/Token.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/TokenizationEmbedding.tsx
================================================================================

// FILE: src/components/TokenizationEmbedding.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EmbeddingLookup } from './EmbeddingLookup';

interface TokenizationEmbeddingProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    isActive: boolean;
}

export const TokenizationEmbedding: React.FC<TokenizationEmbeddingProps> = ({ data, highlight, onElementClick, onComponentClick, isActive }) => {
    // Create a list of ElementIdentifier for the input tokens
    const inputTokensForLookup: ElementIdentifier[] = data.inputText.map((token, i) => ({
        name: "inputToken",
        row: i,
        col: -1, // Not a cell in a matrix
        tokenId: data.tokenizedInput[i],
        tokenStr: token
    }));

    const shouldBreak = (data.embeddingMatrix[0]?.length || 0) > 10;

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('token_embed')}>Input: Tokenization & Embedding Lookup</div>
            <div className="component-body">
                <div className="viz-step-title">1. Text is tokenized, then each Token ID looks up its vector in the Embedding Matrix</div>
                <p style={{textAlign: 'center', margin: '0 0 10px 0', fontSize: '0.9em', color: '#555'}}>Click a Token to see its corresponding row in the Embedding Matrix.</p>
                <EmbeddingLookup
                    mode="token-to-vector"
                    tokens={inputTokensForLookup}
                    embeddingMatrix={data.embeddingMatrix}
                    matrixName="embeddingMatrix"
                    outputVectors={data.inputEmbeddings}
                    outputMatrixName="inputEmbeddings"
                    highlight={highlight}
                    onElementClick={onElementClick}
                    shouldBreak={shouldBreak}
                />
            </div>
        </div>
    );
};
// END OF FILE: src/components/TokenizationEmbedding.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/components/Viz.tsx
================================================================================

// FILE: src/topics/transformer-explorer/components/Viz.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EncoderLayer } from './EncoderLayer';
import { DecoderLayer } from './DecoderLayer';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { TokenizationEmbedding } from './TokenizationEmbedding';
import { Decoding } from './Decoding';
import { MATRIX_NAMES } from '../config/matrixNames';

interface VizProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const Viz: React.FC<VizProps> = ({ data, highlight, onElementClick, onComponentClick }) => {
    const isTokenEmbedActive = highlight.activeComponent === 'token_embed';
    const isInputEmbedActive = highlight.activeComponent === 'input_embed';
    const isOutputEmbedActive = highlight.activeComponent === 'output_embed';
    const isFinalOutputActive = highlight.activeComponent === 'final_output';
    const isDecodingActive = highlight.activeComponent === 'decoding';

    const cols = data.inputEmbeddings[0]?.length || 0;
    const shouldBreak = cols > 15;

    return (
        <div style={{ position: 'relative' }}>
            {/* Tooltip and AnimationPanel are now managed in TransformerExplorerTopic.tsx */}

            {/* --- Input Stage --- */}
            <TokenizationEmbedding
                data={data}
                highlight={highlight}
                onElementClick={onElementClick}
                onComponentClick={onComponentClick}
                isActive={isTokenEmbedActive}
            />

            <div className="arrow-down">↓</div>

            {/* --- Encoder Side --- */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('input_embed')}>Positional Encoding Addition</div>
                <div className="component-body">
                    {shouldBreak ? (
                         <>
                            <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                            <div className="op-symbol">+</div>
                            <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                         </>
                    ) : (
                        <div className="viz-formula-row">
                             <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                             <div className="op-symbol">+</div>
                             <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                </div>
            </div>

            <div className="arrow-down">↓</div>

            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                 <div className="component-header" onClick={() => onComponentClick('input_embed')}>Encoder Input (<InlineMath math="Z" />)</div>
                <div className="component-body">
                     <Matrix name={MATRIX_NAMES.layer(0).encoder_input} data={data.encoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.encoderLayers.map((layer, i) => (
                <EncoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
            ))}

            {/* --- Decoder Side --- */}
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`} style={{marginTop: '30px'}}>
                <div className="component-header" onClick={() => onComponentClick('output_embed')}>Decoder Input & Positional Encoding</div>
                <div className="component-body">
                     <div className="viz-formula-row">
                         <Matrix name="outputEmbeddings" data={data.outputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                         <div className="op-symbol">+</div>
                         <Matrix name="decoderPosEncodings" data={data.decoderPosEncodings} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
            <div className="arrow-down">↓</div>
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('output_embed')}>Decoder Input (<InlineMath math="Y" />)</div>
                <div className="component-body">
                     <Matrix name={MATRIX_NAMES.decoderLayer(0).decoder_input} data={data.decoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.decoderLayers.map((layer, i) => (
                <DecoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    finalEncoderOutput={data.finalEncoderOutput}
                />
            ))}

            {/* --- Final Output --- */}
            <div className="arrow-down">↓</div>
             <div className={`diagram-component ${isFinalOutputActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('final_output')}>Final Linear & Softmax</div>
                <div className="component-body">
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.decoderLayer(data.decoderLayers.length - 1).add_norm_3_output} data={data.finalDecoderOutput} highlight={highlight} onElementClick={onElementClick} />
                         <div className="op-symbol">×</div>
                         <Matrix name="finalLinear" data={data.finalLinear} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">= (Logits)</div>
                    <Matrix name="logits" data={data.logits} highlight={highlight} onElementClick={onElementClick} />
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Softmax}}" /></div>
                    <Matrix name="outputProbabilities" data={data.outputProbabilities} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {/* --- Decoding Stage --- */}
            <div className="arrow-down">↓</div>
            <Decoding
                data={data}
                highlight={highlight}
                onElementClick={onElementClick}
                onComponentClick={onComponentClick}
                isActive={isDecodingActive}
            />

        </div>
    );
};
// END OF FILE: src/topics/transformer-explorer/components/Viz.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/config/matrixNames.ts
================================================================================

// FILE: src/topics/transformer-explorer/config/matrixNames.ts
// This file is the single source of truth for all matrix and vector names.

const generateHeadNames = (base: string) => ({
    Wq: `${base}.Wq`, Wk: `${base}.Wk`, Wv: `${base}.Wv`,
    Q: `${base}.Q`, K: `${base}.K`, V: `${base}.V`,
    Scores: `${base}.Scores`, ScaledScores: `${base}.ScaledScores`,
    AttentionWeights: `${base}.AttentionWeights`, HeadOutput: `${base}.HeadOutput`,
});

export const MATRIX_NAMES = {
    // Input
    inputEmbeddings: 'inputEmbeddings',
    posEncodings: 'posEncodings',
    encoderInput: 'encoderInput', // Deprecated, use layer(0).encoder_input
    finalEncoderOutput: 'finalEncoderOutput',

    // Encoder Layer
    layer: (layerIndex: number) => ({
        encoder_input: `encoder.${layerIndex}.encoder_input`,
        mha_output: `encoder.${layerIndex}.mha.output`,
        Wo: `encoder.${layerIndex}.mha.Wo`,
        ConcatOutput: `encoder.${layerIndex}.mha.ConcatOutput`,
        add_norm_1_output: `encoder.${layerIndex}.add_norm_1_output`,
        W1: `encoder.${layerIndex}.ffn.W1`, b1: `encoder.${layerIndex}.ffn.b1`,
        Intermediate: `encoder.${layerIndex}.ffn.Intermediate`, Activated: `encoder.${layerIndex}.ffn.Activated`,
        W2: `encoder.${layerIndex}.ffn.W2`, b2: `encoder.${layerIndex}.ffn.b2`,
        ffn_output: `encoder.${layerIndex}.ffn.output`,
        add_norm_2_output: `encoder.${layerIndex}.add_norm_2_output`,
    }),

    // Encoder Head
    head: (layerIndex: number, headIndex: number) => generateHeadNames(`encoder.${layerIndex}.mha.h${headIndex}`),
    concatOutput: (layerIndex: number) => `encoder.${layerIndex}.mha.ConcatOutput`,

    // Decoder Input
    outputEmbeddings: 'outputEmbeddings',
    decoderPosEncodings: 'decoderPosEncodings',
    decoderInput: 'decoderInput', // Deprecated, use decoderLayer(0).decoder_input

    // Decoder Layer
    decoderLayer: (layerIndex: number) => ({
        decoder_input: `decoder.${layerIndex}.decoder_input`,

        masked_mha_output: `decoder.${layerIndex}.masked_mha.output`,
        Wo_masked: `decoder.${layerIndex}.masked_mha.Wo`,
        ConcatOutput_masked: `decoder.${layerIndex}.masked_mha.ConcatOutput`,
        add_norm_1_output: `decoder.${layerIndex}.add_norm_1_output`,

        enc_dec_mha_output: `decoder.${layerIndex}.enc_dec_mha.output`,
        Wo_enc_dec: `decoder.${layerIndex}.enc_dec_mha.Wo`,
        ConcatOutput_enc_dec: `decoder.${layerIndex}.enc_dec_mha.ConcatOutput`,
        add_norm_2_output: `decoder.${layerIndex}.add_norm_2_output`,

        W1: `decoder.${layerIndex}.ffn.W1`, b1: `decoder.${layerIndex}.ffn.b1`,
        Intermediate: `decoder.${layerIndex}.ffn.Intermediate`, Activated: `decoder.${layerIndex}.ffn.Activated`,
        W2: `decoder.${layerIndex}.ffn.W2`, b2: `decoder.${layerIndex}.ffn.b2`,
        ffn_output: `decoder.${layerIndex}.ffn.output`,
        add_norm_3_output: `decoder.${layerIndex}.add_norm_3_output`,
    }),

    // Decoder Heads
    maskedMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.masked_mha.h${headIndex}`),
    encDecMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.enc_dec_mha.h${headIndex}`),

    // Final Output
    finalLinear: 'finalLinear',
    logits: 'logits',
    outputProbabilities: 'outputProbabilities',
};
// END OF FILE: src/topics/transformer-explorer/config/matrixNames.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/hooks/useHighlighting.ts
================================================================================

// FILE: src/hooks/useHighlighting.ts
import { useMemo } from 'react';
import { HighlightState } from '../types';

/**
 * A centralized hook to determine the highlight status of an element.
 * This prevents logic duplication and ensures consistent highlighting behavior
 * across the entire application (e.g., in Viz.tsx and Explanation.tsx).
 *
 * @param name - The unique name of the component's matrix/vector.
 * @param row - The row index of the element.
 * @param col - The column index of the element.
 * @param highlight - The global highlight state object.
 * @returns An object { isTarget, isSource, isDestination } indicating the element's highlight status.
 */
export const useHighlighting = (
  name: string,
  row: number,
  col: number,
  highlight: HighlightState
) => {
  return useMemo(() => {
    const { target, sources, destinations } = highlight;

    // Check if this element is the primary target
    const isTarget =
      !!target &&
      target.name === name &&
      target.row === row &&
      target.col === col &&
      !target.isInternal;

    // Check if this element is a source
    const isSource = sources.some(s => {
      if (s.name !== name || s.isInternal) return false;

      // [FIXED] Correctly handle row, column, and single-cell highlighting.
      if (s.highlightRow && s.highlightCol) {
          // This case means the entire matrix is a source, e.g., for residual connections.
          return true;
      }
      if (s.highlightRow) {
          return s.row === row;
      }
      if (s.highlightCol) {
          return s.col === col;
      }
      // Default to single-cell check if no specific highlight type is given
      return s.row === row && s.col === col;
    });

    // Check if this element is a destination
    const isDestination = (destinations || []).some(d => {
       if (d.name !== name || d.isInternal) return false;

       if (d.highlightRow && d.highlightCol) {
          return true;
       }
       if (d.highlightRow) {
           return d.row === row;
       }
       if (d.highlightCol) {
           return d.col === col;
       }
       return d.row === row && d.col === col;
    });

    return { isTarget, isSource, isDestination };
  // The dependency array is correct as we are only using props passed to the hook.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [name, row, col, highlight]);
};
// END OF FILE: src/hooks/useHighlighting.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/hooks/useTransformer.ts
================================================================================

// FILE: src/hooks/useTransformer.ts
import { useMemo } from 'react';
import { TransformerData } from '../types';
import { calculateTransformer } from '../lib/transformer';

// --- Main Hook ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number; // Decoder sequence length
    n_layers: number;
    d_ff: number;
}

/**
 * A React hook that calculates the entire state of a Transformer model.
 * It uses a deterministic calculation function from `lib/transformer` and
 * memoizes the result to avoid re-computation on every render.
 *
 * @param inputText - The input sentence for the encoder.
 * @param dims - The dimensions of the Transformer model.
 * @returns A `TransformerData` object containing all intermediate matrices,
 *          or `null` if the dimensions are invalid or a calculation error occurs.
 */
export const useTransformer = (inputText: string, dims: Dims): TransformerData | null => {
  return useMemo(() => {
    if (!inputText.trim()) {
        return null; // Return null if input is empty to avoid calculation errors
    }
    try {
      // The core logic is now delegated to a pure function.
      // This makes the hook cleaner and separates concerns.
      // The heavy computation is in `calculateTransformer`.
      const transformerData = calculateTransformer(inputText, dims);
      return transformerData;
    } catch (e) {
      console.error("Error during transformer calculation:", e);
      // If any error occurs during the complex calculation,
      // return null to indicate failure to the UI.
      return null;
    }
  }, [inputText, dims]); // The hook will only re-run if the dimensions or input text change.
};
// END OF FILE: src/hooks/useTransformer.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/lib/fixedWeights.ts
================================================================================

// FILE: lib/fixedWeights.ts
// This file provides a deterministic set of weights for the Transformer model.
// All values are hardcoded to ensure the visualization is reproducible.
// This replaces the previous random number generation.

interface Dims {
    d_model: number;
    h: number;
    seq_len: number;
    n_layers: number;
    d_ff: number;
}

// A simple seeding function for pseudo-random but deterministic numbers.
const createSeededRandom = (seed: number) => {
    let state = seed;
    return () => {
        state = (state * 9301 + 49297) % 233280;
        return (state / 233280.0) * 2 - 1; // Return value between -1 and 1
    };
};

const createFixedMatrix = (rows: number, cols: number, seed: number): number[][] => {
    const random = createSeededRandom(seed);
    return Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => random())
    );
};

const createFixedVector = (size: number, seed: number): number[] => {
    const random = createSeededRandom(seed);
    return Array.from({ length: size }, () => random());
};

export const fixedWeights = (dims: Dims) => {
    const { d_model, h, n_layers, d_ff, seq_len } = dims;
    const d_k = d_model / h;

    const VOCAB_SIZE = 16;
    const vocab: { [key: number]: string } = {
        0: '<PAD>', 1: '<SOS>', 2: '<EOS>', 3: 'I', 4: 'am', 5: 'a', 6: 'student',
        7: '我', 8: '是', 9: '一个', 10: '学生', 11: 'he', 12: 'she', 13: 'is',
        14: 'good', 15: '[UNK]'
    };

    const embeddingMatrix = createFixedMatrix(VOCAB_SIZE, d_model, 1);
    const posEncodings = Array.from({ length: 10 }, (_, pos) => // Max seq_len of 10
      Array.from({ length: d_model }, (_, i) =>
        i % 2 === 0
          ? Math.sin(pos / (10000 ** (i / d_model)))
          : Math.cos(pos / (10000 ** ((i - 1) / d_model)))
      )
    );

    const encoderLayers = Array.from({ length: n_layers }, (_, l) => ({
        mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 150 + l),
        },
        ffn: {
            W1: createFixedMatrix(d_model, d_ff, 200 + l * 2 + 0),
            b1: createFixedVector(d_ff, 201 + l * 2 + 0),
            W2: createFixedMatrix(d_ff, d_model, 200 + l * 2 + 1),
            b2: createFixedVector(d_model, 201 + l * 2 + 1),
        },
    }));

    const decoderLayers = Array.from({ length: n_layers }, (_, l) => ({
        masked_mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 350 + l),
        },
        enc_dec_mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 450 + l),
        },
        ffn: {
            W1: createFixedMatrix(d_model, d_ff, 500 + l * 2 + 0),
            b1: createFixedVector(d_ff, 501 + l * 2 + 0),
            W2: createFixedMatrix(d_ff, d_model, 500 + l * 2 + 1),
            b2: createFixedVector(d_model, 501 + l * 2 + 1),
        },
    }));

    const finalLinear = createFixedMatrix(d_model, VOCAB_SIZE, 999);

    return {
        vocab,
        embeddingMatrix,
        posEncodings,
        encoderLayers,
        decoderLayers,
        finalLinear,
    };
};
// END OF FILE: lib/fixedWeights.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/lib/symbolMapping.ts
================================================================================

// FILE: src/topics/transformer-explorer/lib/symbolMapping.ts
interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

export const getSymbolParts = (name: string): SymbolParts => {
    const conceptualName = name.split('.').pop() || '';
    const nameParts = name.split('.');

    const baseMap: { [key: string]: string } = {
        inputEmbeddings: 'E', posEncodings: 'PE',
        Wq: 'W', Wk: 'W', Wv: 'W', Wo: 'W',
        Q: 'Q', K: 'K', V: 'V',
        Scores: 'S', ScaledScores: "S'", AttentionWeights: 'A', HeadOutput: 'H',
        W1: 'W', b1: 'b', Intermediate: 'H_{ffn}', Activated: 'H_{act}',
        W2: 'W', b2: 'b', ffn_output: 'F',
        outputEmbeddings: 'E_{out}', decoderPosEncodings: 'PE_{dec}',
        finalLinear: 'W_{proj}', logits: 'L', outputProbabilities: 'P',
        embeddingMatrix: 'E_{table}'
    };

    let base = baseMap[conceptualName] || 'X';
    let superscript: string | undefined = undefined;
    let newSubscripts: (string | number)[] = [];

    // Extract existing subscript from base, e.g., H_{ffn} -> base: H, newSubscripts: ['ffn']
    const baseMatch = base.match(/([A-Za-z']+)_\{(.*)\}/);
    if (baseMatch) {
        base = baseMatch[1];
        newSubscripts.push(baseMatch[2]);
    }


    const layerMatch = name.match(/\.(encoder|decoder)\.(\d+)/);
    const headMatch = name.match(/\.h(\d+)\./);
    const layerIndex = layerMatch ? parseInt(layerMatch[2], 10) : undefined;
    const headIndex = headMatch ? parseInt(headMatch[1], 10) : undefined;
    const isDecoder = name.includes('decoder');

    if (conceptualName.startsWith('W')) {
        if (['Wq', 'Wk', 'Wv'].includes(conceptualName)) superscript = conceptualName.charAt(1).toUpperCase();
        else if (conceptualName.includes('Wo')) superscript = 'O';
        else if (conceptualName === 'W1') newSubscripts.push('1');
        else if (conceptualName === 'W2') newSubscripts.push('2');
    } else if (conceptualName.startsWith('b')) {
        newSubscripts.push(conceptualName.charAt(1));
    }

    if (['Q', 'K', 'V', 'Scores', 'ScaledScores', 'AttentionWeights', 'HeadOutput'].includes(conceptualName)) {
        if (headIndex !== undefined) newSubscripts.push(headIndex);
    }

    if (['encoder_input', 'decoder_input'].includes(conceptualName)) {
        base = isDecoder ? 'Y' : 'Z';
        if (layerIndex !== undefined) newSubscripts.push(layerIndex);
    }

    if (conceptualName.startsWith('add_norm_')) {
        const num = conceptualName.split('_').pop()![0];
        base = isDecoder ? 'Y' : 'Z';
        superscript = "'".repeat(parseInt(num, 10));
        if (layerIndex !== undefined) newSubscripts.push(`l${layerIndex}`);
    }

    if (['mha_output', 'masked_mha_output', 'enc_dec_mha_output'].includes(conceptualName)) {
        base = 'M';
        if (conceptualName.includes('masked')) newSubscripts.push('mmha');
        else if (conceptualName.includes('enc_dec')) newSubscripts.push('ed');
        if (layerIndex !== undefined) newSubscripts.push(`l${layerIndex}`);
    }

    const subscript = newSubscripts.length > 0 ? newSubscripts.join(',') : undefined;

    return { base, superscript, subscript };
};
// END OF FILE: src/topics/transformer-explorer/lib/symbolMapping.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/lib/tokenizer.ts
================================================================================

// FILE: src/lib/tokenizer.ts
/**
 * A simple whitespace tokenizer.
 * Splits text by spaces and removes empty strings.
 * @param text The input string.
 * @returns An array of tokens.
 */
export const whitespaceTokenizer = (text: string): string[] => {
    return text.trim().split(/\s+/).filter(Boolean);
};

// END OF FILE: src/lib/tokenizer.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/lib/tracing.ts
================================================================================

// FILE: src/topics/transformer-explorer/lib/tracing.ts

import { ElementIdentifier, HighlightSource, HighlightState, TransformerData, Matrix } from '../types';
import { TooltipState } from '../../../components/CalculationTooltip/types';
import { MATRIX_NAMES } from '../config/matrixNames';
import { getSymbolParts } from './symbolMapping';

const getLayerAndHeadIndices = (name: string): [number, number] => {
    const layerIdxMatch = name.match(/\.(encoder|decoder)\.(\d+)/);
    const layerIdx = layerIdxMatch ? parseInt(layerIdxMatch[2], 10) : 0;
    const headIdxMatch = name.match(/\.h(\d+)\./);
    const headIdx = headIdxMatch ? parseInt(headIdxMatch[1], 10) : 0;
    return [layerIdx, headIdx];
};

const getMatrixByName = (name: string, data: TransformerData, l: number, h: number): Matrix | undefined => {
    const LNe = MATRIX_NAMES.layer(l);
    const HNe = MATRIX_NAMES.head(l, h);
    const LNd = MATRIX_NAMES.decoderLayer(l);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(l, h);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(l, h);

    if (name === MATRIX_NAMES.inputEmbeddings) return data.inputEmbeddings;
    if (name === MATRIX_NAMES.posEncodings) return data.posEncodings;
    if (name === MATRIX_NAMES.outputEmbeddings) return data.outputEmbeddings;
    if (name === MATRIX_NAMES.decoderPosEncodings) return data.decoderPosEncodings;
    if (name === MATRIX_NAMES.finalEncoderOutput) return data.finalEncoderOutput;
    if (name === MATRIX_NAMES.logits) return data.logits;
    if (name === MATRIX_NAMES.outputProbabilities) return data.outputProbabilities;
    if (name === MATRIX_NAMES.finalLinear) return data.finalLinear;
    if (name === "embeddingMatrix") return data.embeddingMatrix;


    const encLayer = data.encoderLayers[l];
    if (encLayer) {
        if (name === LNe.encoder_input) return encLayer.encoder_input;
        if (name === LNe.mha_output) return encLayer.mha.output;
        if (name === LNe.Wo) return encLayer.mha.Wo;
        if (name === LNe.ConcatOutput) return encLayer.mha.ConcatOutput;
        if (name === LNe.add_norm_1_output) return encLayer.add_norm_1_output;
        if (name === LNe.ffn_output) return encLayer.ffn.Output;
        if (name === LNe.add_norm_2_output) return encLayer.add_norm_2_output;
        if (name === LNe.Intermediate) return encLayer.ffn.Intermediate;
        if (name === LNe.Activated) return encLayer.ffn.Activated;
        if (name === LNe.W1) return encLayer.ffn.W1;
        if (name === LNe.b1) return [encLayer.ffn.b1];
        if (name === LNe.W2) return encLayer.ffn.W2;
        if (name === LNe.b2) return [encLayer.ffn.b2];
        const encHead = encLayer.mha.heads[h];
        if (encHead) {
            if (name === HNe.Wq) return encHead.Wq;
            if (name === HNe.Wk) return encHead.Wk;
            if (name === HNe.Wv) return encHead.Wv;
            if (name === HNe.Q) return encHead.Q;
            if (name === HNe.K) return encHead.K;
            if (name === HNe.V) return encHead.V;
            if (name === HNe.Scores) return encHead.Scores;
            if (name === HNe.ScaledScores) return encHead.ScaledScores;
            if (name === HNe.AttentionWeights) return encHead.AttentionWeights;
            if (name === HNe.HeadOutput) return encHead.HeadOutput;
        }
    }

    const decLayer = data.decoderLayers[l];
    if (decLayer) {
        if (name === LNd.decoder_input) return decLayer.decoder_input;
        if (name === LNd.masked_mha_output) return decLayer.masked_mha.output;
        if (name === LNd.Wo_masked) return decLayer.masked_mha.Wo;
        if (name === LNd.ConcatOutput_masked) return decLayer.masked_mha.ConcatOutput;
        if (name === LNd.add_norm_1_output) return decLayer.add_norm_1_output;
        if (name === LNd.enc_dec_mha_output) return decLayer.enc_dec_mha.output;
        if (name === LNd.Wo_enc_dec) return decLayer.enc_dec_mha.Wo;
        if (name === LNd.ConcatOutput_enc_dec) return decLayer.enc_dec_mha.ConcatOutput;
        if (name === LNd.add_norm_2_output) return decLayer.add_norm_2_output;
        if (name === LNd.ffn_output) return decLayer.ffn.Output;
        if (name === LNd.add_norm_3_output) return decLayer.add_norm_3_output;
        if (name === LNd.Intermediate) return decLayer.ffn.Intermediate;
        if (name === LNd.Activated) return decLayer.ffn.Activated;
        if (name === LNd.W1) return decLayer.ffn.W1;
        if (name === LNd.b1) return [decLayer.ffn.b1];
        if (name === LNd.W2) return decLayer.ffn.W2;
        if (name === LNd.b2) return [decLayer.ffn.b2];
        const maskedMhaHead = decLayer.masked_mha.heads[h];
        if (maskedMhaHead) {
            if (name === HNd_masked.Wq) return maskedMhaHead.Wq;
            if (name === HNd_masked.Wk) return maskedMhaHead.Wk;
            if (name === HNd_masked.Wv) return maskedMhaHead.Wv;
            if (name === HNd_masked.Q) return maskedMhaHead.Q;
            if (name === HNd_masked.K) return maskedMhaHead.K;
            if (name === HNd_masked.V) return maskedMhaHead.V;
            if (name === HNd_masked.Scores) return maskedMhaHead.Scores;
            if (name === HNd_masked.ScaledScores) return maskedMhaHead.ScaledScores;
            if (name === HNd_masked.AttentionWeights) return maskedMhaHead.AttentionWeights;
            if (name === HNd_masked.HeadOutput) return maskedMhaHead.HeadOutput;
        }
        const encDecMhaHead = decLayer.enc_dec_mha.heads[h];
        if (encDecMhaHead) {
            if (name === HNd_encdec.Wq) return encDecMhaHead.Wq;
            if (name === HNd_encdec.Wk) return encDecMhaHead.Wk;
            if (name === HNd_encdec.Wv) return encDecMhaHead.Wv;
            if (name === HNd_encdec.Q) return encDecMhaHead.Q;
            if (name === HNd_encdec.K) return encDecMhaHead.K;
            if (name === HNd_encdec.V) return encDecMhaHead.V;
            if (name === HNd_encdec.Scores) return encDecMhaHead.Scores;
            if (name === HNd_encdec.ScaledScores) return encDecMhaHead.ScaledScores;
            if (name === HNd_encdec.AttentionWeights) return encDecMhaHead.AttentionWeights;
            if (name === HNd_encdec.HeadOutput) return encDecMhaHead.HeadOutput;
        }
    }
    return undefined;
};

export const generateTooltipData = (element: ElementIdentifier, transformerData: TransformerData, sources: HighlightSource[]): TooltipState | null => {
    const { name, row, col } = element;
    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    let opType: TooltipState['opType'] = 'info';
    let steps: TooltipState['steps'] = [];

    const conceptualName = name.split('.').pop() || '';
    const targetMatrix = getMatrixByName(name, transformerData, layerIdx, headIdx);
    const targetValue = targetMatrix?.[row]?.[col] ?? 0;

    const matmulSourceRow = sources.find(s => s.highlightRow && !s.highlightCol);
    const matmulSourceCol = sources.find(s => s.highlightCol && !s.highlightRow);
    const addSources = sources.filter(s => !s.highlightRow && !s.highlightCol && !s.isInternal);

    if (['mha_output', 'masked_mha_output', 'enc_dec_mha_output'].includes(conceptualName)) {
        opType = 'matmul';
        const concatSource = sources.find(s => s.name.includes('ConcatOutput'));
        const woSource = sources.find(s => s.highlightCol);

        if (concatSource && woSource) {
            const aSources = [{
                data: getMatrixByName(concatSource.name, transformerData, concatSource.layerIndex!, concatSource.headIndex!)![concatSource.row],
                symbolInfo: getSymbolParts(concatSource.name)
            }];
            const bSources = [{
                data: getMatrixByName(woSource.name, transformerData, woSource.layerIndex!, woSource.headIndex!)!.map(r => r[woSource.col]),
                symbolInfo: getSymbolParts(woSource.name)
            }];
            const vecA = aSources[0].data;
            const vecB = bSources[0].data;

            steps.push({ a: vecA, b: vecB, op: '·', result: targetValue, aSources, bSources, aSymbolInfo: getSymbolParts(""), bSymbolInfo: getSymbolParts("") });
        }
    } else if (name.includes('.ffn.Intermediate') || name.includes('.ffn.output')) {
        opType = 'wx-plus-b';
        // [FIXED] Add check for addSources existence before finding biasSource.
        const biasSource = addSources && addSources.find(s => s.name.includes('.b'));
        if (matmulSourceRow && matmulSourceCol && biasSource) {
            const matmulMatrixA = getMatrixByName(matmulSourceRow!.name, transformerData, layerIdx, headIdx)!;
            const matmulMatrixB = getMatrixByName(matmulSourceCol!.name, transformerData, layerIdx, headIdx)!;
            const biasMatrix = getMatrixByName(biasSource.name, transformerData, layerIdx, headIdx)!;

            const aSources = [{ data: matmulMatrixA[row], symbolInfo: getSymbolParts(matmulSourceRow!.name) }];
            const bSources = [{ data: matmulMatrixB.map(r => r[col]), symbolInfo: getSymbolParts(matmulSourceCol!.name) }];
            const biasVectorSource = { data: [biasMatrix[0][col]], symbolInfo: getSymbolParts(biasSource.name) };
            const matmulResult = aSources[0].data.reduce((sum, val, i) => sum + val * bSources[0].data[i], 0);

            steps.push({ title: "Step 1: Matmul (Wx)", op: '·', result: matmulResult, a: aSources[0].data, b: bSources[0].data, aSources, bSources, aSymbolInfo: getSymbolParts(""), bSymbolInfo: getSymbolParts("") });
            steps.push({ title: "Step 2: Add Bias (+b)", op: '+', result: targetValue, a: [matmulResult], b: [biasVectorSource.data[0]], aSources: [{data: [matmulResult], symbolInfo: {base: "Wx", subscript: `[${row},${col}]`}}], bSources: [biasVectorSource], aSymbolInfo: getSymbolParts(""), bSymbolInfo: getSymbolParts(""), aLabel: "Wx", bLabel: "b", resultLabel: "Wx+b" });
        }
    } else if (matmulSourceRow && matmulSourceCol) {
        opType = 'matmul';
        const aSources = [{ data: getMatrixByName(matmulSourceRow.name, transformerData, layerIdx, headIdx)![row], symbolInfo: getSymbolParts(matmulSourceRow.name) }];
        const bSources = [{ data: getMatrixByName(matmulSourceCol.name, transformerData, layerIdx, headIdx)!.map(r => r[col]), symbolInfo: getSymbolParts(matmulSourceCol.name) }];
        steps.push({ a: aSources[0].data, b: bSources[0].data, op: '·', result: targetValue, aSources, bSources, aSymbolInfo: getSymbolParts(""), bSymbolInfo: getSymbolParts("") });
    } else if (addSources.length >= 2) {
        const matrixA = getMatrixByName(addSources[0].name, transformerData, layerIdx, headIdx)!;
        const matrixB = getMatrixByName(addSources[1].name, transformerData, layerIdx, headIdx)!;
        if (conceptualName.includes('add_norm')) {
            opType = 'layernorm';
            const vecA = matrixA[row];
            const vecB = matrixB[row];
            const addedVector = vecA.map((val, i) => val + vecB[i]);
            const aLabel = `${getSymbolParts(addSources[0].name).base}${getSymbolParts(addSources[0].name).subscript ? `_{${getSymbolParts(addSources[0].name).subscript}}` : ''} + ${getSymbolParts(addSources[1].name).base}${getSymbolParts(addSources[1].name).subscript ? `_{${getSymbolParts(addSources[1].name).subscript}}` : ''}`;
            steps.push({ a: addedVector, b: [], op: 'layernorm', result: targetValue, aSymbolInfo: getSymbolParts(name), bSymbolInfo: { base: '' }, aLabel: aLabel, resultLabel: getSymbolParts(name).base });
        } else {
            opType = 'add';
            const addResult = matrixA[row][col] + matrixB[row][col];
            steps.push({ a: matrixA[row], b: matrixB[row], op: '+', result: addResult, aSymbolInfo: getSymbolParts(addSources[0].name), bSymbolInfo: getSymbolParts(addSources[1].name), aLabel: getSymbolParts(addSources[0].name).base, bLabel: getSymbolParts(addSources[1].name).base, resultLabel: "Sum" });
        }
    } else if (conceptualName === 'Activated') {
        opType = 'relu';
        const sourceMatrix = getMatrixByName(sources[0].name, transformerData, layerIdx, headIdx)!;
        steps.push({ a: sourceMatrix[row], b: [], op: 'relu', result: targetValue, aSymbolInfo: getSymbolParts(sources[0].name), bSymbolInfo: { base: '' }, aLabel: getSymbolParts(sources[0].name).base, resultLabel: getSymbolParts(name).base });
    } else if (conceptualName === 'AttentionWeights' || conceptualName === 'outputProbabilities') {
        opType = 'softmax';
        const sourceMatrix = getMatrixByName(sources[0].name, transformerData, layerIdx, headIdx)!;
        steps.push({ a: sourceMatrix[row], b: [], op: 'softmax', result: targetValue, aSymbolInfo: getSymbolParts(sources[0].name), bSymbolInfo: { base: '' }, aLabel: getSymbolParts(sources[0].name).base, resultLabel: getSymbolParts(name).base });
    } else if (conceptualName.includes('ConcatOutput')) {
        return null; // No tooltip for concat, highlighting is sufficient
    }

    if (steps.length === 0) return null;

    const finalSymbol = getSymbolParts(name);
    let subscript = finalSymbol.subscript;
    // Special handling for title, merging multiple subscripts
    const titleSymbolParts = [finalSymbol.base];
    if (finalSymbol.subscript) titleSymbolParts.push(`_{${finalSymbol.subscript}}`);
    if (finalSymbol.superscript) titleSymbolParts.push(`^{${finalSymbol.superscript}}`);
    element.symbol = titleSymbolParts.join('');

    return { target: element, opType, steps, title: `Calculation for ${element.symbol}[${row},${col}]` };
};

export const createBackwardHighlight = (element: ElementIdentifier, transformerData: TransformerData, dims: any): { highlight: HighlightState } => {
    const { name, row, col, isInternal } = element;
    let newSources: HighlightSource[] = [];
    let activeComponent: string | null = null;
    let activeResidual: string | null = null;

    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    element.layerIndex = layerIdx;
    element.headIndex = headIdx;

    const addSource = (src: Partial<HighlightSource>) => {
        const [srcLayer, srcHead] = getLayerAndHeadIndices(src.name!);
        const newSource = Object.assign(
            {},
            element,
            { row: -1, col: -1 },
            src,
            { layerIndex: srcLayer, headIndex: srcHead }
        );
        newSources.push(newSource);
    };


    if (name.startsWith('residual.')) {
        const [, resId] = name.split('.');
        activeResidual = resId;
        const resLayerIdx = parseInt(resId.match(/l(\d+)/)?.[1] || '0', 10);
        const part = parseInt(resId.match(/(\d+)$/)?.[1] || '1', 10);
        if (resId.includes('-d')) {
            const LN = MATRIX_NAMES.decoderLayer(resLayerIdx);
            if (part === 1) { activeComponent = 'add_norm_1_dec'; addSource({ name: LN.decoder_input, highlightRow: true, highlightCol: true }); addSource({ name: LN.masked_mha_output, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2_dec'; addSource({ name: LN.add_norm_1_output, highlightRow: true, highlightCol: true }); addSource({ name: LN.enc_dec_mha_output, highlightRow: true, highlightCol: true }); }
            else if (part === 3) { activeComponent = 'add_norm_3_dec'; addSource({ name: LN.add_norm_2_output, highlightRow: true, highlightCol: true }); addSource({ name: LN.ffn_output, highlightRow: true, highlightCol: true }); }
        } else {
            const LN = MATRIX_NAMES.layer(resLayerIdx);
            if (part === 1) { activeComponent = 'add_norm_1'; addSource({ name: LN.encoder_input, highlightRow: true, highlightCol: true }); addSource({ name: LN.mha_output, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2'; addSource({ name: LN.add_norm_1_output, highlightRow: true, highlightCol: true }); addSource({ name: LN.ffn_output, highlightRow: true, highlightCol: true }); }
        }
        return { highlight: { target: null, sources: newSources, activeComponent, activeResidual, destinations: [] } };
    }

    const LNe = MATRIX_NAMES.layer(layerIdx);
    const HNe = MATRIX_NAMES.head(layerIdx, headIdx);
    const LNd = MATRIX_NAMES.decoderLayer(layerIdx);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIdx, headIdx);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(layerIdx, headIdx);
    const baseName = isInternal ? name.replace('.internal', '') : name;

    if (name.startsWith('encoder')) {
        if (Object.values(HNe).includes(baseName) || [LNe.mha_output, LNe.Wo, LNe.encoder_input, LNe.ConcatOutput].includes(baseName)) activeComponent = 'mha';
        else if ([LNe.add_norm_1_output].includes(baseName)) activeComponent = 'add_norm_1';
        else if ([LNe.add_norm_2_output].includes(baseName)) activeComponent = 'add_norm_2';
        else if (baseName.includes('.ffn.')) activeComponent = 'ffn';
    } else if (name.startsWith('decoder')) {
        if (Object.values(HNd_masked).includes(baseName) || [LNd.masked_mha_output, LNd.Wo_masked, LNd.decoder_input, LNd.ConcatOutput_masked].includes(baseName)) activeComponent = 'masked_mha';
        else if (Object.values(HNd_encdec).includes(baseName) || [LNd.enc_dec_mha_output, LNd.Wo_enc_dec, LNd.add_norm_1_output, MATRIX_NAMES.finalEncoderOutput, LNd.ConcatOutput_enc_dec].includes(baseName)) activeComponent = 'enc_dec_mha';
        else if (baseName === LNd.add_norm_1_output) activeComponent = 'add_norm_1_dec';
        else if (baseName === LNd.add_norm_2_output) activeComponent = 'add_norm_2_dec';
        else if (baseName === LNd.add_norm_3_output) activeComponent = 'add_norm_3_dec';
        else if (baseName.includes('.ffn.')) activeComponent = 'ffn_dec';
    } else if (name === 'inputToken' || name === 'embeddingMatrix' || name === 'inputEmbeddings') {
        activeComponent = 'token_embed';
    } else if ([MATRIX_NAMES.posEncodings, MATRIX_NAMES.encoderInput].includes(baseName) || baseName === LNe.encoder_input) {
        activeComponent = 'input_embed';
    } else if ([MATRIX_NAMES.outputEmbeddings, MATRIX_NAMES.decoderPosEncodings, MATRIX_NAMES.decoderInput].includes(baseName) || baseName === LNd.decoder_input) {
        activeComponent = 'output_embed';
    } else if ([MATRIX_NAMES.finalLinear, MATRIX_NAMES.logits].includes(baseName)) {
        activeComponent = 'final_output';
    } else if (name === MATRIX_NAMES.outputProbabilities || name === 'outputToken') {
        activeComponent = 'decoding';
    }

    if (name === 'inputToken') { addSource({ name: MATRIX_NAMES.inputEmbeddings, row, col: -1, highlightRow: true }) }
    else if (name === MATRIX_NAMES.inputEmbeddings) { addSource({ name: 'inputToken', row }); addSource({ name: 'embeddingMatrix', row: transformerData.tokenizedInput[row], col: -1, highlightRow: true }) }
    else if (name === LNe.encoder_input) {
        if (layerIdx === 0) { addSource({ name: MATRIX_NAMES.inputEmbeddings, row, col }); addSource({ name: MATRIX_NAMES.posEncodings, row, col }); }
        else { addSource({ name: MATRIX_NAMES.layer(layerIdx - 1).add_norm_2_output, row, col }); }
    }
    else if (name === HNe.Q || name === HNe.K || name === HNe.V) { const type = name.split('.').pop()!; addSource({ name: LNe.encoder_input, row, col: -1, highlightRow: true }); addSource({ name: HNe[`W${type.toLowerCase()}` as 'Wq' | 'Wk' | 'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNe.Scores) { addSource({ name: HNe.Q, row, col: -1, highlightRow: true }); addSource({ name: HNe.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNe.ScaledScores) { addSource({ name: HNe.Scores, row, col }); }
    else if (name === HNe.AttentionWeights) { addSource({ name: HNe.ScaledScores, row, col: -1, highlightRow: true });}
    else if (name === HNe.HeadOutput) { addSource({ name: HNe.AttentionWeights, row, col: -1, highlightRow: true }); addSource({ name: HNe.V, row: -1, col, highlightCol: true }); }
    else if (name === LNe.ConcatOutput) { for (let h = 0; h < dims.h; h++) { addSource({ name: MATRIX_NAMES.head(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true, headIndex: h }); } }
    else if (name === LNe.mha_output) { addSource({ name: LNe.ConcatOutput, row, col: -1, highlightRow: true }); addSource({ name: LNe.Wo, row: -1, col, highlightCol: true }); }
    else if (name === LNe.add_norm_1_output) { addSource({ name: LNe.encoder_input, row, col }); addSource({ name: LNe.mha_output, row, col }); }
    else if (name === LNe.Intermediate) { addSource({ name: LNe.add_norm_1_output, row, col: -1, highlightRow: true }); addSource({ name: LNe.W1, row: -1, col, highlightCol: true }); addSource({ name: LNe.b1, row: 0, col }); }
    else if (name === LNe.Activated) { addSource({ name: LNe.Intermediate, row, col }); }
    else if (name === LNe.ffn_output) { addSource({ name: LNe.Activated, row, col: -1, highlightRow: true }); addSource({ name: LNe.W2, row: -1, col, highlightCol: true }); addSource({ name: LNe.b2, row: 0, col }); }
    else if (name === LNe.add_norm_2_output) { addSource({ name: LNe.add_norm_1_output, row, col }); addSource({ name: LNe.ffn_output, row, col }); }
    else if (name === LNd.decoder_input) {
        if (layerIdx === 0) { addSource({ name: MATRIX_NAMES.outputEmbeddings, row, col }); addSource({ name: MATRIX_NAMES.decoderPosEncodings, row, col }); }
        else { addSource({ name: MATRIX_NAMES.decoderLayer(layerIdx - 1).add_norm_3_output, row, col }); }
    }
    else if (name === HNd_masked.Q || name === HNd_masked.K || name === HNd_masked.V) { const type = name.split('.').pop()!; addSource({ name: LNd.decoder_input, row, col: -1, highlightRow: true }); addSource({ name: HNd_masked[`W${type.toLowerCase()}` as 'Wq' | 'Wk' | 'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNd_masked.Scores) { addSource({ name: HNd_masked.Q, row, col: -1, highlightRow: true }); addSource({ name: HNd_masked.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNd_masked.ScaledScores) { addSource({ name: HNd_masked.Scores, row, col }); }
    else if (name === HNd_masked.AttentionWeights) { addSource({ name: HNd_masked.ScaledScores, row, col: -1, highlightRow: true }); }
    else if (name === HNd_masked.HeadOutput) { addSource({ name: HNd_masked.AttentionWeights, row, col: -1, highlightRow: true }); addSource({ name: HNd_masked.V, row: -1, col, highlightCol: true }); }
    else if (name === LNd.ConcatOutput_masked) { for (let h = 0; h < dims.h; h++) { addSource({ name: MATRIX_NAMES.maskedMhaHead(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true, headIndex: h }); } }
    else if (name === LNd.masked_mha_output) { addSource({ name: LNd.ConcatOutput_masked, row, col: -1, highlightRow: true }); addSource({ name: LNd.Wo_masked, row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_1_output) { addSource({ name: LNd.decoder_input, row, col }); addSource({ name: LNd.masked_mha_output, row, col }); }
    else if (name === HNd_encdec.Q) { addSource({ name: LNd.add_norm_1_output, row, col: -1, highlightRow: true }); addSource({ name: HNd_encdec.Wq, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.K || name === HNd_encdec.V) { const type = name.split('.').pop()!.toLowerCase(); addSource({ name: MATRIX_NAMES.finalEncoderOutput, row, col: -1, highlightRow: true }); addSource({ name: HNd_encdec[`W${type}` as 'Wk' | 'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.Scores) { addSource({ name: HNd_encdec.Q, row, col: -1, highlightRow: true }); addSource({ name: HNd_encdec.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNd_encdec.ScaledScores) { addSource({ name: HNd_encdec.Scores, row, col }); }
    else if (name === HNd_encdec.AttentionWeights) { addSource({ name: HNd_encdec.ScaledScores, row, col: -1, highlightRow: true }); }
    else if (name === HNd_encdec.HeadOutput) { addSource({ name: HNd_encdec.AttentionWeights, row, col: -1, highlightRow: true }); addSource({ name: HNd_encdec.V, row: -1, col, highlightCol: true }); }
    else if (name === LNd.ConcatOutput_enc_dec) { for (let h = 0; h < dims.h; h++) { addSource({ name: MATRIX_NAMES.encDecMhaHead(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true, headIndex: h }); } }
    else if (name === LNd.enc_dec_mha_output) { addSource({ name: LNd.ConcatOutput_enc_dec, row, col: -1, highlightRow: true }); addSource({ name: LNd.Wo_enc_dec, row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_2_output) { addSource({ name: LNd.add_norm_1_output, row, col }); addSource({ name: LNd.enc_dec_mha_output, row, col }); }
    else if (name === LNd.Intermediate) { addSource({ name: LNd.add_norm_2_output, row, col: -1, highlightRow: true }); addSource({ name: LNd.W1, row: -1, col, highlightCol: true }); addSource({ name: LNd.b1, row: 0, col }); }
    else if (name === LNd.Activated) { addSource({ name: LNd.Intermediate, row, col }); }
    else if (name === LNd.ffn_output) { addSource({ name: LNd.Activated, row, col: -1, highlightRow: true }); addSource({ name: LNd.W2, row: -1, col, highlightCol: true }); addSource({ name: LNd.b2, row: 0, col }); }
    else if (name === LNd.add_norm_3_output) { addSource({ name: LNd.add_norm_2_output, row, col }); addSource({ name: LNd.ffn_output, row, col }); }
    else if (name === MATRIX_NAMES.logits) { addSource({ name: MATRIX_NAMES.decoderLayer(dims.n_layers - 1).add_norm_3_output, row, col: -1, highlightRow: true }); addSource({ name: MATRIX_NAMES.finalLinear, row: -1, col, highlightCol: true }) }
    else if (name === MATRIX_NAMES.outputProbabilities) { addSource({ name: MATRIX_NAMES.logits, row, col: -1, highlightRow: true }) }
    else if (name === 'outputToken') { addSource({ name: MATRIX_NAMES.outputProbabilities, row, col: -1, highlightRow: true, highlightProbCol: true }) }

    const highlight = { target: element, sources: newSources, activeComponent, activeResidual, destinations: [] };
    return { highlight };
};
// END OF FILE: src/topics/transformer-explorer/lib/tracing.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/lib/transformer.ts
================================================================================

// FILE: src/topics/transformer-explorer/lib/transformer.ts
import { Matrix, TransformerData, EncoderLayerData, FFNData, MultiHeadAttentionData, AttentionHeadData, Vector, DecoderLayerData } from '../types';
import { fixedWeights } from './fixedWeights';
import { whitespaceTokenizer } from './tokenizer';

// --- Utility Functions ---

const createMatrixFrom2DArray = (data: number[][]): Matrix => {
    return data.map(row => row.slice());
};

const createVectorFrom1DArray = (data: number[]): Vector => {
    return data.slice();
};

const addMatrices = (A: Matrix, B: Matrix): Matrix => {
    return A.map((row, i) =>
        row.map((val, j) => val + B[i][j])
    );
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
    const rowsA = A.length;
    if (rowsA === 0) return [];
    const colsA = A[0].length;
    if (colsA === 0) return A.map(() => []);
    const colsB = B[0]?.length ?? 0;
    if (colsB === 0) return A.map(() => []);

    const result: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));

    for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
            let sum = 0;
            for (let k = 0; k < colsA; k++) {
                sum += A[i][k] * B[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => {
    return A.map(row => row.map(val => val / scalar));
}

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row.filter(v => isFinite(v)));
        const exps = row.map(val => isFinite(val) ? Math.exp(val - maxVal) : 0);
        const sumExps = exps.reduce((a, b) => a + b, 0);
        if (sumExps === 0) return row.map(() => 1 / row.length); // Avoid division by zero
        return exps.map(exp => exp / sumExps);
    });
}

const layerNorm = (A: Matrix): Matrix => {
    if (A.length === 0 || A[0].length === 0) return [];
    return A.map(row => {
        const mean = row.reduce((a,b) => a+b, 0) / row.length;
        const variance = row.map(x => (x - mean) ** 2).reduce((a,b) => a+b,0) / row.length;
        const std = Math.sqrt(variance + 1e-5);
        return row.map(x => (x - mean) / std);
    });
}

const applyReLU = (A: Matrix): Matrix => {
    return A.map(row => row.map(val => Math.max(0, val)));
}

const addBias = (A: Matrix, b: Vector): Matrix => {
    return A.map(row => row.map((val, j) => val + b[j]));
}

const applyMask = (A: Matrix, maskValue = -Infinity): Matrix => {
    return A.map((row, i) =>
        row.map((val, j) => (j > i ? maskValue : val))
    );
};

// --- Main Calculation Function ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number; // Decoder sequence length
    n_layers: number;
    d_ff: number;
}

export const calculateTransformer = (inputText: string, dims: Dims): TransformerData | null => {
    const { d_model, h, seq_len: decoder_seq_len, n_layers, d_ff } = dims;
    if (d_model % h !== 0) return null;
    const d_k = d_model / h;

    const weights = fixedWeights(dims);
    const vocab = weights.vocab;
    const UNK_TOKEN_ID = 15;

    // --- INPUT STAGE (DYNAMIC) ---
    const tokenizedText = whitespaceTokenizer(inputText);
    const tokenizedInput = tokenizedText.map(t => {
        const entry = Object.entries(vocab).find(([id, word]) => word === t);
        return entry ? parseInt(entry[0], 10) : UNK_TOKEN_ID;
    });
    const encoder_seq_len = tokenizedInput.length;
    if (encoder_seq_len === 0) return null; // Handle empty input after tokenization

    // --- ENCODER ---
    const embeddingMatrix = createMatrixFrom2DArray(weights.embeddingMatrix);
    const inputEmbeddings = tokenizedInput.map(token_id => embeddingMatrix[token_id]);

    const posEncodings: Matrix = createMatrixFrom2DArray(weights.posEncodings).slice(0, encoder_seq_len);
    const encoderInput = addMatrices(inputEmbeddings, posEncodings);

    let currentEncoderInput = encoderInput;
    const encoderLayers: EncoderLayerData[] = [];

    for (let i = 0; i < n_layers; i++) {
        const encoder_input = currentEncoderInput;
        const heads: AttentionHeadData[] = [];
        const headOutputs: Matrix[] = [];
        for(let j=0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wv);
            const Q = multiplyMatrices(encoder_input, Wq);
            const K = multiplyMatrices(encoder_input, Wk);
            const V = multiplyMatrices(encoder_input, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: encoder_seq_len }, (_, c) => K[c][r]));
            const Scores = multiplyMatrices(Q, K_T);
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            headOutputs.push(HeadOutput);
        }
        const ConcatOutput = headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(encoder_seq_len).fill(0).map(() => []));
        const Wo = createMatrixFrom2DArray(weights.encoderLayers[i].mha.Wo);
        const mha_output = multiplyMatrices(ConcatOutput, Wo);
        const mha: MultiHeadAttentionData = { heads, Wo, ConcatOutput, output: mha_output };
        const add_norm_1_output = layerNorm(addMatrices(encoder_input, mha_output));
        const W1 = createMatrixFrom2DArray(weights.encoderLayers[i].ffn.W1);
        const b1 = createVectorFrom1DArray(weights.encoderLayers[i].ffn.b1);
        const Intermediate = addBias(multiplyMatrices(add_norm_1_output, W1), b1);
        const Activated = applyReLU(Intermediate);
        const W2 = createMatrixFrom2DArray(weights.encoderLayers[i].ffn.W2);
        const b2 = createVectorFrom1DArray(weights.encoderLayers[i].ffn.b2);
        const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
        const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
        const add_norm_2_output = layerNorm(addMatrices(add_norm_1_output, ffn_output));
        encoderLayers.push({ encoder_input, mha, mha_output, add_norm_1_output, ffn, ffn_output, add_norm_2_output });
        currentEncoderInput = add_norm_2_output;
    }
    const finalEncoderOutput = currentEncoderInput;

    // --- DECODER ---
    const tokenizedDecoderInput = ["<SOS>", "我", "是", "学生"].slice(0, decoder_seq_len).map(t => Object.keys(vocab).find(k => vocab[parseInt(k)] === t)!).map(Number);
    const outputEmbeddings = tokenizedDecoderInput.map(token_id => embeddingMatrix[token_id]);
    const decoderPosEncodings = createMatrixFrom2DArray(weights.posEncodings).slice(0, decoder_seq_len);
    const decoderInput = addMatrices(outputEmbeddings, decoderPosEncodings);

    let currentDecoderInput = decoderInput;
    const decoderLayers: DecoderLayerData[] = [];

    for (let i = 0; i < n_layers; i++) {
        const decoder_input = currentDecoderInput;
        const decWeights = weights.decoderLayers[i];

        const masked_mha_heads: AttentionHeadData[] = [];
        const masked_mha_headOutputs: Matrix[] = [];
        for (let j = 0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wv);
            const Q = multiplyMatrices(decoder_input, Wq);
            const K = multiplyMatrices(decoder_input, Wk);
            const V = multiplyMatrices(decoder_input, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: decoder_seq_len }, (_, c) => K[c][r]));
            const Scores = applyMask(multiplyMatrices(Q, K_T));
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            masked_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            masked_mha_headOutputs.push(HeadOutput);
        }
        const masked_ConcatOutput = masked_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(decoder_seq_len).fill(0).map(() => []));
        const masked_Wo = createMatrixFrom2DArray(decWeights.masked_mha.Wo);
        const masked_mha_output = multiplyMatrices(masked_ConcatOutput, masked_Wo);
        const masked_mha: MultiHeadAttentionData = { heads: masked_mha_heads, Wo: masked_Wo, ConcatOutput: masked_ConcatOutput, output: masked_mha_output };
        const dec_add_norm_1_output = layerNorm(addMatrices(decoder_input, masked_mha_output));

        const enc_dec_mha_heads: AttentionHeadData[] = [];
        const enc_dec_mha_headOutputs: Matrix[] = [];
        for (let j = 0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wv);
            const Q = multiplyMatrices(dec_add_norm_1_output, Wq);
            const K = multiplyMatrices(finalEncoderOutput, Wk);
            const V = multiplyMatrices(finalEncoderOutput, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: encoder_seq_len }, (_, c) => K[c][r]));
            const Scores = multiplyMatrices(Q, K_T);
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            enc_dec_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            enc_dec_mha_headOutputs.push(HeadOutput);
        }
        const enc_dec_ConcatOutput = enc_dec_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(decoder_seq_len).fill(0).map(() => []));
        const enc_dec_Wo = createMatrixFrom2DArray(decWeights.enc_dec_mha.Wo);
        const enc_dec_mha_output = multiplyMatrices(enc_dec_ConcatOutput, enc_dec_Wo);
        const enc_dec_mha: MultiHeadAttentionData = { heads: enc_dec_mha_heads, Wo: enc_dec_Wo, ConcatOutput: enc_dec_ConcatOutput, output: enc_dec_mha_output };
        const dec_add_norm_2_output = layerNorm(addMatrices(dec_add_norm_1_output, enc_dec_mha_output));

        const W1 = createMatrixFrom2DArray(decWeights.ffn.W1);
        const b1 = createVectorFrom1DArray(decWeights.ffn.b1);
        const Intermediate = addBias(multiplyMatrices(dec_add_norm_2_output, W1), b1);
        const Activated = applyReLU(Intermediate);
        const W2 = createMatrixFrom2DArray(decWeights.ffn.W2);
        const b2 = createVectorFrom1DArray(decWeights.ffn.b2);
        const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
        const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
        const dec_add_norm_3_output = layerNorm(addMatrices(dec_add_norm_2_output, ffn_output));

        decoderLayers.push({ decoder_input, masked_mha, masked_mha_output, add_norm_1_output: dec_add_norm_1_output, enc_dec_mha, enc_dec_mha_output, add_norm_2_output: dec_add_norm_2_output, ffn, ffn_output, add_norm_3_output: dec_add_norm_3_output });
        currentDecoderInput = dec_add_norm_3_output;
    }
    const finalDecoderOutput = currentDecoderInput;

    const finalLinear = createMatrixFrom2DArray(weights.finalLinear);
    const logits = multiplyMatrices(finalDecoderOutput, finalLinear);
    const outputProbabilities = softmaxByRow(logits);

    // --- DECODING STAGE ---
    const decodedTokens = outputProbabilities.map(row => row.indexOf(Math.max(...row)));
    const outputText = decodedTokens.map(id => vocab[id] || "[UNK]"); // Handle unknown tokens

    return {
        inputText: tokenizedText,
        tokenizedInput,
        embeddingMatrix,
        vocab,
        inputEmbeddings,
        posEncodings,
        encoderInput,
        encoderLayers,
        finalEncoderOutput,
        outputEmbeddings,
        decoderPosEncodings,
        decoderInput,
        decoderLayers,
        finalDecoderOutput,
        finalLinear,
        logits,
        outputProbabilities,
        decodedTokens,
        outputText,
    };
};
// END OF FILE: src/topics/transformer-explorer/lib/transformer.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/TransformerExplorerTopic.css
================================================================================

/* FILE: src/topics/transformer-explorer/TransformerExplorerTopic.css */
/* This file contains all necessary styles for the transformer-explorer topic,
   ensuring it is fully self-contained. */

.main-layout {
  display: flex;
  gap: 20px;
  flex-grow: 1;
  overflow: hidden;
  padding: 20px;
  min-height: 0;
  position: relative;
}

.column {
  flex: 1;
  background: var(--component-bg);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
  overflow-y: auto;
  min-height: 0;
  min-width: 0;
}

.column-content {
  padding: 20px;
}

.column.left-column {
  flex: 1.4;
}

.column h2 {
  font-size: 1.6em;
  margin: -20px -20px 20px -20px;
  padding: 20px 20px 15px 20px;
  text-align: center;
  color: #000;
  position: sticky;
  top: -21px;
  background: inherit;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
  border-radius: 12px 12px 0 0;
}

.diagram-component {
  border: 2px solid var(--border-color);
  border-radius: 10px;
  margin-bottom: 15px;
  background-color: #fdfdfd;
  transition: all 0.3s ease;
}

.diagram-component .component-header {
    cursor: pointer;
    transition: background-color 0.3s ease;
}
.diagram-component .component-header:hover {
    background-color: #f0f2f5;
}
.diagram-component.active {
    border-color: var(--highlight-formula-border) !important;
    box-shadow: 0 0 30px var(--highlight-formula-bg) !important;
    transform: scale(1.01);
}

.component-header {
  background-color: var(--component-header-bg);
  padding: 8px 15px;
  font-weight: bold;
  font-size: 1.1em;
  border-bottom: 1px solid var(--border-color);
  border-radius: 8px 8px 0 0;
}
.component-body {
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  width: 100%;
  box-sizing: border-box;
}

.arrow-down {
  width: 100%;
  text-align: center;
  font-size: 24px;
  color: var(--arrow-color);
  margin: 5px 0;
}

.matrix-wrapper {
    position: relative;
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    vertical-align: middle;
}

/* Side-label logic for transformer-explorer */
.matrix-wrapper .matrix-label-side { display: none; }
.matrix-wrapper .matrix-label-container { display: flex; }
.matrix-wrapper > .matrix-label {
    display: flex;
    justify-content: center;
    margin-top: 8px;
}

.matrix-wrapper.side-label,
.viz-formula-row.vertical .matrix-wrapper,
.viz-formula-row > .matrix-wrapper:only-child,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper,
.component-body > .matrix-wrapper
{
    flex-direction: row;
    align-items: center;
    gap: 12px;
}

.matrix-wrapper.side-label .matrix-label-side,
.viz-formula-row.vertical .matrix-wrapper .matrix-label-side,
.viz-formula-row > .matrix-wrapper:only-child .matrix-label-side,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper .matrix-label-side,
.component-body > .matrix-wrapper .matrix-label-side {
    display: flex;
}

.matrix-wrapper.side-label .matrix-label-container,
.matrix-wrapper.side-label > .matrix-label,
.viz-formula-row.vertical .matrix-wrapper .matrix-label-container,
.viz-formula-row.vertical .matrix-wrapper > .matrix-label,
.viz-formula-row > .matrix-wrapper:only-child .matrix-label-container,
.viz-formula-row > .matrix-wrapper:only-child > .matrix-label,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper .matrix-label-container,
.formula-display > .matrix-scroll-wrapper:only-child .matrix-wrapper > .matrix-label,
.component-body > .matrix-wrapper .matrix-label-container,
.component-body > .matrix-wrapper > .matrix-label {
    display: none;
}

.matrix-container {
  display: inline-block;
  border: 1px solid #ccc;
  padding: 5px;
  border-radius: 4px;
  background-color: #f9f9f9;
}
.matrix-grid {
  display: grid;
  gap: 3px;
}

.matrix-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
  z-index: 2;
  font-weight: normal;
}

.matrix-ellipsis {
    width: 45px;
    height: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #aaa;
    font-size: 1.2em;
    font-family: monospace;
}

.matrix-element:hover {
  transform: scale(1.1);
  border-color: #007bff;
  box-shadow: 0 0 5px rgba(0,123,255,0.5);
  z-index: 5;
}

.matrix-element.source {
  background-color: var(--highlight-source-bg);
  color: var(--highlight-source-color);
  border: 1.5px solid var(--highlight-source-border);
}
.matrix-element.target {
  background-color: var(--highlight-target-bg);
  color: var(--highlight-target-color);
  border: 1.5px solid var(--highlight-target-border);
}

.matrix-element.prob-max {
    box-shadow: 0 0 8px 2px var(--highlight-target-border);
    font-weight: bold;
    transform: scale(1.15);
    z-index: 6;
}

.matrix-element.destination {
  background-color: var(--highlight-formula-bg);
  border: 1px solid var(--highlight-formula-border);
}

.matrix-label-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}

.matrix-label {
  text-align: center;
  font-weight: bold;
  font-family: monospace;
  font-size: 1.1em;
  margin: 0;
}

.matrix-symbol-tag {
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    font-size: 1.1em;
    border: 1px solid #ced4da;
    line-height: 1;
    font-family: 'Times New Roman', serif;
}

.op-symbol {
    font-size: 1.6em; /* [MODIFIED] Reduced size */
    font-weight: bold;
    color: #909399;
    align-self: center;
    margin: 0 5px; /* [MODIFIED] Reduced margin */
}

.matrix-header-item, .symbolic-header-item {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5;
    color: #909399;
    font-family: monospace;
    font-size: 0.8em;
    font-weight: bold;
    border-radius: 2px;
    padding: 2px;
    box-sizing: border-box;
    min-height: 15px;
}
.symbolic-header-item {
    background-color: transparent;
}


.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block.active {
  border-color: var(--highlight-formula-border) !important;
  box-shadow: 0 0 30px var(--highlight-bg) !important;
  transform: scale(1.01);
  background-color: var(--highlight-formula-bg);
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li, .math-block h5 {
    line-height: 1.7;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.math-block h5 {
    font-size: 1.1em;
    margin-top: 1.5em;
    margin-bottom: 0.5em;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

.formula-display {
    display: flex;
    justify-content: center; /* [MODIFIED] Changed from flex-start to center */
    align-items: center;
    gap: 15px;
    overflow-x: auto;
    margin: 20px 0;
    padding: 15px 10px;
    background-color: rgba(0,0,0,0.02);
    border-radius: 8px;
    flex-wrap: wrap;
}
.formula-display > * {
    flex-shrink: 0;
}
.formula-display.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.katex-display {
    margin: 0.5em 0 !important;
}

.matrix-scroll-wrapper {
    overflow-x: auto;
    padding: 5px;
    flex-shrink: 0;
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.symbolic-matrix-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.symbolic-matrix-grid {
    display: grid;
    gap: 2px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f9f9f9;
}
.symbolic-element, .symbolic-ellipsis {
    min-width: 60px;
    min-height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9em;
    border-radius: 2px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    transition: all 0.2s ease-in-out;
}
.symbolic-ellipsis {
    border-style: dashed;
    color: #aaa;
}
.symbolic-element.source {
  background-color: var(--highlight-source-bg);
  border-color: var(--highlight-source-border);
}
.symbolic-element.target {
  background-color: var(--highlight-target-bg);
  border-color: var(--highlight-target-border);
}
.symbolic-element.destination {
    background-color: var(--highlight-formula-bg);
    border-color: var(--highlight-formula-border);
}

.viz-formula-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    padding: 15px 10px;
    border: 1px solid #eef;
    border-radius: 8px;
    background-color: rgba(0,0,0,0.015);
    gap: 5px;
    box-sizing: border-box;
}
.viz-formula-group > * {
    flex-shrink: 0;
}
.viz-formula-row {
    display: flex;
    align-items: center;
    gap: 15px;
    justify-content: center;
    width: max-content;
    padding: 0 5px;
    flex-wrap: nowrap;
}
.viz-formula-row.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.viz-formula-row > * {
    flex-shrink: 0;
}

.viz-step-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #606266;
    margin-top: 10px;
    margin-bottom: 5px;
    font-size: 0.9em;
    border-bottom: 1px solid #eef;
    padding-bottom: 5px;
}
.viz-formula-group .viz-step-title {
    margin-top: -5px;
    margin-bottom: 10px;
}

.residual-block {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px 10px;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #fcfcfc;
}
.residual-block:hover {
    border-color: var(--highlight-formula-border);
    background-color: var(--highlight-formula-bg);
}
.residual-icon {
    font-size: 1.6em;
    font-weight: bold;
    color: var(--arrow-color);
    line-height: 1;
}
.residual-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
}
.residual-matrix-symbol {
    font-size: 1.2em;
}
.residual-matrix-dims {
    font-size: 0.8em;
    color: #666;
    font-family: monospace;
}
.residual-block.active {
    border-color: var(--highlight-formula-border);
    border-style: solid;
    box-shadow: 0 0 15px var(--highlight-formula-bg);
    transform: scale(1.05);
}
.residual-block.active .residual-icon {
    color: var(--highlight-formula-border);
}

.add-norm-component-body {
    flex-direction: column;
}

.add-norm-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
}

.token-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 5px;
    cursor: pointer;
    border-radius: 4px;
    border: 2px solid transparent;
    transition: all 0.2s ease-in-out;
}
.token-container:hover {
    transform: scale(1.05);
    background-color: rgba(0,0,0,0.02);
}
.token-container.target {
    border-color: var(--highlight-target-border);
    background-color: var(--highlight-target-bg);
}
.token-container.source {
    border-color: var(--highlight-source-border);
    background-color: var(--highlight-source-bg);
}
.token-text {
    padding: 4px 8px;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-family: monospace;
    font-size: 1.05em;
    min-width: 25px;
    text-align: center;
}
.token-id {
    padding: 2px 6px;
    background-color: #e9ecef;
    border: 1px solid #ced4da;
    border-radius: 10px;
    font-size: 0.8em;
    color: #495057;
}

.token-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
}

.decoding-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
}
.decoding-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
}

.embedding-lookup-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
    width: 100%;
    position: relative;
    padding: 10px;
    box-sizing: border-box;
}
.embedding-lookup-container.vertical {
    flex-direction: column;
}
.embedding-lookup-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}
.embedding-lookup-svg path {
    fill: none;
    stroke-width: 2px;
    stroke: var(--arrow-color);
    stroke-dasharray: 5 5;
    transition: all 0.3s ease;
}
.embedding-lookup-svg path.highlighted {
    stroke: var(--highlight-target-border);
    stroke-width: 3px;
    stroke-dasharray: none;
}
.embedding-lookup-column {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
    flex-shrink: 0;
}
.embedding-lookup-vocab {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    min-width: 0;
}

/* [NEW] Styles for animated ElementwiseCalculation */
.elementwise-calc-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px 0;
    font-size: 0.9em;
}
.calc-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: 100%;
    transition: opacity 0.4s ease;
}
.calc-step.hidden {
    opacity: 0.3;
    pointer-events: none;
}
.calc-label {
    color: #555;
    font-size: 1em;
    font-weight: bold;
    font-family: sans-serif;
}
.elementwise-op-row {
    display: flex;
    gap: 5px;
    border: 1px solid #ddd;
    padding: 4px;
    border-radius: 4px;
    background: #fff;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
}
.elementwise-op-element {
  width: 50px;
  height: 28px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.85em;
  cursor: pointer;
  transition: all 0.2s ease;
}
.elementwise-op-element.highlight-step {
    transform: scale(1.1);
    border-color: var(--highlight-formula-border);
    background-color: var(--highlight-formula-bg);
}
.elementwise-op-element.symbolic-ellipsis {
    border: none;
    background-color: transparent;
    color: #aaa;
    width: auto;
}
.elementwise-op-element.sum {
    width: auto;
    padding: 0 10px;
    font-weight: bold;
}
.elementwise-op-element.source {
    background-color: var(--highlight-source-bg) !important;
    color: var(--highlight-source-color) !important;
    border-color: var(--highlight-source-border) !important;
}
.elementwise-op-element.target {
    background-color: var(--highlight-target-bg) !important;
    color: var(--highlight-target-color) !important;
    border-color: var(--highlight-target-border) !important;
}
.elementwise-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.elementwise-controls button {
    padding: 6px 12px;
    font-size: 0.9em;
    cursor: pointer;
    border: 1px solid #6c757d;
    border-radius: 4px;
    background-color: #fff;
}
.elementwise-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* [REVISED] Modernized styles for Controls panel */
.controls-container {
    display: flex;
    flex-direction: column;
    gap: 18px; /* More vertical space */
    padding: 20px;
    flex-grow: 1;
    overflow-y: auto;
}

.control-group {
    display: flex;
    justify-content: space-between; /* Label on left, input on right */
    align-items: center;
    width: 100%;
}

.control-group label {
    font-size: 0.95em;
    color: #495057; /* Darker, more professional gray */
    font-weight: 500; /* Medium weight */
    flex-shrink: 0;
    padding-right: 15px; /* Space between label and input */
}

/* Common styles for number inputs and the d_k display */
.control-group input[type="number"],
.control-group .d_k-value {
    width: 80px; /* Align the number inputs and the d_k value */
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px; /* Slightly more rounded */
    font-size: 1em;
    text-align: center;
    box-sizing: border-box;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

/* Specific style for text input */
.control-group input[type="text"] {
    flex-grow: 1; /* Allow text input to fill remaining space */
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 1em;
    box-sizing: border-box;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

/* Specific focus state for all interactive inputs */
.control-group input:focus {
    outline: none;
    border-color: #409eff; /* Accent color on focus */
    box-shadow: 0 0 0 3px rgba(64, 158, 255, 0.2); /* Subtle glow */
}

/* Style for the read-only d_k value */
.d_k-value {
    font-weight: 600; /* Bolder */
    background-color: #f0f2f5; /* Subtle background */
    color: #303133;
    border-color: #e4e7ed;
}
/* END OF FILE: src/topics/transformer-explorer/TransformerExplorerTopic.css */



================================================================================
### 文件路径: src/topics/transformer-explorer/TransformerExplorerTopic.tsx
================================================================================

// FILE: src/topics/transformer-explorer/TransformerExplorerTopic.tsx
import React, { useState, useCallback, useEffect } from 'react';
import './TransformerExplorerTopic.css';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { CalculationTooltip } from '../../components/CalculationTooltip/CalculationTooltip';
import { AnimationPanel } from './components/AnimationPanel';
import { TooltipState } from '../../components/CalculationTooltip/types';
import { useTransformer } from './hooks/useTransformer';
import { useSplitPane } from '../../hooks/useSplitPane';
import { ElementIdentifier, HighlightState, TransformerData } from './types';
import { generateTooltipData, createBackwardHighlight } from './lib/tracing';
import { ViewToggle, ViewMode } from '../../components/ViewToggle/ViewToggle';

export const TransformerExplorerTopic: React.FC = () => {
    const [dims, setDims] = useState({ d_model: 8, h: 2, seq_len: 2, n_layers: 1, d_ff: 32 });
    const [inputText, setInputText] = useState("I am a student");
    const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [], destinations: [], activeComponent: null, activeResidual: null });
    const [tooltip, setTooltip] = useState<TooltipState | null>(null);
    const [animationData, setAnimationData] = useState<TooltipState | null>(null);
    const [viewMode, setViewMode] = useState<ViewMode>('none');
    const [activeElement, setActiveElement] = useState<ElementIdentifier | null>(null);

    const { primarySize, separatorProps, containerProps } = useSplitPane(window.innerWidth * 0.45);

    const transformerData: TransformerData | null = useTransformer(inputText, dims);

    useEffect(() => {
        if (highlight.activeComponent) {
          const explanationEl = document.getElementById(`math_${highlight.activeComponent}`);
          if (explanationEl) {
              setTimeout(() => {
                  explanationEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }, 100);
          }
        }
    }, [highlight.activeComponent]);

    useEffect(() => {
        if (viewMode !== 'none' && activeElement && transformerData) {
            const { highlight: newHighlight } = createBackwardHighlight(activeElement, transformerData, dims);
            const newCalculationData = generateTooltipData(activeElement, transformerData, newHighlight.sources);

            if (viewMode === 'decomposition') {
                setTooltip(newCalculationData);
                setAnimationData(null);
            } else { // animation mode
                if (newCalculationData && newCalculationData.opType !== 'info') {
                    setAnimationData(newCalculationData);
                    setTooltip(null);
                } else {
                    setAnimationData(null);
                    setTooltip(newCalculationData);
                }
            }
        } else {
            setTooltip(null);
            setAnimationData(null);
        }
    }, [viewMode, activeElement, transformerData, dims]);


    const handleInteraction = useCallback((element: ElementIdentifier, event: React.MouseEvent) => {
        if (!transformerData) return;
        const { highlight: newHighlight } = createBackwardHighlight(element, transformerData, dims);
        setHighlight(newHighlight);
        setActiveElement(element);
    }, [transformerData, dims]);

    const handleComponentClick = useCallback((componentId: string) => {
      setHighlight(prev => ({
          target: null, sources: [], destinations: [], activeComponent: componentId, activeResidual: null
      }));
      setTooltip(null);
      setAnimationData(null);
      setActiveElement(null);
      setViewMode('none');
    }, []);

    const closeTooltip = useCallback(() => {
        setTooltip(null);
        setViewMode('none');
        setActiveElement(null);
    }, []);

    const closeAnimationPanel = useCallback(() => {
        setAnimationData(null);
        setViewMode('none');
        setActiveElement(null);
    }, []);

    if (!transformerData) {
        return <div style={{padding: "20px", textAlign: "center"}}>正在加载或维度设置无效... (d_model 必须能被 h 整除)</div>
    }

    const explanationDims = {
      ...dims,
      encoder_seq_len: transformerData.encoderInput.length,
      decoder_seq_len: transformerData.decoderInput.length,
      vocab_size: Object.keys(transformerData.vocab).length
  };

    return (
        <div className="main-layout" {...containerProps} style={{padding: '0', gap: '0', height: '100%'}}>
            {tooltip && <CalculationTooltip tooltip={tooltip} onClose={closeTooltip} />}
            {animationData && <AnimationPanel animationData={animationData} onClose={closeAnimationPanel} />}
            <Controls dims={dims} setDims={setDims} inputText={inputText} setInputText={setInputText}/>
            <ViewToggle viewMode={viewMode} setViewMode={setViewMode} />

            <div className="column left-column" style={{width: primarySize, flex: 'none', borderRadius: '0', boxShadow: 'none'}}>
                <div className="column-content">
                    <h2>模型结构与数据流</h2>
                    <p style={{textAlign: 'center', margin: '-10px 0 15px 0', fontSize: '0.9em', color: '#555'}}>
                        提示: 点击任何矩阵单元格进行联动高亮。选择左上角视图模式后再次点击，可查看计算详情。
                    </p>
                    <Viz
                        data={transformerData}
                        highlight={highlight}
                        onElementClick={handleInteraction}
                        onComponentClick={handleComponentClick}
                    />
                </div>
            </div>
            <div className="split-pane-separator" {...separatorProps} />
            <div className="column right-column" style={{flex: 1, borderRadius: '0', boxShadow: 'none'}}>
                <div className="column-content">
                    <h2>数学原理详解</h2>
                    <Explanation
                        dims={explanationDims}
                        highlight={highlight}
                        onSymbolClick={handleInteraction}
                    />
                </div>
            </div>
        </div>
    );
}
// END OF FILE: src/topics/transformer-explorer/TransformerExplorerTopic.tsx



================================================================================
### 文件路径: src/topics/transformer-explorer/types.ts
================================================================================

// FILE: src/topics/transformer-explorer/types.ts
import { SymbolInfo } from '../../components/visualizers/types';
import { ElementIdentifier as GenericElementIdentifier, CalculationComponent as GenericCalculationComponent } from '../../components/CalculationTooltip/types';

export type Matrix = number[][];
export type Vector = number[];
export type CalculationComponent = GenericCalculationComponent;

// Extend the generic ElementIdentifier with topic-specific fields
export interface ElementIdentifier extends GenericElementIdentifier {
    matrixSymbol?: string;
    matrixDims?: string;
    tokenId?: number;
    tokenStr?: string;
    probValue?: number;
}

export interface HighlightSource extends ElementIdentifier {
    highlightRow?: boolean;
    highlightCol?: boolean;
    highlightProbCol?: boolean;
}

export interface HighlightState {
    activeComponent: string | null;
    activeResidual: string | null;
    target: ElementIdentifier | null;
    sources: HighlightSource[];
    destinations?: HighlightSource[];
}

export interface AttentionHeadData {
    Wq: Matrix;
    Wk: Matrix;
    Wv: Matrix;
    Q: Matrix;
    K: Matrix;
    V: Matrix;
    Scores: Matrix;
    ScaledScores: Matrix;
    AttentionWeights: Matrix;
    HeadOutput: Matrix;
}

export interface MultiHeadAttentionData {
    heads: AttentionHeadData[];
    ConcatOutput: Matrix;
    Wo: Matrix;
    output: Matrix;
}

export interface FFNData {
    W1: Matrix;
    b1: Vector;
    Intermediate: Matrix;
    Activated: Matrix;
    W2: Matrix;
    b2: Vector;
    Output: Matrix;
}

export interface EncoderLayerData {
    encoder_input: Matrix;
    mha: MultiHeadAttentionData;
    mha_output: Matrix;

    add_norm_1_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;

    add_norm_2_output: Matrix;
}

export interface DecoderLayerData {
    decoder_input: Matrix;
    masked_mha: MultiHeadAttentionData;
    masked_mha_output: Matrix;
    add_norm_1_output: Matrix;

    enc_dec_mha: MultiHeadAttentionData;
    enc_dec_mha_output: Matrix;
    add_norm_2_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;
    add_norm_3_output: Matrix;
}

export interface TransformerData {
    inputText: string[];
    tokenizedInput: number[];
    embeddingMatrix: Matrix;
    vocab: { [key: number]: string };
    inputEmbeddings: Matrix;
    posEncodings: Matrix;
    encoderInput: Matrix;
    encoderLayers: EncoderLayerData[];
    finalEncoderOutput: Matrix;
    outputEmbeddings: Matrix;
    decoderPosEncodings: Matrix;
    decoderInput: Matrix;
    decoderLayers: DecoderLayerData[];
    finalDecoderOutput: Matrix;
    finalLinear: Matrix;
    logits: Matrix;
    outputProbabilities: Matrix;
    decodedTokens: number[];
    outputText: string[];
}
// END OF FILE: src/topics/transformer-explorer/types.ts



================================================================================
### 文件路径: src/topics/transformer-explorer/utils/matrixView.ts
================================================================================

// FILE: src/topics/transformer-explorer/utils/matrixView.ts
export const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12; // e.g., 4 + 3 + 4 + 1 ellipsis = 12

/**
 * Calculates the visible indices for a row or column of a matrix based on a focus point.
 * It always shows the first and last `alwaysShowCount` items.
 * It shows a `windowSize` around the `focusIndex`.
 *
 * @param totalSize - The total number of items (rows or columns).
 * @param focusIndex - The index of the focused item, or -1 if no focus.
 * @param alwaysShowCount - The number of items to always show at the beginning and end.
 * @param windowSize - The size of the focus window around the focusIndex.
 * @returns An array of indices to display, with ELLIPSIS string for gaps.
 */
export const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {

  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }

  const visible = new Set<number>();

  // 1. Add always-visible indices
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }

  // [NEW] Also include the middle index when there's no specific focus
  if (focusIndex === -1 && totalSize >= MIN_SIZE_FOR_TRUNCATION) {
    visible.add(Math.floor((totalSize - 1) / 2));
  }

  // 2. Add focus window indices
  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }

  // 3. Build the final array with ellipses for gaps
  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];

  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }

  return result;
};
// END OF FILE: src/topics/transformer-explorer/utils/matrixView.ts



================================================================================
### 文件路径: public/index.html
================================================================================

<!--# FILE: public/index.html-->

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>终极 Transformer 深度探索器</title>
    <!-- 引入 MathJax 用于渲染 LaTeX 公式 -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

<!--# END OF FILE: public/index.html-->


