================================================================================
### 文件路径: src/App.css
================================================================================

/* START OF FILE: src/App.css */
/* FILE: src/App.css */
:root {
  --highlight-color: #c0392b;
  --highlight-bg: rgba(192, 57, 43, 0.08);
  --border-color: #dcdfe6;
  --bg-color: #f5f7fa;
  --text-color: #303133;
  --arrow-color: #888;
  --component-bg: #ffffff;
  --component-header-bg: #f8f9fa;
  --residual-bg: #f0f4c3;
  --residual-border: #dce775;

  /* Highlighting */
  --highlight-target-bg: #e63946;
  --highlight-target-color: #ffffff;
  --highlight-source-bg: #1d3557;
  --highlight-source-color: #f1faee;
  --highlight-formula-bg: #fefae0;
  --highlight-formula-border: #fca311;
  --highlight-vector-bg: rgba(69, 123, 157, 0.2);
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  background-color: var(--bg-color);
  color: var(--text-color);
  margin: 0;
  font-size: 15px;
}

#root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

h1 {
  text-align: center;
  color: #000;
  margin: 0;
  padding: 20px 0;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; /* Prevent title from shrinking */
}

.main-layout {
  display: flex;
  gap: 20px;
  flex-grow: 1; /* Allow layout to fill remaining space */
  overflow: hidden;
  padding: 20px;
  min-height: 0; /* Important for flex children scrolling */
}

.column {
  flex: 1;
  background: var(--component-bg);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
  overflow-y: auto; /* THIS IS THE KEY FOR SCROLLING */
  min-height: 0;
}

.column-content {
  padding: 20px;
}

.column.left-column {
  flex: 1.4;
}

.column h2 {
  font-size: 1.6em;
  margin: -20px -20px 20px -20px;
  padding: 20px 20px 15px 20px;
  text-align: center;
  color: #000;
  position: sticky;
  top: -21px; /* Adjust to hide top border */
  background: inherit;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
  border-radius: 12px 12px 0 0;
}

/* --- Left Column: Viz --- */
.diagram-component {
  border: 2px solid var(--border-color);
  border-radius: 10px;
  margin-bottom: 15px;
  background-color: #fdfdfd;
  transition: all 0.3s ease;
}

.component-header {
  background-color: var(--component-header-bg);
  padding: 8px 15px;
  font-weight: bold;
  font-size: 1.1em;
  border-bottom: 1px solid var(--border-color);
  border-radius: 8px 8px 0 0;
}
.component-body {
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
}

.arrow-down {
  width: 100%;
  text-align: center;
  font-size: 24px;
  color: var(--arrow-color);
  margin: 5px 0;
}

/* --- Matrix Styles --- */
.matrix-wrapper {
    position: relative;
}
.matrix-container {
  display: inline-block;
  border: 1px solid #ccc;
  padding: 5px;
  border-radius: 4px;
  background-color: #f9f9f9;
  position: relative;
}
.matrix-grid {
  display: grid;
  gap: 3px;
}

.matrix-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
  z-index: 2;
}

.matrix-element:hover {
  transform: scale(1.1);
  border-color: #007bff;
  box-shadow: 0 0 5px rgba(0,123,255,0.5);
  z-index: 5;
}

.matrix-element.source {
  background-color: var(--highlight-source-bg);
  color: var(--highlight-source-color);
  border-color: var(--highlight-source-bg);
}
.matrix-element.target {
  background-color: var(--highlight-target-bg);
  color: var(--highlight-target-color);
  border-color: var(--highlight-target-bg);
}

.vector-highlight-overlay {
    position: absolute;
    background-color: var(--highlight-vector-bg);
    border: 1px solid var(--highlight-source-bg);
    border-radius: 3px;
    z-index: 1;
    pointer-events: none;
    transition: all 0.2s ease;
}

.matrix-label {
  text-align: center;
  font-weight: bold;
  margin-top: 8px;
  font-family: monospace;
  font-size: 1.1em;
}

.op-symbol {
    font-size: 2em;
    font-weight: bold;
    color: #909399;
}

/* --- Right Column: Explanation --- */
.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block.active {
  border-color: var(--highlight-formula-border) !important;
  box-shadow: 0 0 30px var(--highlight-bg) !important;
  transform: scale(1.01);
  background-color: var(--highlight-formula-bg);
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li, .math-block h5 {
    line-height: 1.7;
    margin: 1em 0;
}
.math-block h5 {
    font-size: 1.1em;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

.formula-display {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
    margin: 20px 0;
    padding: 10px;
    overflow-x: auto;
}
.katex-display {
    margin: 0 !important;
}

/* Controls */
.controls-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 15px 20px;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  gap: 30px;
  flex-shrink: 0; /* Prevent controls from shrinking */
}
.control-group {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.control-group label {
  font-size: 0.9em;
  margin-bottom: 5px;
  color: #606266;
}
.control-group input {
  width: 60px;
  padding: 6px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  text-align: center;
  font-size: 1em;
}
.d_k-value {
    width: 60px;
    padding: 6px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: center;
    font-size: 1em;
    font-weight: bold;
    background-color: #f0f2f5;
}
/* END OF FILE: src/App.css */
/* END OF FILE: src/App.css */


================================================================================
### 文件路径: src/App.tsx
================================================================================

/* START OF FILE: src/App.tsx */
// FILE: src/App.tsx
import React, { useState, useCallback } from 'react';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { useTransformer } from './hooks/useTransformer';
import { ElementIdentifier, HighlightSource, HighlightState, TransformerData } from './types';

function App() {
  const [dims, setDims] = useState({
      d_model: 8,
      h: 2,
      seq_len: 3,
      n_layers: 1,
      d_ff: 32
  });
  const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [], activeComponent: null });

  const transformerData: TransformerData | null = useTransformer(dims);

  // ENHANCEMENT: Complete rewrite of the highlighting logic for bi-directional analysis.
  const handleElementClick = useCallback((element: ElementIdentifier) => {
      if (!transformerData) return;

      const { name, row, col } = element;
      const parts = name.split('.');

      let newSources: HighlightSource[] = [];
      let newTarget: ElementIdentifier | null = element;

      // FIX: Active component logic is now generic to support multiple layers
      // and correctly map to the single explanation block on the right.
      let activeComponent: string | null = null;
      const componentType = parts.length > 2 ? parts[2] : parts[0]; // e.g., mha, ffn, inputEmbeddings

      if (['inputEmbeddings', 'posEncodings', 'encoderInput'].includes(componentType)) {
          activeComponent = 'input_embed';
      } else if (componentType === 'mha') {
          activeComponent = 'mha';
      } else if (componentType === 'add_norm_1' || componentType === 'add_norm_2') {
          activeComponent = 'add_norm';
      } else if (componentType === 'ffn') {
          activeComponent = 'ffn';
      }


      const layerIdx = parts.length > 1 && parts[0] === 'encoder' ? parseInt(parts[1], 10) : 0;
      const matrixName = parts[parts.length -1];
      const d_k = dims.d_model / dims.h;

      // --- BACKWARD TRACING: "How was I computed?" (Element-centric style) ---
      if (name === 'encoderInput') {
          newSources.push({ name: 'inputEmbeddings', row, col });
          newSources.push({ name: 'posEncodings', row, col });
      } else if (componentType === 'mha') {
          const headIdx = parseInt(parts[3].replace('h', ''), 10);
          const headBasePath = `encoder.${layerIdx}.mha.h${headIdx}`;
          // The input to MHA is the output of the *previous* Add & Norm layer, or the initial encoder input
          const mhaInputName = layerIdx === 0
              ? `encoderInput`
              : `encoder.${layerIdx-1}.add_norm_2_out`;

          // If we click MHA input, we trace back to Add & Norm 1 output
          if (name.endsWith('add_norm_1_in_residual') && name.startsWith(`encoder.${layerIdx}.mha`)) {
              const prevLayerOutput = layerIdx > 0 ? `encoder.${layerIdx-1}.add_norm_2_out` : 'encoderInput';
              newSources.push({ name: prevLayerOutput, row, col });
          }

          if (['Q', 'K', 'V'].includes(matrixName)) {
              const weightName = `${headBasePath}.W${matrixName.toLowerCase()}`;
              const mhaInput = `encoder.${layerIdx}.add_norm_1_in_residual`; // MHA input is residual from Add&Norm1
              for (let k = 0; k < dims.d_model; k++) {
                  newSources.push({ name: mhaInput, row, col: k, highlightRow: true });
                  newSources.push({ name: weightName, row: k, col: col, highlightCol: true });
              }
          } else if (matrixName === 'Scores') {
              // FIX: Use highlightRow to highlight the entire vectors in Q and K.
              // This is more intuitive than highlighting individual cells.
              newSources.push({ name: `${headBasePath}.Q`, row: row, col: -1, highlightRow: true });
              newSources.push({ name: `${headBasePath}.K`, row: col, col: -1, highlightRow: true }); // K is transposed, so its row `col` becomes a column.
          } else if (matrixName === 'AttentionWeights') {
              // An attention weight is calculated from the entire corresponding row in Scores
               for (let k = 0; k < dims.seq_len; k++) {
                   newSources.push({ name: `${headBasePath}.Scores`, row, col: k, highlightRow: true});
               }
          } else if (matrixName === 'HeadOutput') {
              for (let k = 0; k < dims.seq_len; k++) {
                   newSources.push({ name: `${headBasePath}.AttentionWeights`, row, col: k, highlightRow: true });
              }
              for (let k = 0; k < d_k; k++) {
                   newSources.push({ name: `${headBasePath}.V`, row: -1, col: k, highlightCol: true }); // All rows of V contribute to the output
              }
          } else if (matrixName === 'Output') {
              const woName = `encoder.${layerIdx}.mha.Wo`;
              for (let k = 0; k < dims.d_model; k++) { // d_model = h * d_k
                  const headIdx = Math.floor(k / d_k);
                  const headCol = k % d_k;
                  newSources.push({ name: `encoder.${layerIdx}.mha.h${headIdx}.HeadOutput`, row, col: -1, highlightRow: true });
                  newSources.push({ name: woName, row: k, col: col, highlightCol: true });
              }
          }
      } else if (componentType === 'add_norm_1' || componentType === 'add_norm_2') {
          if (matrixName === 'out') {
              const baseName = parts.slice(0,3).join('.');
              // Element-wise addition, perfect 1-to-1 mapping
              newSources.push({ name: `${baseName}_in_residual`, row, col });
              newSources.push({ name: `${baseName}_in_sublayer`, row, col });
          }
      } else if (componentType === 'ffn') {
          const ffnInputName = `encoder.${layerIdx}.add_norm_1_out`;
          if (matrixName === 'Intermediate' || matrixName === 'Activated') {
              const w1Name = `encoder.${layerIdx}.ffn.W1`;
              for(let k=0; k < dims.d_model; k++) {
                  newSources.push({ name: ffnInputName, row, col: k, highlightRow: true });
                  newSources.push({ name: w1Name, row: k, col: col, highlightCol: true });
              }
          } else if (matrixName === 'Output') {
              const activatedName = `encoder.${layerIdx}.ffn.Activated`;
              const w2Name = `encoder.${layerIdx}.ffn.W2`;
              for(let k=0; k < dims.d_ff; k++) {
                  newSources.push({ name: activatedName, row, col: k, highlightRow: true });
                  newSources.push({ name: w2Name, row: k, col: col, highlightCol: true });
              }
          }
      }

      const newHighlightState: HighlightState = { target: newTarget, sources: newSources, activeComponent };
      setHighlight(newHighlightState);

      setTimeout(() => {
          const explanationEl = document.getElementById(`math_${activeComponent}`);
          if (explanationEl) {
              explanationEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
      }, 0);

  }, [transformerData, dims]);

  if (!transformerData) {
      return <div>Loading or Invalid Dimensions... (d_model must be divisible by h)</div>
  }

  return (
    <div className="app-container">
      <h1>终极 Transformer 深度探索器 (极简版)</h1>
      <Controls dims={dims} setDims={setDims} />
      <div className="main-layout">
        <div className="column left-column">
          <div className="column-content">
              <h2>模型结构与数据流</h2>
              <Viz
                data={transformerData}
                highlight={highlight}
                onElementClick={handleElementClick}
              />
          </div>
        </div>
        <div className="column right-column">
           <div className="column-content">
              <h2>数学原理</h2>
              <Explanation
                dims={dims}
                highlight={highlight}
              />
           </div>
        </div>
      </div>
    </div>
  );
}

export default App;
// END OF FILE: src/App.tsx
/* END OF FILE: src/App.tsx */


================================================================================
### 文件路径: src/index.tsx
================================================================================

/* START OF FILE: src/index.tsx */
// FILE: src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
// END OF FILE: src/index.tsx
/* END OF FILE: src/index.tsx */


================================================================================
### 文件路径: src/styles.css
================================================================================

/* START OF FILE: src/styles.css */

/* END OF FILE: src/styles.css */


================================================================================
### 文件路径: src/types.ts
================================================================================

/* START OF FILE: src/types.ts */
// FILE: src/types.ts
export type Matrix = number[][];
export type Vector = number[];

export interface ElementIdentifier {
  name: string; // e.g., "encoder.0.mha.h0.Q"
  row: number;
  col: number;
}

export interface HighlightSource extends ElementIdentifier {
  highlightRow?: boolean;
  highlightCol?: boolean;
}

export interface HighlightState {
  activeComponent: string | null; // e.g., "encoder.0.mha"
  target: ElementIdentifier | null;
  sources: HighlightSource[];
}

export interface AttentionHeadData {
  Wq: Matrix;
  Wk: Matrix;
  Wv: Matrix;
  Q: Matrix;
  K: Matrix;
  V: Matrix;
  Scores: Matrix;
  ScaledScores: Matrix;
  AttentionWeights: Matrix;
  HeadOutput: Matrix;
}

export interface MultiHeadAttentionData {
    heads: AttentionHeadData[];
    Wo: Matrix;
    Output: Matrix;
}

export interface FFNData {
    W1: Matrix;
    b1: Vector;
    Intermediate: Matrix;
    Activated: Matrix;
    W2: Matrix;
    b2: Vector;
    Output: Matrix;
}

export interface EncoderLayerData {
    mha: MultiHeadAttentionData;
    add_norm_1_in_residual: Matrix;
    add_norm_1_in_sublayer: Matrix;
    add_norm_1_out: Matrix;
    ffn: FFNData;
    add_norm_2_in_residual: Matrix;
    add_norm_2_in_sublayer: Matrix;
    add_norm_2_out: Matrix;
}

export interface TransformerData {
    inputEmbeddings: Matrix;
    posEncodings: Matrix;
    encoderInput: Matrix;
    encoderLayers: EncoderLayerData[];
}
// END OF FILE: src/types.ts
/* END OF FILE: src/types.ts */


================================================================================
### 文件路径: src/components/AddNorm.tsx
================================================================================

/* START OF FILE: src/components/AddNorm.tsx */
// FILE: src/components/AddNorm.tsx
import React from 'react';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface AddNormProps {
    baseName: string;
    inputResidual: MatrixType;
    inputSublayer: MatrixType;
    output: MatrixType;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const AddNorm: React.FC<AddNormProps> = ({ baseName, inputResidual, inputSublayer, output, highlight, onElementClick }) => {
    return (
         <div className="diagram-component">
            <div className="component-header">Add & LayerNorm</div>
            <div className="component-body">
                <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                    <Matrix name={`${baseName}_in_residual`} data={inputResidual} highlight={highlight} onElementClick={onElementClick} />
                    <div className="op-symbol">+</div>
                    <Matrix name={`${baseName}_in_sublayer`} data={inputSublayer} highlight={highlight} onElementClick={onElementClick} />
                </div>
                <div className="arrow-down"><InlineMath math="\rightarrow \text{LayerNorm} \rightarrow" /></div>
                <Matrix name={`${baseName}_out`} data={output} highlight={highlight} onElementClick={onElementClick} />
            </div>
        </div>
    );
};
// END OF FILE: src/components/AddNorm.tsx
/* END OF FILE: src/components/AddNorm.tsx */


================================================================================
### 文件路径: src/components/Controls.tsx
================================================================================

/* START OF FILE: src/components/Controls.tsx */
// FILE: src/components/Controls.tsx
import React from 'react';

interface ControlsProps {
  dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
  setDims: (dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number }) => void;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims }) => {

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    let newDims = { ...dims, [id]: parseInt(value, 10) || 1 };

    // Ensure d_model is divisible by h
    if (id === 'h') {
        if (newDims.d_model % newDims.h !== 0) {
             newDims.d_model = Math.max(newDims.h, Math.ceil(newDims.d_model / newDims.h) * newDims.h);
        }
    }
    if (id === 'd_model') {
         if (newDims.d_model % newDims.h !== 0) {
             let best_h = 1;
             for (let i = 1; i <= newDims.d_model; i++) {
                 if (newDims.d_model % i === 0) {
                    if (Math.abs(i - newDims.h) < Math.abs(best_h - newDims.h)) {
                       best_h = i;
                    }
                 }
             }
             newDims.h = best_h;
         }
    }

    // Ensure d_ff is a multiple of d_model
    if(id === 'd_model') {
        newDims.d_ff = newDims.d_model * 4;
    }

    setDims(newDims);
  };

  const d_k = dims.d_model % dims.h === 0 ? dims.d_model / dims.h : 'N/A';

  return (
    <div className="controls-container">
      <div className="control-group">
        <label htmlFor="seq_len">序列长度 (seq_len)</label>
        <input type="number" id="seq_len" value={dims.seq_len} onChange={handleInputChange} min="2" max="5" />
      </div>
      <div className="control-group">
        <label htmlFor="d_model">模型维度 (d_model)</label>
        <input type="number" id="d_model" value={dims.d_model} onChange={handleInputChange} step={1} min={2} max="16"/>
      </div>
      <div className="control-group">
        <label htmlFor="h">注意力头数 (h)</label>
        <input type="number" id="h" value={dims.h} onChange={handleInputChange} min="1" max={dims.d_model}/>
      </div>
      <div className="control-group">
        <label htmlFor="n_layers">层数 (N)</label>
        <input type="number" id="n_layers" value={dims.n_layers} onChange={handleInputChange} min="1" max="3"/>
      </div>
       <div className="control-group">
        <label>键/查询维度 (d_k)</label>
        <div className="d_k-value">{d_k}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Controls.tsx
/* END OF FILE: src/components/Controls.tsx */


================================================================================
### 文件路径: src/components/DecoderLayer.tsx
================================================================================

/* START OF FILE: src/components/DecoderLayer.tsx */
// FILE: src/components/DecoderLayer.tsx
// This file is intentionally left blank for this version,
// as the focus is on a complete and correct Encoder implementation.
export {};
// END OF FILE: src/components/DecoderLayer.tsx
/* END OF FILE: src/components/DecoderLayer.tsx */


================================================================================
### 文件路径: src/components/Element.tsx
================================================================================

/* START OF FILE: src/components/Element.tsx */
// FILE: src/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

// The 'export' keyword here is crucial. It makes this file a module.
export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col;
  const isSource = highlight.sources.some(s => s.name === name && s.row === row && s.col === col);

  const className = `matrix-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''}`;

  const handleClick = () => {
    onElementClick({ name, row, col });
  };

  return (
    <div className={className} onClick={handleClick}>
      {value.toFixed(2)}
    </div>
  );
});
// END OF FILE: src/components/Element.tsx



================================================================================
### 文件路径: src/components/EncoderLayer.tsx
================================================================================

/* START OF FILE: src/components/EncoderLayer.tsx */
// FILE: src/components/EncoderLayer.tsx
import React from 'react';
import { EncoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { MultiHeadAttention } from './MultiHeadAttention';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';

interface EncoderLayerProps {
  layerIndex: number;
  data: EncoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const EncoderLayer: React.FC<EncoderLayerProps> = ({ layerIndex, data, highlight, onElementClick }) => {
  const baseName = `encoder.${layerIndex}`;
  return (
    <>
        <div className="arrow-down">↓</div>
        <div className="diagram-component">
            <div className="component-header" style={{backgroundColor: '#e3f2fd'}}>Encoder Layer {layerIndex + 1}</div>
            <div className="component-body" style={{padding: '5px'}}>

                <MultiHeadAttention
                    baseName={`${baseName}.mha`}
                    data={data.mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />

                <AddNorm
                    baseName={`${baseName}.add_norm_1`}
                    inputResidual={data.add_norm_1_in_residual}
                    inputSublayer={data.add_norm_1_in_sublayer}
                    output={data.add_norm_1_out}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />

                <FeedForward
                    baseName={`${baseName}.ffn`}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />

                <AddNorm
                    baseName={`${baseName}.add_norm_2`}
                    inputResidual={data.add_norm_2_in_residual}
                    inputSublayer={data.add_norm_2_in_sublayer}
                    output={data.add_norm_2_out}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
            </div>
        </div>
    </>
  );
};
// END OF FILE: src/components/EncoderLayer.tsx
/* END OF FILE: src/components/EncoderLayer.tsx */


================================================================================
### 文件路径: src/components/Explanation.tsx
================================================================================

/* START OF FILE: src/components/Explanation.tsx */
// FILE: src/components/Explanation.tsx
import React from 'react';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { SymbolicMatrix } from './SymbolicMatrix';
import { HighlightState } from '../types';

interface ExplanationProps {
    dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
    highlight: HighlightState;
}

interface MathBlockProps {
    id: string;
    title: string;
    children: React.ReactNode;
    highlight: HighlightState;
}

const MathBlock: React.FC<MathBlockProps> = ({ id, title, children, highlight }) => {
    const isActive = highlight.activeComponent ? id.includes(highlight.activeComponent) : false;
    return (
        <div id={`math_${id}`} className={`math-block ${isActive ? 'active' : ''}`}>
            <h3>{title}</h3>
            {children}
        </div>
    );
};

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight }) => {
    const d_k = dims.d_model / dims.h;

    // ENHANCEMENT: The names passed to this function are now the full, unique identifiers
    // This allows the SymbolicMatrix component to correctly sync with the highlight state.
    const renderMatrixProduct = (
        A_name: string, B_name: string, C_name: string,
        A_prefix: string, B_prefix: string, C_prefix: string,
        a_rows: number, a_cols: number,
        b_rows: number, b_cols: number,
        b_transpose: boolean = false
    ) => {
      return (
         <div className="formula-display">
            <SymbolicMatrix name={A_name} prefix={A_prefix} rows={a_rows} cols={a_cols} highlight={highlight} />
            <BlockMath math="\times" />
            <SymbolicMatrix name={B_name} prefix={B_prefix} rows={b_rows} cols={b_cols} highlight={highlight} transpose={b_transpose} />
            <BlockMath math="=" />
            <SymbolicMatrix name={C_name} prefix={C_prefix} rows={a_rows} cols={b_cols} highlight={highlight} />
        </div>
      )
    }

    // Define full names for layer 0 components to ensure correct highlighting
    const baseMhaName = 'encoder.0.mha.h0';
    const baseFfnName = 'encoder.0.ffn';
    const baseAddNorm1Name = 'encoder.0.add_norm_1';

    return (
        <div>
             <MathBlock id="input_embed" title="输入嵌入 (Input Embedding)" highlight={highlight}>
                <BlockMath math={`Z_{0;${dims.seq_len}\\times${dims.d_model}} = \\text{Embedding}(X) + \\text{PE}(X)`} />
                <p>此步骤将输入的文本序列转换为模型可以处理的、包含位置信息的数值向量。我们以一个序列 (长度={dims.seq_len}) 为例，当前模型维度 <InlineMath math={`d_{model}=${dims.d_model}`} />。</p>
                <div className="formula-display">
                    <SymbolicMatrix name="inputEmbeddings" rows={dims.seq_len} cols={dims.d_model} prefix="e" highlight={highlight} />
                    <BlockMath math="+" />
                    <SymbolicMatrix name="posEncodings" rows={dims.seq_len} cols={dims.d_model} prefix="pe" highlight={highlight} />
                    <BlockMath math="=" />
                    <SymbolicMatrix name="encoderInput" rows={dims.seq_len} cols={dims.d_model} prefix="z" highlight={highlight} />
                </div>
             </MathBlock>

             <MathBlock id="encoder.0.mha" title="编码器：多头注意力 (Multi-Head Attention)" highlight={highlight}>
                <BlockMath math={`\\text{MultiHead}(Z) = \\text{Concat}(\\text{head}_0, ..., \\text{head}_{${dims.h-1}})W^O`} />
                <h5>为单个头生成 Q, K, V</h5>
                <BlockMath math={`Q = Z W^Q, \\quad K = Z W^K, \\quad V = Z W^V`} />
                {renderMatrixProduct(`${baseAddNorm1Name}_in_residual`, `${baseMhaName}.Wq`, `${baseMhaName}.Q`, 'z', 'w^q', 'q', dims.seq_len, dims.d_model, dims.d_model, d_k)}
                <h5>计算注意力分数</h5>
                <BlockMath math="\\text{Scores} = Q K^T" />
                {renderMatrixProduct(`${baseMhaName}.Q`, `${baseMhaName}.K`, `${baseMhaName}.Scores`, 'q', 'k', 's', dims.seq_len, d_k, d_k, dims.seq_len, true)}
                <h5>缩放、Softmax 和加权求和</h5>
                <BlockMath math={`\\text{head}_i = \\text{softmax}\\left(\\frac{\\text{Scores}}{\\sqrt{d_k}}\\right)V`} />
             </MathBlock>

             <MathBlock id="encoder.0.add_norm_1" title="残差连接与层归一化 (Add & Norm)" highlight={highlight}>
                <BlockMath math="X_{out} = \\text{LayerNorm}(X_{in} + \\text{Sublayer}(X_{in}))" />
                <div className="formula-display">
                    <SymbolicMatrix name={`${baseAddNorm1Name}_in_residual`} prefix="x" rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                    <BlockMath math="+" />
                    <SymbolicMatrix name={`${baseAddNorm1Name}_in_sublayer`} prefix="m" rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <SymbolicMatrix name={`${baseAddNorm1Name}_out`} prefix="y" rows={dims.seq_len} cols={dims.d_model} highlight={highlight} />
                </div>
             </MathBlock>

              <MathBlock id="encoder.0.ffn" title="前馈神经网络 (Feed-Forward Network)" highlight={highlight}>
                <BlockMath math="\text{FFN}(X) = \text{ReLU}(XW_1 + b_1)W_2 + b_2" />
                <h5>1. 第一次线性变换 (维度扩展)</h5>
                {renderMatrixProduct(`${baseAddNorm1Name}_out`, `${baseFfnName}.W1`, `${baseFfnName}.Intermediate`, 'x', 'w', 'h', dims.seq_len, dims.d_model, dims.d_model, dims.d_ff)}
                <h5>2. 第二次线性变换 (维度投影)</h5>
                {renderMatrixProduct(`${baseFfnName}.Activated`, `${baseFfnName}.W2`, `${baseFfnName}.Output`, 'h', 'w', 'y', dims.seq_len, dims.d_ff, dims.d_ff, dims.d_model)}
             </MathBlock>
        </div>
    );
};
// END OF FILE: src/components/Explanation.tsx
/* END OF FILE: src/components/Explanation.tsx */


================================================================================
### 文件路径: src/components/FeedForward.tsx
================================================================================

/* START OF FILE: src/components/FeedForward.tsx */
// FILE: src/components/FeedForward.tsx
import React from 'react';
import { FFNData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface FFNProps {
    baseName: string;
    data: FFNData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const FeedForward: React.FC<FFNProps> = ({ baseName, data, highlight, onElementClick }) => {
    return (
        <div className="diagram-component">
            <div className="component-header">Feed-Forward Network</div>
            <div className="component-body">
                <p>Input (from Add & Norm)</p>
                <div className="arrow-down">↓</div>
                <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                    <span>Linear 1 & ReLU →</span>
                    <Matrix name={`${baseName}.W1`} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                    <Matrix name={`${baseName}.Activated`} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                </div>
                 <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center', marginTop: '10px'}}>
                    <span>Linear 2 →</span>
                    <Matrix name={`${baseName}.W2`} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                    <Matrix name={`${baseName}.Output`} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/FeedForward.tsx
/* END OF FILE: src/components/FeedForward.tsx */


================================================================================
### 文件路径: src/components/Matrix.tsx
================================================================================

/* START OF FILE: src/components/Matrix.tsx */
// FILE: src/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
  isTransposed?: boolean;
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, isTransposed = false }) => {
  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const rows = isTransposed ? data[0].length : data.length;
  const cols = isTransposed ? data.length : data[0].length;

  const gridTemplateColumns = `repeat(${cols}, auto)`;

  const vectorHighlights = highlight.sources
    .filter(s => s.name === name && (s.highlightRow || s.highlightCol))
    .map((s, i) => {
       const elementWidth = 45;
       const elementHeight = 25;
       const gap = 3;
       let style: React.CSSProperties = {};

       // The source `s` refers to the original data matrix.
       // `isTransposed` refers to how this component is displaying the data.
       // `rows` and `cols` are the *visual* dimensions of this component.
       const highlightDataRow = s.highlightRow ?? false;
       const highlightDataCol = s.highlightCol ?? false;

       // FIX: This logic correctly renders highlights on transposed matrices
       // by swapping row/column highlighting logic as needed.
       if (isTransposed) {
           // A data row is a visual column. A data col is a visual row.
           if (highlightDataRow) { // Highlight a visual column
               style.width = `${elementWidth}px`;
               style.height = `calc(${rows} * (${elementHeight}px + ${gap}px) - ${gap}px)`;
               style.top = `5px`;
               style.left = `${s.row * (elementWidth + gap) + 5}px`; // The data row index is the visual column index.
           } else if (highlightDataCol) { // Highlight a visual row
               style.width = `calc(${cols} * (${elementWidth}px + ${gap}px) - ${gap}px)`;
               style.height = `${elementHeight}px`;
               style.top = `${s.col * (elementHeight + gap) + 5}px`; // The data col index is the visual row index.
               style.left = `5px`;
           }
       } else {
           // Standard display
           if (highlightDataRow) { // Highlight a visual row
               style.width = `calc(${cols} * (${elementWidth}px + ${gap}px) - ${gap}px)`;
               style.height = `${elementHeight}px`;
               style.top = `${s.row * (elementHeight + gap) + 5}px`;
               style.left = `5px`;
           } else if (highlightDataCol) { // Highlight a visual column
               style.width = `${elementWidth}px`;
               style.height = `calc(${rows} * (${elementHeight}px + ${gap}px) - ${gap}px)`;
               style.top = `5px`;
               style.left = `${s.col * (elementWidth + gap) + 5}px`;
           }
       }
       return <div key={`${s.name}-${s.row}-${s.col}-${i}`} className="vector-highlight-overlay" style={style} />;
    });


  return (
    <div className="matrix-wrapper">
      <div className="matrix-container">
        {vectorHighlights}
        <div className="matrix-grid" style={{ gridTemplateColumns }}>
          {Array.from({ length: rows }).map((_, r) => (
            <React.Fragment key={`row-${r}`}>
            {Array.from({ length: cols }).map((_, c) => {
              const originalRow = isTransposed ? c : r;
              const originalCol = isTransposed ? r : c;
              const value = data[originalRow][originalCol];

              return (
                <Element
                  key={`${name}-${originalRow}-${originalCol}`}
                  name={name}
                  row={originalRow}
                  col={originalCol}
                  value={value}
                  highlight={highlight}
                  onElementClick={onElementClick}
                />
              );
            })}
            </React.Fragment>
          ))}
        </div>
      </div>
      <div className="matrix-label"><InlineMath>{`${name.split('.').pop()}${isTransposed ? '^T' : ''}`}</InlineMath></div>
    </div>
  );
};
// END OF FILE: src/components/Matrix.tsx
/* END OF FILE: src/components/Matrix.tsx */


================================================================================
### 文件路径: src/components/MultiHeadAttention.tsx
================================================================================

/* START OF FILE: src/components/MultiHeadAttention.tsx */
// FILE: src/components/MultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface MHAProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const MultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick }) => {
    // Simplified to show only the first head's details for clarity
    const headData = data.heads[0];
    const headBaseName = `${baseName}.h0`;

    return (
        <div className="diagram-component">
            <div className="component-header">Multi-Head Attention</div>
            <div className="component-body">
                <p>Input (from previous layer)</p>
                <div className="arrow-down">↓</div>

                {/* Q, K, V Generation */}
                <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', alignItems: 'center', gap: '15px'}}>
                   <span>Q = Z × Wq →</span>
                   <Matrix name={`${headBaseName}.Wq`} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                   <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                </div>
                 <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', alignItems: 'center', gap: '15px', marginTop: '10px'}}>
                   <span>K = Z × Wk →</span>
                   <Matrix name={`${headBaseName}.Wk`} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                   <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                </div>
                 <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', alignItems: 'center', gap: '15px', marginTop: '10px'}}>
                   <span>V = Z × Wv →</span>
                   <Matrix name={`${headBaseName}.Wv`} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                   <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down">↓</div>
                <p>Scaled Dot-Product Attention (Head 1)</p>

                <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                    <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    <InlineMath math="\times" />
                    <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                     <InlineMath math="\rightarrow" />
                    <Matrix name={`${headBaseName}.Scores`} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    {/* FIX: Escaped the '&' character to '\\&' to prevent KaTeX parse error. */}
                    <InlineMath math="\xrightarrow{\text{scale \\& softmax}}" />
                    <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                     <InlineMath math="\times" />
                    <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                     <InlineMath math="=" />
                    <Matrix name={`${headBaseName}.HeadOutput`} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                </div>

                <div className="arrow-down">↓</div>
                <p>Concat & Final Projection</p>

                 <div style={{display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', justifyContent: 'center'}}>
                   <Matrix name={`${headBaseName}.HeadOutput`} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick} />
                   <InlineMath math="..." />
                   <Matrix name={`${baseName}.Wo`} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                   <InlineMath math="=" />
                   <Matrix name={`${baseName}.Output`} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/MultiHeadAttention.tsx
/* END OF FILE: src/components/MultiHeadAttention.tsx */


================================================================================
### 文件路径: src/components/SymbolicMatrix.tsx
================================================================================

/* START OF FILE: src/components/SymbolicMatrix.tsx */
// FILE: src/components/SymbolicMatrix.tsx
import React from 'react';
import { HighlightState } from '../types';
import { BlockMath } from 'react-katex';

interface SymbolicMatrixProps {
  name: string;
  rows: number;
  cols: number;
  prefix: string;
  highlight: HighlightState;
  transpose?: boolean;
}

export const SymbolicMatrix: React.FC<SymbolicMatrixProps> = ({ name, rows, cols, prefix, highlight, transpose = false }) => {

  const displayRows = transpose ? cols : rows;
  const displayCols = transpose ? rows : cols;

  const getElement = (r_idx: number, c_idx: number): string => {
      const originalRow = transpose ? c_idx : r_idx;
      const originalCol = transpose ? r_idx : c_idx;

      const rawMatrixName = name.split('.').pop() || '';
      const nameParts = rawMatrixName.match(/^([a-zA-Z_]+)(\d*)$/);
      const nameSubscript = (nameParts && nameParts[2]) ? `,${nameParts[2]}` : '';

      let elementString = `${prefix}_{${originalRow},${originalCol}${nameSubscript}}`;

      const isTarget = highlight.target?.name === name && highlight.target?.row === originalRow && highlight.target?.col === originalCol;
      const isSource = highlight.sources.some(s => s.name === name && s.row === originalRow && s.col === originalCol);

      if (isTarget) {
        elementString = `\\textcolor{#e63946}{\\underline{${elementString}}}`;
      } else if (isSource) {
        elementString = `\\textcolor{#1d3557}{\\mathbf{${elementString}}}`;
      }
      return elementString;
  }

  // FIX: Removed all truncation logic to fully expand all matrices.
  let matrixRows: string[] = [];
  for (let r = 0; r < displayRows; r++) {
      let matrixCols: string[] = [];
      for (let c = 0; c < displayCols; c++) {
          matrixCols.push(getElement(r, c));
      }
      matrixRows.push(matrixCols.join(' & '));
  }

  const matrixString = matrixRows.join(' \\\\ ');
  const bmatrix = `\\begin{pmatrix} ${matrixString} \\end{pmatrix}`;

  const rawName = name.split('.').pop() || name;
  const nameParts = rawName.match(/^([a-zA-Z_]+)(\d*)$/);
  let baseName;
  let nameSubscript;

  if (nameParts && nameParts[2]) {
      baseName = nameParts[1];
      nameSubscript = nameParts[2];
  } else {
      baseName = rawName.replace(/_/g, '\\_');
      nameSubscript = null;
  }

  const dimsSubscript = `${displayRows}\\times${displayCols}`;
  const finalSubscript = nameSubscript ? `${nameSubscript},${dimsSubscript}` : dimsSubscript;

  const finalFormula = `${baseName}_{${finalSubscript}}${transpose ? '^T' : ''} = ${bmatrix}`;

  return <BlockMath math={finalFormula} />;
};
// END OF FILE: src/components/SymbolicMatrix.tsx
/* END OF FILE: src/components/SymbolicMatrix.tsx */


================================================================================
### 文件路径: src/components/Viz.tsx
================================================================================

/* START OF FILE: src/components/Viz.tsx */
// FILE: src/components/Viz.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EncoderLayer } from './EncoderLayer';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface VizProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const Viz: React.FC<VizProps> = ({ data, highlight, onElementClick }) => {
    return (
        <div>
            <div className="diagram-component">
                <div className="component-header">Input Embedding & Positional Encoding</div>
                <div className="component-body">
                    <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                    <div className="op-symbol">+</div>
                    <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            <div className="arrow-down">↓</div>

            <div className="diagram-component">
                <div className="component-header">Encoder Input (<InlineMath math="Z_0" />)</div>
                <div className="component-body">
                     <Matrix name="encoderInput" data={data.encoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.encoderLayers.map((layer, i) => (
                <EncoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
            ))}
        </div>
    );
};
// END OF FILE: src/components/Viz.tsx
/* END OF FILE: src/components/Viz.tsx */


================================================================================
### 文件路径: src/hooks/useTransformer.ts
================================================================================

/* START OF FILE: src/hooks/useTransformer.ts */
// FILE: src/hooks/useTransformer.ts
import { useMemo } from 'react';
import { Matrix, TransformerData, EncoderLayerData, FFNData, MultiHeadAttentionData, AttentionHeadData, Vector } from '../types';

// --- Utility Functions ---

const createRandomMatrix = (rows: number, cols: number): Matrix => {
  return Array.from({ length: rows }, () => 
    Array.from({ length: cols }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)))
  );
};

const createRandomVector = (size: number): Vector => {
  return Array.from({ length: size }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)));
}

const addMatrices = (A: Matrix, B: Matrix): Matrix => {
  return A.map((row, i) => 
    row.map((val, j) => parseFloat((val + B[i][j]).toFixed(2)))
  );
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
  const rowsA = A.length;
  const colsA = A[0].length;
  const colsB = B[0].length;
  const result: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));

  for (let i = 0; i < rowsA; i++) {
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      result[i][j] = parseFloat(sum.toFixed(2));
    }
  }
  return result;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => {
    return A.map(row => row.map(val => parseFloat((val / scalar).toFixed(2))));
}

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row);
        const exps = row.map(val => Math.exp(val - maxVal));
        const sumExps = exps.reduce((a, b) => a + b, 0);
        return exps.map(exp => parseFloat((exp / sumExps).toFixed(2)));
    });
}

const layerNorm = (A: Matrix): Matrix => {
    return A.map(row => {
        const mean = row.reduce((a,b) => a+b, 0) / row.length;
        const variance = row.map(x => (x - mean) ** 2).reduce((a,b) => a+b,0) / row.length;
        const std = Math.sqrt(variance + 1e-5);
        return row.map(x => parseFloat(((x - mean) / std).toFixed(2)));
    });
}

const applyReLU = (A: Matrix): Matrix => {
    return A.map(row => row.map(val => Math.max(0, val)));
}

const addBias = (A: Matrix, b: Vector): Matrix => {
    return A.map(row => row.map((val, j) => parseFloat((val + b[j]).toFixed(2))));
}

// --- Main Hook ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number;
    n_layers: number;
    d_ff: number;
}

export const useTransformer = (dims: Dims): TransformerData | null => {

  return useMemo(() => {
    try {
        const { d_model, h, seq_len, n_layers, d_ff } = dims;
        if (d_model % h !== 0) return null;
        const d_k = d_model / h;

        const inputEmbeddings = createRandomMatrix(seq_len, d_model);
        const posEncodings: Matrix = Array.from({ length: seq_len }, (_, pos) =>
          Array.from({ length: d_model }, (_, i) => 
            parseFloat((i % 2 === 0 
              ? Math.sin(pos / (10000 ** (i / d_model)))
              : Math.cos(pos / (10000 ** ((i - 1) / d_model)))).toFixed(2))
          )
        );
        const encoderInput = addMatrices(inputEmbeddings, posEncodings);

        let currentInput = encoderInput;
        const encoderLayers: EncoderLayerData[] = [];

        for (let i = 0; i < n_layers; i++) {
            // MHA
            const heads: AttentionHeadData[] = [];
            const headOutputs: Matrix[] = [];
            for(let j=0; j < h; j++) {
                const Wq = createRandomMatrix(d_model, d_k);
                const Wk = createRandomMatrix(d_model, d_k);
                const Wv = createRandomMatrix(d_model, d_k);

                const Q = multiplyMatrices(currentInput, Wq);
                const K = multiplyMatrices(currentInput, Wk);
                const V = multiplyMatrices(currentInput, Wv);

                const K_T: Matrix = Array.from({ length: d_k }, (_, r) => Array.from({ length: seq_len }, (_, c) => K[c][r]));
                const Scores = multiplyMatrices(Q, K_T);

                const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
                const AttentionWeights = softmaxByRow(ScaledScores);
                const HeadOutput = multiplyMatrices(AttentionWeights, V);

                heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
                headOutputs.push(HeadOutput);
            }
            const ConcatOutput = headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(seq_len).fill(0).map(() => []));
            const Wo = createRandomMatrix(d_model, d_model);
            const mhaOutput = multiplyMatrices(ConcatOutput, Wo);
            const mha: MultiHeadAttentionData = { heads, Wo, Output: mhaOutput };

            // Add & Norm 1
            const add_norm_1_in_residual = currentInput;
            const add_norm_1_in_sublayer = mha.Output;
            const add_norm_1_sum = addMatrices(add_norm_1_in_residual, add_norm_1_in_sublayer);
            const add_norm_1_out = layerNorm(add_norm_1_sum);

            // FFN
            const W1 = createRandomMatrix(d_model, d_ff);
            const b1 = createRandomVector(d_ff);
            const Intermediate = addBias(multiplyMatrices(add_norm_1_out, W1), b1);
            const Activated = applyReLU(Intermediate);
            const W2 = createRandomMatrix(d_ff, d_model);
            const b2 = createRandomVector(d_model);
            const ffnOutput = addBias(multiplyMatrices(Activated, W2), b2);
            const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffnOutput };

            // Add & Norm 2
            const add_norm_2_in_residual = add_norm_1_out;
            const add_norm_2_in_sublayer = ffn.Output;
            const add_norm_2_sum = addMatrices(add_norm_2_in_residual, add_norm_2_in_sublayer);
            const add_norm_2_out = layerNorm(add_norm_2_sum);

            encoderLayers.push({
                mha,
                add_norm_1_in_residual,
                add_norm_1_in_sublayer,
                add_norm_1_out,
                ffn,
                add_norm_2_in_residual,
                add_norm_2_in_sublayer,
                add_norm_2_out
            });

            currentInput = add_norm_2_out;
        }

        return {
            inputEmbeddings,
            posEncodings,
            encoderInput,
            encoderLayers
        };
    } catch (e) {
        console.error("Error during transformer calculation:", e);
        return null;
    }
  }, [dims]);
};
// END OF FILE: src/hooks/useTransformer.ts
/* END OF FILE: src/hooks/useTransformer.ts */


================================================================================
### 文件路径: public/index.html
================================================================================

<!-- START OF FILE: public/index.html -->
<!--# FILE: public/index.html-->

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>矩阵可视化 (React)</title>
    <!-- 引入 MathJax 用于渲染 LaTeX 公式 -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

<!--# END OF FILE: public/index.html-->


