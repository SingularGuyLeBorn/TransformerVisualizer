================================================================================
### 文件路径: src/App.css
================================================================================

/* FILE: src/App.css */
:root {
  --highlight-color: #c0392b;
  --highlight-bg: rgba(192, 57, 43, 0.08);
  --border-color: #dcdfe6;
  --bg-color: #f5f7fa;
  --text-color: #303133;
  --arrow-color: #888;
  --component-bg: #ffffff;
  --component-header-bg: #f8f9fa;
  --residual-bg: #f0f4c3;
  --residual-border: #dce775;

  /* Highlighting */
  --highlight-target-bg: #e63946;
  --highlight-target-color: #ffffff;
  --highlight-source-bg: #606266; /* [MODIFIED] Changed from dark blue to gray */
  --highlight-source-color: #f1faee;
  /* 调整为半透明橙红色调 */
  --highlight-formula-bg: rgba(252, 163, 17, 0.15); /* 橙红色（#fca311）的15%透明度 */
  --highlight-formula-border: #fca311; /* 橙红色 */
  --highlight-vector-bg: rgba(69, 123, 157, 0.2);
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  background-color: var(--bg-color);
  color: var(--text-color);
  margin: 0;
  font-size: 15px;
}

#root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

h1 {
  text-align: center;
  color: #000;
  margin: 0;
  padding: 20px 0;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; /* Prevent title from shrinking */
}

.main-layout {
  display: flex;
  gap: 20px;
  flex-grow: 1; /* Allow layout to fill remaining space */
  overflow: hidden;
  padding: 20px;
  min-height: 0; /* Important for flex children scrolling */
}

.column {
  flex: 1;
  background: var(--component-bg);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
  overflow-y: auto; /* THIS IS THE KEY FOR SCROLLING */
  min-height: 0;
  min-width: 0; /* [ADDED] Critical fix for responsive overflow */
}

.column-content {
  padding: 20px;
}

.column.left-column {
  flex: 1.4;
}

.column h2 {
  font-size: 1.6em;
  margin: -20px -20px 20px -20px;
  padding: 20px 20px 15px 20px;
  text-align: center;
  color: #000;
  position: sticky;
  top: -21px; /* Adjust to hide top border */
  background: inherit;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
  border-radius: 12px 12px 0 0;
}

/* --- Left Column: Viz --- */
.diagram-component {
  border: 2px solid var(--border-color);
  border-radius: 10px;
  margin-bottom: 15px;
  background-color: #fdfdfd;
  transition: all 0.3s ease;
}
/* 新增：左侧组件激活时的样式 */
.diagram-component.active {
    border-color: var(--highlight-formula-border) !important;
    box-shadow: 0 0 30px var(--highlight-formula-bg) !important;
    transform: scale(1.01);
}

.component-header {
  background-color: var(--component-header-bg);
  padding: 8px 15px;
  font-weight: bold;
  font-size: 1.1em;
  border-bottom: 1px solid var(--border-color);
  border-radius: 8px 8px 0 0;
}
.component-body {
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  width: 100%; /* [ADDED] Critical fix for child element scrolling */
  box-sizing: border-box; /* Ensure padding is included in the width */
}

.arrow-down {
  width: 100%;
  text-align: center;
  font-size: 24px;
  color: var(--arrow-color);
  margin: 5px 0;
}

/* --- Matrix Styles --- */

.matrix-wrapper {
    position: relative;
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    vertical-align: middle; /* 改善在 flex 布局行中的对齐 */
}

.matrix-container {
  display: inline-block;
  border: 1px solid #ccc;
  padding: 5px;
  border-radius: 4px;
  background-color: #f9f9f9;
  position: relative;
}
.matrix-grid {
  display: grid;
  gap: 3px;
}

.matrix-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
  z-index: 2;
  font-weight: normal; /* 确保不加粗 */
}

/* [ADDED] Styling for ellipsis cell in matrix grid */
.matrix-ellipsis {
    width: 45px;
    height: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #aaa;
    font-size: 1.2em;
    font-family: monospace;
}


.matrix-element:hover {
  transform: scale(1.1);
  border-color: #007bff;
  box-shadow: 0 0 5px rgba(0,123,255,0.5);
  z-index: 5;
}

.matrix-element.source {
  background-color: var(--highlight-source-bg);
  color: var(--highlight-source-color);
  border: 1px solid var(--highlight-source-bg);
}
.matrix-element.target {
  background-color: var(--highlight-target-bg);
  color: var(--highlight-target-color);
  border: 1px solid var(--highlight-target-bg);
}

.matrix-element.destination {
  background-color: var(--highlight-formula-bg);
  border: 1px solid var(--highlight-formula-border);
}

.matrix-label-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}

.matrix-label {
  text-align: center;
  font-weight: bold;
  font-family: monospace;
  font-size: 1.1em;
  margin: 0;
}

.matrix-symbol-tag {
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    font-size: 1.1em;
    border: 1px solid #ced4da;
    line-height: 1;
    font-family: 'Times New Roman', serif;
}


.op-symbol {
    font-size: 2em;
    font-weight: bold;
    color: #909399;
}

/* --- Right Column: Explanation --- */
.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block.active {
  border-color: var(--highlight-formula-border) !important;
  box-shadow: 0 0 30px var(--highlight-bg) !important;
  transform: scale(1.01);
  background-color: var(--highlight-formula-bg);
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li, .math-block h5 {
    line-height: 1.7;
    margin: 1em 0;
}
.math-block h5 {
    font-size: 1.1em;
    margin-top: 1.5em;
    margin-bottom: 0.5em;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

.formula-display {
    display: flex;
    justify-content: flex-start; /* Aligned to left for better scroll */
    align-items: center;
    gap: 15px;
    overflow-x: auto; /* CRITICAL FIX: Allow horizontal scrolling */
    margin: 20px 0;
    padding: 15px 10px;
    background-color: rgba(0,0,0,0.02);
    border-radius: 8px;
}
.formula-display > * {
    flex-shrink: 0; /* CRITICAL FIX: Prevent items from shrinking */
}
.formula-display.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.formula-display.vertical .viz-formula-row {
    justify-content: flex-start;
}

.katex-display {
    margin: 0 !important;
}

.matrix-scroll-wrapper {
    overflow-x: auto;
    padding: 5px;
    flex-shrink: 0; /* Changed from 1 to 0 */
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Symbolic Matrix & Highlighting */
.symbolic-matrix-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.symbolic-matrix-grid {
    display: grid;
    gap: 2px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f9f9f9;
}
.symbolic-element, .symbolic-ellipsis {
    min-width: 60px;
    min-height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9em;
    border-radius: 2px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    transition: all 0.2s ease-in-out;
}
.symbolic-ellipsis {
    border-style: dashed;
    color: #aaa;
}
.symbolic-element.source {
  background-color: rgba(96, 98, 102, 0.1);
  border-color: var(--highlight-source-bg);
}
.symbolic-element.target {
  background-color: rgba(230, 57, 70, 0.1);
  border-color: var(--highlight-target-bg);
}
.symbolic-element.destination {
    background-color: var(--highlight-formula-bg);
    border-color: var(--highlight-formula-border);
}


/* Controls */
.controls-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 15px 20px;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  gap: 30px;
  flex-shrink: 0; /* Prevent controls from shrinking */
}
.control-group {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.control-group label {
  font-size: 0.9em;
  margin-bottom: 5px;
  color: #606266;
}
.control-group input {
  width: 60px;
  padding: 6px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  text-align: center;
  font-size: 1em;
}
.d_k-value {
    width: 60px;
    padding: 6px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: center;
    font-size: 1em;
    font-weight: bold;
    background-color: #f0f2f5;
}

/* [MODIFIED] Grouping and Scrolling Logic */
.viz-formula-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    overflow-x: auto;
    padding: 15px 10px;
    border: 1px solid #eef;
    border-radius: 8px;
    background-color: rgba(0,0,0,0.015);
    gap: 5px; /* Spacing between rows/arrows inside a group */
    box-sizing: border-box; /* Ensure padding is included in the width */
}
.viz-formula-group > * {
    flex-shrink: 0; /* Ensure content inside does not shrink */
}
.viz-formula-row {
    display: flex;
    align-items: center;
    gap: 15px;
    justify-content: center;
    width: auto; /* Let the row size to its content */
    padding: 0 5px; /* Remove vertical padding */
}
.viz-formula-row > * {
    flex-shrink: 0;
}


/* Styling for sub-steps in visualization components */
.viz-step-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #606266;
    margin-top: 10px;
    margin-bottom: 5px;
    font-size: 0.9em;
    border-bottom: 1px solid #eef;
    padding-bottom: 5px;
}
.viz-formula-group .viz-step-title {
    margin-top: -5px; /* Adjust margin when inside a group */
    margin-bottom: 10px;
}

/* Styling for Elementwise Operation Visualization */
.elementwise-op-container {
    width: 100%;
    padding: 10px;
    margin: 5px 0;
    border: 1px dashed #ccc;
    border-radius: 8px;
    background-color: #f8f9fa;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    box-sizing: border-box;
}
.elementwise-op-label {
    font-weight: bold;
    font-size: 1.1em;
}
.elementwise-op-viz {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    font-family: monospace;
    font-size: 1.2em;
    padding-bottom: 5px;
}
.elementwise-op-viz > * {
    flex-shrink: 0;
}
/* [ADDED] Wrapper for function call to keep items on one line */
.elementwise-op-function-call {
    display: flex;
    align-items: center;
    gap: 5px;
}

.elementwise-op-row {
    display: flex;
    gap: 5px;
    border: 1px solid #ddd;
    padding: 4px;
    border-radius: 4px;
    background: #fff;
    align-items: center;
}
.elementwise-op-element {
  /* Inherits from .matrix-element */
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
}
/* [ADDED] Style for ellipsis in elementwise op */
.elementwise-op-element.symbolic-ellipsis {
    border: none;
    background-color: transparent;
    color: #aaa;
    width: auto;
}

/* [NEW] Styles for ElementwiseCalculation */
.elementwise-calc-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: 100%;
    font-size: 0.9em;
}
.calc-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}
.calc-label {
    color: #555;
    font-size: 0.9em;
}
.elementwise-op-element.sum {
    width: auto;
    padding: 0 10px;
    font-weight: bold;
}
.elementwise-op-element.source, .elementwise-op-element.sum.source {
    background-color: var(--highlight-source-bg) !important;
    color: var(--highlight-source-color) !important;
    border-color: var(--highlight-source-bg) !important;
}
.elementwise-op-element.target, .elementwise-op-element.sum.target {
    background-color: var(--highlight-target-bg) !important;
    color: var(--highlight-target-color) !important;
    border-color: var(--highlight-target-bg) !important;
}

/* [NEW] Styles for Residual Block */
.residual-block {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px 10px;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #fcfcfc;
}
.residual-block:hover {
    border-color: var(--highlight-formula-border);
    background-color: var(--highlight-formula-bg);
}
.residual-icon {
    font-size: 1.6em;
    font-weight: bold;
    color: var(--arrow-color);
    line-height: 1;
}
.residual-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
}
.residual-matrix-symbol {
    font-size: 1.2em;
}
.residual-matrix-dims {
    font-size: 0.8em;
    color: #666;
    font-family: monospace;
}
.residual-block.active {
    border-color: var(--highlight-formula-border);
    border-style: solid;
    box-shadow: 0 0 15px var(--highlight-formula-bg);
    transform: scale(1.05);
}
.residual-block.active .residual-icon {
    color: var(--highlight-formula-border);
}

.add-norm-component-body {
    flex-direction: column; /* Changed for vertical layout */
}

.add-norm-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap; /* Allow wrapping on small screens */
}
/* END OF FILE: src/App.css */


================================================================================
### 文件路径: src/App.tsx
================================================================================

// FILE: src/App.tsx
import React, { useState, useCallback, useEffect } from 'react';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { useTransformer } from './hooks/useTransformer';
import { ElementIdentifier, HighlightSource, HighlightState, TransformerData } from './types';
import { MATRIX_NAMES } from './config/matrixNames';

// Helper to create backward highlight state
const createBackwardHighlight = (element: ElementIdentifier, transformerData: TransformerData, dims: any, currentHighlight: HighlightState): HighlightState => {
    const { name, row, col, isInternal } = element;
    let newSources: HighlightSource[] = [];
    let newTarget: ElementIdentifier | null = element;
    let activeComponent: string | null = null;
    let activeResidual: string | null = null;

    if (name.startsWith('residual.')) {
        const [, resId, type] = name.split('.');
        activeResidual = resId;
        const layerIdx = 0; // Simplified for this app
        const LN = MATRIX_NAMES.layer(layerIdx);
        if (resId === 'res1') {
            activeComponent = 'add_norm_1';
            newSources.push({ name: LN.encoder_input, row: -1, col: -1, highlightRow: true, highlightCol: true });
            newSources.push({ name: LN.mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true });
        } else if (resId === 'res2') {
            activeComponent = 'add_norm_2';
            newSources.push({ name: LN.add_norm_1_output, row: -1, col: -1, highlightRow: true, highlightCol: true });
            newSources.push({ name: LN.ffn_output, row: -1, col: -1, highlightRow: true, highlightCol: true });
        }
        return { target: null, sources: newSources, activeComponent, activeResidual };
    }

    const layerIdxMatch = name.match(/encoder\.(\d+)/);
    const layerIdx = layerIdxMatch ? parseInt(layerIdxMatch[1], 10) : 0;
    const headIdxMatch = name.match(/h(\d+)/);
    const headIdx = headIdxMatch ? parseInt(headIdxMatch[1], 10) : 0;

    const LN = MATRIX_NAMES.layer(layerIdx);
    const HN = MATRIX_NAMES.head(layerIdx, headIdx);

    // Component Activation Logic
    const baseName = isInternal ? name.replace('.internal', '') : name;
    if (Object.values(MATRIX_NAMES.head(layerIdx, headIdx)).includes(baseName) || baseName === LN.mha_output || baseName === LN.Wo || baseName === LN.encoder_input) {
        activeComponent = 'mha';
    } else if (baseName === MATRIX_NAMES.inputEmbeddings || baseName === MATRIX_NAMES.posEncodings || baseName === MATRIX_NAMES.encoderInput) {
        activeComponent = 'input_embed';
    } else if (baseName === LN.add_norm_1_output) {
        activeComponent = 'add_norm_1';
    } else if (baseName === LN.add_norm_2_output) {
        activeComponent = 'add_norm_2';
    } else if (Object.values(LN).includes(baseName) && (baseName.includes('.ffn.') || baseName.includes('add_norm_1_output'))) {
         activeComponent = 'ffn';
    }

     // Backward Tracing Logic
    if (isInternal) {
        newTarget = { name, row, col, isInternal: true };
        if (baseName === HN.AttentionWeights) {
            newSources.push({ name: HN.ScaledScores, row, col: -1, highlightRow: true });
            newSources.push({ name, row, col: -1, isInternal: true });
        } else if (baseName === LN.Activated) {
            newSources.push({ name: LN.Intermediate, row, col });
        }
    } else if (name === MATRIX_NAMES.encoderInput) {
        newSources.push({ name: MATRIX_NAMES.inputEmbeddings, row, col });
        newSources.push({ name: MATRIX_NAMES.posEncodings, row, col });
    } else if (name === LN.encoder_input) {
        newSources.push({ name: layerIdx > 0 ? MATRIX_NAMES.layer(layerIdx - 1).add_norm_2_output : MATRIX_NAMES.encoderInput, row, col });
    } else if (name === HN.Q || name === HN.K || name === HN.V) {
        const type = name.split('.').pop()!;
        newSources.push({ name: LN.encoder_input, row, col: -1, highlightRow: true });
        newSources.push({ name: HN[`W${type.toLowerCase()}` as 'Wq'|'Wk'|'Wv'], row: -1, col, highlightCol: true });
    } else if (name === HN.Scores) {
        newSources.push({ name: HN.Q, row, col: -1, highlightRow: true });
        newSources.push({ name: HN.K, row: col, col: -1, highlightRow: true });
    } else if (name === HN.ScaledScores) {
        newSources.push({ name: HN.Scores, row, col });
    } else if (name === HN.AttentionWeights) {
        newSources.push({ name: HN.ScaledScores, row, col: -1, highlightRow: true });
        newSources.push({ name: `${HN.AttentionWeights}.internal`, row, col, isInternal: true });
    } else if (name === HN.HeadOutput) {
        newSources.push({ name: HN.AttentionWeights, row, col: -1, highlightRow: true });
        newSources.push({ name: HN.V, row: -1, col, highlightCol: true });
    } else if (name === LN.mha_output) {
        for (let h = 0; h < dims.h; h++) {
            newSources.push({ name: MATRIX_NAMES.head(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true });
        }
        newSources.push({ name: LN.Wo, row: -1, col, highlightCol: true });
    } else if (name === LN.add_norm_1_output) {
        newSources.push({ name: LN.encoder_input, row, col: -1, highlightRow: true });
        newSources.push({ name: LN.mha_output, row, col: -1, highlightRow: true });
    } else if (name === LN.Intermediate || name === LN.Activated) {
        newSources.push({ name: LN.add_norm_1_output, row, col: -1, highlightRow: true });
        newSources.push({ name: LN.W1, row: -1, col, highlightCol: true });
        newSources.push({ name: LN.b1, row: 0, col });
        if (name === LN.Activated) {
             newSources.push({ name: `${LN.Activated}.internal`, row, col, isInternal: true });
        }
    } else if (name === LN.ffn_output) {
        newSources.push({ name: LN.Activated, row, col: -1, highlightRow: true });
        newSources.push({ name: LN.W2, row: -1, col, highlightCol: true });
        newSources.push({ name: LN.b2, row: 0, col });
    } else if (name === LN.add_norm_2_output) {
        newSources.push({ name: LN.add_norm_1_output, row, col: -1, highlightRow: true });
        newSources.push({ name: LN.ffn_output, row, col: -1, highlightRow: true });
    }

    return { target: newTarget, sources: newSources, activeComponent, activeResidual };
};

// Helper to create forward highlight state
const createForwardHighlight = (element: ElementIdentifier, transformerData: TransformerData, dims: any): HighlightState => {
    const { name, row, col } = element;
    let newDestinations: HighlightSource[] = [];
    let newSources: HighlightSource[] = [{...element}];
    let activeComponent: string | null = null;

    const layerIdxMatch = name.match(/encoder\.(\d+)/);
    const layerIdx = layerIdxMatch ? parseInt(layerIdxMatch[1], 10) : 0;
    const headIdxMatch = name.match(/h(\d+)/);
    const headIdx = headIdxMatch ? parseInt(headIdxMatch[1], 10) : 0;

    const LN = MATRIX_NAMES.layer(layerIdx);
    const HN = MATRIX_NAMES.head(layerIdx, headIdx);

    // Forward Tracing Logic
    if (name === MATRIX_NAMES.inputEmbeddings || name === MATRIX_NAMES.posEncodings) {
        newDestinations.push({ name: MATRIX_NAMES.encoderInput, row, col });
        activeComponent = 'input_embed';
    } else if (name === MATRIX_NAMES.encoderInput) {
        newDestinations.push({ name: LN.encoder_input, row, col });
        activeComponent = 'input_embed';
    } else if (name === LN.encoder_input) {
        newDestinations.push({ name: HN.Q, row, col: -1, highlightRow: true });
        newDestinations.push({ name: HN.K, row, col: -1, highlightRow: true });
        newDestinations.push({ name: HN.V, row, col: -1, highlightRow: true });
        newDestinations.push({ name: LN.add_norm_1_output, row, col });
        activeComponent = 'mha';
    } else if (name === HN.Q) {
        newDestinations.push({ name: HN.Scores, row, col: -1, highlightRow: true });
        activeComponent = 'mha';
    } else if (name === HN.K) {
        newDestinations.push({ name: HN.Scores, row: -1, col: row, highlightCol: true });
        activeComponent = 'mha';
    } else if (name === HN.V) {
        newDestinations.push({ name: HN.HeadOutput, row: -1, col, highlightCol: true });
        activeComponent = 'mha';
    }
    // ... and so on for all other matrices

    return { target: element, sources: [], destinations: newDestinations, activeComponent, activeResidual: null };
};


function App() {
  const [dims, setDims] = useState({
      d_model: 8,
      h: 2,
      seq_len: 3,
      n_layers: 1,
      d_ff: 32
  });
  const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [], activeComponent: null, activeResidual: null });

  const transformerData: TransformerData | null = useTransformer(dims);

  useEffect(() => {
    if (highlight.activeComponent) {
      const explanationEl = document.getElementById(`math_${highlight.activeComponent}`);
      if (explanationEl) {
          setTimeout(() => {
              explanationEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
      }
    }
  }, [highlight.activeComponent]);

  const handleElementClick = useCallback((element: ElementIdentifier) => {
      if (!transformerData) return;
      setHighlight(createBackwardHighlight(element, transformerData, dims, highlight));
  }, [transformerData, dims, highlight]);

  const handleSymbolClick = useCallback((element: ElementIdentifier) => {
    if (!transformerData) return;
    setHighlight(createForwardHighlight(element, transformerData, dims));
  }, [transformerData, dims]);

  if (!transformerData) {
      return <div>正在加载或维度设置无效... (d_model 必须能被 h 整除)</div>
  }

  return (
    <div className="app-container">
      <h1>终极 Transformer 深度探索器 (编码器篇)</h1>
      <Controls dims={dims} setDims={setDims} />
      <div className="main-layout">
        <div className="column left-column">
          <div className="column-content">
              <h2>模型结构与数据流</h2>
              <Viz
                data={transformerData}
                highlight={highlight}
                onElementClick={handleElementClick}
              />
          </div>
        </div>
        <div className="column right-column">
           <div className="column-content">
              <h2>数学原理</h2>
              <Explanation
                dims={dims}
                highlight={highlight}
                onSymbolClick={handleSymbolClick}
              />
           </div>
        </div>
      </div>
    </div>
  );
}

export default App

// END OF FILE: src/App.tsx


================================================================================
### 文件路径: src/index.tsx
================================================================================

/* START OF FILE: src/index.tsx */
// FILE: src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
// END OF FILE: src/index.tsx
/* END OF FILE: src/index.tsx */


================================================================================
### 文件路径: src/styles.css
================================================================================

/* START OF FILE: src/styles.css */

/* END OF FILE: src/styles.css */


================================================================================
### 文件路径: src/types.ts
================================================================================

// FILE: src/types.ts
export type Matrix = number[][];
export type Vector = number[];

export interface ElementIdentifier {
  name: string; // e.g., "encoder.0.mha.h0.Q" or "residual.res1.start"
  row: number;
  col: number;
  isInternal?: boolean; // True if it's part of an internal calculation visualization
  matrixSymbol?: string; // e.g., "Z"
  matrixDims?: string; // e.g., "3x8"
}

export interface HighlightSource extends ElementIdentifier {
  highlightRow?: boolean;
  highlightCol?: boolean;
}

export interface HighlightState {
  activeComponent: string | null; // e.g., "mha", "ffn"
  activeResidual: string | null; // e.g., "res1"
  target: ElementIdentifier | null;
  sources: HighlightSource[];
  destinations?: HighlightSource[]; // For forward tracing
}

export interface AttentionHeadData {
  Wq: Matrix;
  Wk: Matrix;
  Wv: Matrix;
  Q: Matrix;
  K: Matrix;
  V: Matrix;
  Scores: Matrix;
  ScaledScores: Matrix;
  AttentionWeights: Matrix;
  HeadOutput: Matrix;
}

export interface MultiHeadAttentionData {
    heads: AttentionHeadData[];
    Wo: Matrix;
    output: Matrix;
}

export interface FFNData {
    W1: Matrix;
    b1: Vector; // bias is part of FFN data
    Intermediate: Matrix;
    Activated: Matrix;
    W2: Matrix;
    b2: Vector; // bias is part of FFN data
    Output: Matrix;
}

export interface EncoderLayerData {
    encoder_input: Matrix;
    mha: MultiHeadAttentionData;
    mha_output: Matrix;

    add_norm_1_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;

    add_norm_2_output: Matrix;
}

export interface TransformerData {
    inputEmbeddings: Matrix;
    posEncodings: Matrix;
    encoderInput: Matrix;
    encoderLayers: EncoderLayerData[];
}
// END OF FILE: src/types.ts


================================================================================
### 文件路径: src/components/AddNorm.tsx
================================================================================

// FILE: src/components/AddNorm.tsx
import React from 'react';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { ResidualBlock } from './ResidualBlock';

interface AddNormProps {
    inputSublayer: MatrixType;
    output: MatrixType;
    sublayerMatrixName: string;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
    activeId: 'add_norm_1' | 'add_norm_2';
    residualId: string; // e.g., "res1"
    residualMatrixSymbol: string;
    residualMatrixDims: string;
}

export const AddNorm: React.FC<AddNormProps> = ({
    inputSublayer,
    output,
    sublayerMatrixName,
    outputMatrixName,
    highlight,
    onElementClick,
    activeId,
    residualId,
    residualMatrixSymbol,
    residualMatrixDims,
}) => {
    const isActive = highlight.activeComponent === activeId;

    return (
         <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Add & LayerNorm</div>
            <div className="component-body add-norm-component-body">
                <div className="add-norm-inputs">
                    <ResidualBlock
                        id={residualId}
                        type="end"
                        highlight={highlight}
                        onElementClick={onElementClick}
                        matrixSymbol={residualMatrixSymbol}
                        matrixDims={residualMatrixDims}
                    />
                    <div className="op-symbol">+</div>
                    <Matrix name={sublayerMatrixName} data={inputSublayer} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down"><InlineMath math="\xrightarrow{\text{LayerNorm}}" /></div>

                <Matrix name={outputMatrixName} data={output} highlight={highlight} onElementClick={onElementClick} />
            </div>
        </div>
    );
};
// END OF FILE: src/components/AddNorm.tsx


================================================================================
### 文件路径: src/components/Controls.tsx
================================================================================

/* START OF FILE: src/components/Controls.tsx */
// FILE: src/components/Controls.tsx
import React from 'react';

interface ControlsProps {
  dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
  setDims: (dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number }) => void;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims }) => {

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    let newDims = { ...dims, [id]: parseInt(value, 10) || 1 };

    // Ensure d_model is divisible by h
    if (id === 'h') {
        if (newDims.d_model % newDims.h !== 0) {
             newDims.d_model = Math.max(newDims.h, Math.ceil(newDims.d_model / newDims.h) * newDims.h);
        }
    }
    if (id === 'd_model') {
         if (newDims.d_model % newDims.h !== 0) {
             let best_h = 1;
             for (let i = 1; i <= newDims.d_model; i++) {
                 if (newDims.d_model % i === 0) {
                    if (Math.abs(i - newDims.h) < Math.abs(best_h - newDims.h)) {
                       best_h = i;
                    }
                 }
             }
             newDims.h = best_h;
         }
    }

    // Ensure d_ff is a multiple of d_model
    if(id === 'd_model') {
        newDims.d_ff = newDims.d_model * 4;
    }

    setDims(newDims);
  };

  const d_k = dims.d_model % dims.h === 0 ? dims.d_model / dims.h : 'N/A';

  return (
    <div className="controls-container">
      <div className="control-group">
        <label htmlFor="seq_len">序列长度 (seq_len)</label>
        <input type="number" id="seq_len" value={dims.seq_len} onChange={handleInputChange} min="2" max="5" />
      </div>
      <div className="control-group">
        <label htmlFor="d_model">模型维度 (d_model)</label>
        <input type="number" id="d_model" value={dims.d_model} onChange={handleInputChange} step={1} min={2} max="16"/>
      </div>
      <div className="control-group">
        <label htmlFor="h">注意力头数 (h)</label>
        <input type="number" id="h" value={dims.h} onChange={handleInputChange} min="1" max={dims.d_model}/>
      </div>
      <div className="control-group">
        <label htmlFor="n_layers">层数 (N)</label>
        <input type="number" id="n_layers" value={dims.n_layers} onChange={handleInputChange} min="1" max="3"/>
      </div>
       <div className="control-group">
        <label>键/查询维度 (d_k)</label>
        <div className="d_k-value">{d_k}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Controls.tsx
/* END OF FILE: src/components/Controls.tsx */


================================================================================
### 文件路径: src/components/DecoderLayer.tsx
================================================================================

/* START OF FILE: src/components/DecoderLayer.tsx */
// FILE: src/components/DecoderLayer.tsx
// This file is intentionally left blank for this version,
// as the focus is on a complete and correct Encoder implementation.
export {};
// END OF FILE: src/components/DecoderLayer.tsx
/* END OF FILE: src/components/DecoderLayer.tsx */


================================================================================
### 文件路径: src/components/Element.tsx
================================================================================

// FILE: src/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col && !highlight.target.isInternal;

  const isSource = highlight.sources.some(s => {
    if (s.name !== name || s.isInternal) return false;
    if (s.highlightRow) return s.row === row;
    if (s.highlightCol) return s.col === col;
    return s.row === row && s.col === col;
  });

  const isDestination = highlight.destinations?.some(d => {
    if (d.name !== name || d.isInternal) return false;
    if (d.highlightRow) return d.row === row;
    if (d.highlightCol) return d.col === col;
    return d.row === row && d.col === col;
  });

  const className = `matrix-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''} ${isDestination ? 'destination' : ''}`;

  const handleClick = () => {
    onElementClick({ name, row, col });
  };

  return (
    <div className={className} onClick={handleClick}>
      {value.toFixed(2)}
    </div>
  );
});
// END OF FILE: src/components/Element.tsx


================================================================================
### 文件路径: src/components/ElementwiseCalculation.tsx
================================================================================

// FILE: src/components/ElementwiseCalculation.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier, HighlightState } from '../types';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface ElementwiseCalculationProps {
  opType: 'softmax' | 'relu';
  inputRow: number[];
  outputRow: number[];
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
  baseName: string; // e.g., "encoder.0.mha.h0.AttentionWeights"
  rowIndex: number;
}

const formatNumber = (num: number, precision = 2) => num.toFixed(precision);

export const ElementwiseCalculation: React.FC<ElementwiseCalculationProps> = ({
  opType,
  inputRow,
  outputRow,
  highlight,
  onElementClick,
  baseName,
  rowIndex,
}) => {
  const targetCol = highlight.target?.isInternal && highlight.target.row === rowIndex ? highlight.target.col : -1;
  const visibleCols = getVisibleIndices(inputRow.length, targetCol);

  const handleClick = (colIndex: number) => {
    onElementClick({
      name: `${baseName}.internal`, // Special name for internal calculation
      row: rowIndex,
      col: colIndex,
      isInternal: true,
    });
  };

  const isSource = (colIndex: number) => {
      return highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === colIndex);
  }
  const isTarget = (colIndex: number) => {
      return highlight.target?.isInternal && highlight.target.row === rowIndex && highlight.target.col === colIndex;
  }


  const renderVisibleElements = (data: (number | string)[], type: 'input' | 'output' | 'exp' | 'sum') => {
    return visibleCols.map((col, i) => {
      if (col === ELLIPSIS) {
        return <div key={`ellipsis-${i}`} className="elementwise-op-element symbolic-ellipsis">...</div>;
      }
      const value = data[col];
      const className = `elementwise-op-element ${isSource(col) ? 'source' : ''} ${isTarget(col) ? 'target' : ''}`;
      return (
        <div key={`${type}-${col}`} className={className} onClick={() => handleClick(col)}>
          {typeof value === 'number' ? formatNumber(value) : value}
        </div>
      );
    });
  };

  const renderSoftmax = () => {
    const maxVal = Math.max(...inputRow);
    const exps = inputRow.map(val => Math.exp(val - maxVal));
    const sumExps = exps.reduce((a, b) => a + b, 0);

    const fullSumIsSource = highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === -1); // -1 indicates whole row/sum

    return (
      <>
        {/* Step 1: exp(x - max(x)) */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(x_i - \text{max}(\mathbf{x}))" /></div>
          <div className="elementwise-op-row">
            {renderVisibleElements(exps.map(v => Number(formatNumber(v, 4))), 'exp')}
          </div>
        </div>
        {/* Step 2: Sum */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\sum \text{exp}(\dots)" /></div>
          <div className={`elementwise-op-element sum ${fullSumIsSource ? 'source' : ''}`} onClick={() => handleClick(-1)}>
            {formatNumber(sumExps, 4)}
          </div>
        </div>
        {/* Step 3: Division */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(\dots) / \sum" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };

  const renderReLU = () => {
    return (
      <>
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{max}(0, x_i)" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };


  return (
    <div className="elementwise-calc-container">
        {opType === 'softmax' ? renderSoftmax() : renderReLU()}
    </div>
  );
};
// END OF FILE: src/components/ElementwiseCalculation.tsx


================================================================================
### 文件路径: src/components/ElementwiseOperation.tsx
================================================================================

// FILE: src/components/ElementwiseOperation.tsx
import React from 'react';
import { Matrix, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseCalculation } from './ElementwiseCalculation';

interface ElementwiseOperationProps {
    opType: 'softmax' | 'relu';
    inputMatrix: Matrix;
    outputMatrix: Matrix;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
    layerIndex: number; // [NEW] Explicitly pass layerIndex
    headIndex?: number; // [NEW] Optional headIndex for MHA
}

const getInputMatrixName = (opType: 'softmax' | 'relu', layerIndex: number, headIndex?: number) => {
    if (opType === 'softmax') {
        return MATRIX_NAMES.head(layerIndex, headIndex ?? 0).ScaledScores;
    }
    return MATRIX_NAMES.layer(layerIndex).Intermediate;
};

export const ElementwiseOperation: React.FC<ElementwiseOperationProps> = ({
    opType,
    inputMatrix,
    outputMatrix,
    outputMatrixName,
    highlight,
    onElementClick,
    layerIndex,
    headIndex,
}) => {
    const relevantInputName = getInputMatrixName(opType, layerIndex, headIndex);
    let targetRowIndex = 0;

    if (highlight.target) {
        if (highlight.target.name === relevantInputName || highlight.target.name === outputMatrixName) {
            targetRowIndex = highlight.target.row;
        } else if (highlight.target.isInternal && highlight.target.name.startsWith(outputMatrixName)) {
            targetRowIndex = highlight.target.row;
        }
    }

    const inputRow = inputMatrix[targetRowIndex] || [];
    const outputRow = outputMatrix[targetRowIndex] || [];

    const opName = opType.charAt(0).toUpperCase() + opType.slice(1);
    const opFunction = opType === 'relu' ? 'max(0, x)' : 'softmax(x_i)';

    return (
        <div className="elementwise-op-container">
            <div className="elementwise-op-label">
                <InlineMath math={`\\text{Detailed Calculation: } ${opName}(x_i) = ${opFunction}`} />
            </div>
            <p style={{margin: '0', fontSize: '0.8em', color: '#666'}}>* Showing calculation for Row {targetRowIndex}</p>
            <ElementwiseCalculation
                opType={opType}
                inputRow={inputRow}
                outputRow={outputRow}
                highlight={highlight}
                onElementClick={onElementClick}
                baseName={outputMatrixName}
                rowIndex={targetRowIndex}
            />
        </div>
    );
};
// END OF FILE: src/components/ElementwiseOperation.tsx


================================================================================
### 文件路径: src/components/EncoderLayer.tsx
================================================================================

// FILE: src/components/EncoderLayer.tsx
import React from 'react';
import { EncoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { MultiHeadAttention } from './MultiHeadAttention';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../config/symbolMapping';
import { Matrix } from './Matrix';

interface EncoderLayerProps {
  layerIndex: number;
  data: EncoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const EncoderLayer: React.FC<EncoderLayerProps> = ({ layerIndex, data, highlight, onElementClick }) => {
  const baseName = `encoder.${layerIndex}`;
  const LN = MATRIX_NAMES.layer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.encoder_input);
  const dimsRes1 = `${data.encoder_input.length}x${data.encoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  return (
    <div className="encoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#e3f2fd', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#e3f2fd'}}>编码器层 (Encoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- MHA Sub-layer with Residual Connection --- */}
                <Matrix name={LN.encoder_input} data={data.encoder_input} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id="res1" type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MultiHeadAttention
                    baseName={`${baseName}.mha`}
                    data={data.mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
                <AddNorm
                    inputSublayer={data.mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_1"
                    residualId="res1"
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />

                {/* --- FFN Sub-layer with Residual Connection --- */}
                <div className="arrow-down">↓</div>
                <Matrix name={LN.add_norm_1_output} data={data.add_norm_1_output} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id="res2" type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_1_output}
                    inputName={LN.add_norm_1_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
                <AddNorm
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_2"
                    residualId="res2"
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />

            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/EncoderLayer.tsx


================================================================================
### 文件路径: src/components/Explanation.tsx
================================================================================

// FILE: src/components/Explanation.tsx
import React from 'react';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import { InteractiveSymbolicVector } from './InteractiveSymbolicVector';
import { HighlightState, ElementIdentifier } from '../types';
import { MATRIX_NAMES } from '../config/matrixNames';

interface ExplanationProps {
    dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier) => void;
}

interface MathBlockProps {
    id: string;
    title: string;
    children: React.ReactNode;
    highlight: HighlightState;
}

const MathBlock: React.FC<MathBlockProps> = ({ id, title, children, highlight }) => {
    const isActive = highlight.activeComponent === id;
    return (
        <div id={`math_${id}`} className={`math-block ${isActive ? 'active' : ''}`}>
            <h3>{title}</h3>
            {children}
        </div>
    );
};

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight, onSymbolClick }) => {
    const LN = MATRIX_NAMES.layer(0);
    const HN = MATRIX_NAMES.head(0, 0);
    const d_k = dims.d_model / dims.h;

    const shouldBreakAddNorm = dims.d_model > 15 || dims.d_model * 2 > 15;

    return (
        <div>
            <div className="math-block">
                <h3>Transformer 架构概览</h3>
                <p>Transformer 模型由两个核心部分组成：<b>编码器 (Encoder)</b> 和 <b>解码器 (Decoder)</b>。编码器的任务是“理解”输入的整个句子（例如，"I am a student"），并将其转化为一组富含上下文信息的数字表示。解码器的任务是利用这些数字表示，并结合已经生成的内容，一次一个词地生成目标句子（例如，“我 是 一个 学生”）。</p>
                <p>在2017年的原始论文《Attention Is All You Need》中，编码器和解码器都由 N=6 个相同的层堆叠而成。<b>此可视化工具将聚焦于编码器部分</b>，带您深入探索其内部的数据流动和数学原理。</p>
            </div>

             <MathBlock id="input_embed" title="第1步：输入预处理" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将输入的文本序列（一串文字）转换为模型可以处理的、包含“词义”和“位置”信息的数值向量矩阵。我们以一个长度为 {dims.seq_len} 的序列为例，当前模型维度 <InlineMath math={`d_{model}=${dims.d_model}`}/>。</p>

                <h5>计算流程</h5>
                <ol>
                    <li><b>词嵌入 (Token Embedding):</b> 首先，通过一个大型的、可学习的嵌入表（相当于一个巨大的“词典”），将每个词元（Token）的ID转换为一个稠密的向量。结果是一个矩阵，每一行代表一个词的初始含义。</li>
                    <li><b>位置编码 (Positional Encoding):</b> Transformer没有循环结构，无法感知词的顺序。因此，我们创建另一个同样大小的位置编码矩阵。该矩阵根据固定的 <InlineMath math="\sin"/> 和 <InlineMath math="\cos"/> 函数生成，为模型注入关于序列顺序的绝对位置信息。</li>
                    <li><b>逐元素相加:</b> 最后，将上述两个矩阵逐元素相加，得到编码器最终的输入表示 <InlineMath math="Z"/>。这个矩阵的每一行，都既包含了词的语义，也包含了它在句子中的位置信息。</li>
                </ol>

                <p>位置编码计算公式: 矩阵中每一项 <InlineMath math="PE_{(pos, i)}"/> 的值都由其位置 <code>pos</code> 和维度索引 <code>i</code> 决定：</p>
                <BlockMath math={`
                PE_{(pos, i)} =
                \\begin{cases}
                    \\sin(pos / 10000^{i/d_{\\text{model}}}), & \\text{if } i \\text{ is even} \\\\
                    \\cos(pos / 10000^{(i-1)/d_{\\text{model}}}), & \\text{if } i \\text{ is odd}
                \\end{cases}
                `} />
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.inputEmbeddings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.posEncodings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    {shouldBreakAddNorm && <BlockMath math="=" />}
                    {!shouldBreakAddNorm && <BlockMath math="=" />}
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.encoderInput} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
             </MathBlock>

             <MathBlock id="mha" title="编码器子层1：多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此机制的核心目的是计算句子中每个词与其他所有词的“关注度”或“相关性”，并根据这个关注度重新计算每个词的向量表示，从而让每个词的向量都融入其上下文信息。</p>
                <h5>设计思路</h5>
                <p>传统的单头注意力虽然能捕捉输入元素间的关系，但只能在单一的表示空间中进行。这限制了模型在处理复杂信息时（如同时关注语法结构和语义关系）的能力。多头注意力（MHA）通过将注意力计算分解到多个并行的“头”来解决这个问题。每个头在输入的不同表示子空间中学习注意力权重，使得模型能同时从不同位置、不同方面关注信息，就像让 {dims.h} 个“专家”从不同角度去审视和理解句子。</p>

                <h5>1. 生成 Q, K, V 向量</h5>
                <p>输入矩阵 <InlineMath math="Z"/> 被并行地送入 {dims.h} 个独立的注意力头。每个头都拥有三块自己专属、可学习的权重矩阵。通过矩阵乘法，将输入 <InlineMath math="Z"/> 投影到三个新的矩阵：查询 (Query, <InlineMath math="Q"/>), 键 (Key, <InlineMath math="K"/>), 和 值 (Value, <InlineMath math="V"/>)。</p>
                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.Q} rows={dims.seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.K} rows={dims.seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.V} rows={dims.seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>

                <h5>2. 计算注意力分数</h5>
                <p>通过将 Query 矩阵与转置后的 Key 矩阵相乘，我们得到一个注意力分数矩阵 <InlineMath math="S"/>。该矩阵中的每个元素 <InlineMath math="S_{r,c}"/> 代表输入序列中第 <code>r</code> 个词（查询方）对第 <code>c</code> 个词（被查询方）的关注度原始分数。</p>
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.Q} rows={dims.seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.K} rows={dims.seq_len} cols={d_k} highlight={highlight} transpose={true} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.Scores} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>

                <h5>3. 缩放与Softmax</h5>
                <p>为防止梯度在反向传播时过小，将分数矩阵 <InlineMath math="S"/> 中的所有元素都除以一个缩放因子 <InlineMath math={`\\sqrt{d_k}`}/>。然后，对缩放后的分数矩阵<b>逐行</b>应用 Softmax 函数，将其转换为总和为1的概率分布。这就是最终的注意力权重矩阵 <InlineMath math="A"/>。</p>
                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.Scores} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math={`\\xrightarrow{/\\sqrt{d_k}}`} />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.ScaledScores} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math={`\\xrightarrow{\\text{softmax}}`} />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.AttentionWeights} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>

                <h5>4. 加权求和</h5>
                <p>最后，将权重矩阵 <InlineMath math="A"/> 与 Value 矩阵 <InlineMath math="V"/> 相乘，得到该注意力头的最终输出 <InlineMath math="H"/>。这个过程本质上是对 <InlineMath math="V"/> 中的所有词向量进行加权求和，权重就是刚算出来的注意力分数。关注度越高的词，其V向量在最终结果中的占比就越大。</p>
                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.AttentionWeights} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.V} rows={dims.seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HN.HeadOutput} rows={dims.seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>

                <h5>5. 拼接与最终投影</h5>
                <p>所有 {dims.h} 个头的输出矩阵 (<InlineMath math={`H_0, H_1, \\dots, H_{${dims.h-1}}`}/>) 在特征维度上被拼接（Concatenate）在一起，形成一个大的矩阵 <InlineMath math="H_{cat}"/>。然后，这个拼接后的矩阵通过一个最终的线性层（权重 <InlineMath math="W^O"/>）进行融合与降维，得到该多头注意力块的最终输出 <InlineMath math="M"/>。</p>
                 <BlockMath math={`H_{cat} = \\text{Concat}(H_0, H_1, \\dots, H_{${dims.h-1}})`} />
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.concatOutput(0)} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.Wo} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.mha_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
             </MathBlock>

             <MathBlock id="add_norm_1" title="组件：残差连接与层归一化 (1)" highlight={highlight}>
                <p>在每个子层（如多头注意力、前馈网络）之后，都会跟随一个“Add & Norm”模块。它包含两个关键步骤，旨在改善深度网络的训练过程并增强信息流动。</p>
                <h5>步骤 1: 残差连接 (Add)</h5>
                <p>此步骤的目的是将子层的<b>输入</b>信息与<b>输出</b>信息直接相加。这创建了一条“捷径”（Shortcut/Residual Connection），使得梯度在反向传播时可以更容易地流过深层网络，有效缓解梯度消失问题，也保证了模型不会因为增加了一层而效果变差。</p>
                <BlockMath math={`Z_{add} = Z_{in} + \\text{Sublayer}(Z_{in})`} />

                <h5>步骤 2: 层归一化 (Layer Normalization)</h5>
                <p>此步骤旨在稳定训练过程，降低模型对权重初始化的敏感度。它独立地对每个样本（即矩阵的每一行）的特征向量进行归一化处理。对于 <InlineMath math="Z_{add}"/> 的每一行向量 <InlineMath math="\mathbf{z}"/>：</p>
                <ol>
                    <li><b>计算均值 (<InlineMath math="\mu"/>) 和方差 (<InlineMath math="\sigma^2"/>):</b> 计算该行向量内所有元素的均值与方差。</li>
                    <li><b>归一化:</b> 将向量变为均值为0，方差为1的标准分布。</li>
                    <BlockMath math={`\\mathbf{\\hat{z}} = \\frac{\\mathbf{z} - \\mu}{\\sqrt{\\sigma^2 + \\epsilon}}`} />
                    <li><b>缩放与平移:</b> 引入两个可学习的参数向量 <InlineMath math="\gamma"/> (gamma) 和 <InlineMath math="\beta"/> (beta)，来恢复模型的表达能力，因为强制归一化可能会限制模型的性能。其中 <InlineMath math="\odot"/> 代表逐元素乘法。</li>
                    <BlockMath math={`\\mathbf{z}_{out} = \\gamma \odot \\mathbf{\\hat{z}} + \\beta`} />
                </ol>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.mha_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
             </MathBlock>

              <MathBlock id="ffn" title="编码器子层2：位置前馈网络" highlight={highlight}>
                <h5>做什么？</h5>
                <p>在注意力层捕捉了上下文关系之后，前馈网络 (FFN) 对每个位置的向量独立地进行一次复杂的非线性变换。这极大地增加了模型的表达能力，使其能够学习更复杂的特征组合。</p>
                <h5>设计思路</h5>
                <p>注意力层本身的计算（加权求和）是线性的，为了让模型能够学习更复杂的函数，需要在每个注意力层之后引入非线性变换。FFN 就是这个非线性组件。它独立地、相同地应用于序列中的每一个位置（即每一个词元向量），为其增加了模型的“深度”和表达能力，可以看作是在特征维度上进行深度加工。</p>

                <h5>1. 第一次线性变换 (维度扩展)</h5>
                <p>输入矩阵 <InlineMath math="Z'"/> 首先会经过一个线性层，将其维度从 <InlineMath math={`d_{model}=${dims.d_model}`}/> 扩展到一个更大的中间维度 <InlineMath math={`d_{ff}=${dims.d_ff}`}/>。这个“升维”操作为模型提供了更大的空间来学习和组合特征。然后加上偏置项，并通过ReLU激活函数引入非线性。</p>
                <BlockMath math={`H_{act} = \\text{ReLU}(Z' W_1 + b_1)`} />
                <div className="formula-display vertical">
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                    <BlockMath math="\times"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                    <BlockMath math="+"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LN.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.Activated} rows={dims.seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                </div>

                <h5>2. 第二次线性变换 (维度投影)</h5>
                <p>最后，将经过激活函数处理的矩阵再通过第二个线性层，将其从中间维度 <InlineMath math={`d_{ff}`}/> 投影回原始的模型维度 <InlineMath math={`d_{model}`}/>，并加上第二个偏置项，得到FFN层的最终输出。这个“降维”操作将学习到的复杂特征整合回模型的主干维度中。</p>
                <BlockMath math={`F = H_{act} W_2 + b_2`} />
                <div className="formula-display vertical">
                     <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.Activated} rows={dims.seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                    <BlockMath math="\times"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.W2} rows={dims.d_ff} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                    <BlockMath math="+"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LN.b2} data={Array(dims.d_model).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                    <BlockMath math="="/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.ffn_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    </div>
                </div>
             </MathBlock>

             <MathBlock id="add_norm_2" title="组件：残差连接与层归一化 (2)" highlight={highlight}>
                <p>与第一个 "Add & Norm" 层完全相同，此步骤将 FFN 子层的输出信息与该子层的输入信息直接结合，然后进行层归一化，产生该编码器层的最终输出。</p>
                <p>这个输出可以被送入下一个编码器层进行更深层次的特征提取，或者（如果这是最后一层）被送入解码器的每一个“编码器-解码器注意力”子层中，作为指导翻译生成的上下文信息。</p>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.ffn_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LN.add_norm_2_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
             </MathBlock>
        </div>
    );
};
// END OF FILE: src/components/Explanation.tsx


================================================================================
### 文件路径: src/components/FeedForward.tsx
================================================================================

// FILE: src/components/FeedForward.tsx
import React from 'react';
import { FFNData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface FFNProps {
    baseName: string;
    input: MatrixType;
    inputName: string;
    data: FFNData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const FeedForward: React.FC<FFNProps> = ({ baseName, input, inputName, data, highlight, onElementClick }) => {
    const isActive = highlight.activeComponent === 'ffn';
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const LN = MATRIX_NAMES.layer(layerIndex);

    // --- Layout Breaking Logic ---
    const inputCols1 = input[0]?.length || 0;
    const w1Cols = data.W1[0]?.length || 0;
    const breakStep1 = inputCols1 > 15 || w1Cols > 15 || (inputCols1 + w1Cols > 15);

    const activatedCols = data.Activated[0]?.length || 0;
    const w2Cols = data.W2[0]?.length || 0;
    const breakStep2 = activatedCols > 15 || w2Cols > 15 || (activatedCols + w2Cols > 15);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Feed-Forward Network</div>
            <div className="component-body">
                <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">1. First Linear Layer & ReLU</div>
                    {breakStep1 ? (
                        <>
                            <div className="viz-formula-row">
                                 <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                 <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                             <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                             <span className="op-symbol">×</span>
                             <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b1} data={[data.b1]} highlight={highlight} onElementClick={onElementClick} />
                    </div>

                    <ElementwiseOperation
                        opType="relu"
                        inputMatrix={data.Intermediate}
                        outputMatrix={data.Activated}
                        outputMatrixName={LN.Activated}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Second Linear Layer</div>
                    {breakStep2 ? (
                        <>
                            <div className="viz-formula-row">
                                 <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                 <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                            <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                            <span className="op-symbol">×</span>
                            <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b2} data={[data.b2]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LN.ffn_output} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/FeedForward.tsx


================================================================================
### 文件路径: src/components/InteractiveSymbolicElement.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicElement.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier } from '../types';

interface InteractiveSymbolicElementProps {
  base: string;
  subscript?: string;
  row?: number;
  col?: number;
  isTarget?: boolean;
  isSource?: boolean;
  isDestination?: boolean;
  onClick: () => void;
}

export const InteractiveSymbolicElement: React.FC<InteractiveSymbolicElementProps> = React.memo(({ base, subscript, row, col, isTarget, isSource, isDestination, onClick }) => {
  const elementBase = base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
  const subscriptContent = [subscript, row, col].filter(s => s !== undefined && s !== null).join(',');
  const mathString = `${elementBase}_{${subscriptContent}}`;

  const className = `symbolic-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''} ${isDestination ? 'destination' : ''}`;

  return (
    <div className={className} onClick={onClick} style={{cursor: 'pointer'}}>
      <InlineMath math={mathString} />
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicElement.tsx


================================================================================
### 文件路径: src/components/InteractiveSymbolicMatrix.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicMatrix.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicMatrixProps {
  name: string;
  rows: number;
  cols: number;
  highlight: HighlightState;
  transpose?: boolean;
  onSymbolClick: (element: ElementIdentifier) => void;
}

export const InteractiveSymbolicMatrix: React.FC<InteractiveSymbolicMatrixProps> = React.memo(({ name, rows, cols, highlight, transpose = false, onSymbolClick }) => {
  const displayRows = transpose ? cols : rows;
  const displayCols = transpose ? rows : cols;
  const symbol = getSymbolParts(name);

  let focusRow = -1;
  let focusCol = -1;

  if (highlight.target?.name === name) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const highlightedTarget = (highlight.target?.name === name) ? highlight.target : null;
  const highlightedSources = highlight.sources.filter(s => s.name === name);
  const highlightedDestinations = highlight.destinations?.filter(d => d.name === name) || [];

  const visibleRowIndices = getVisibleIndices(displayRows, transpose ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, transpose ? focusRow : focusCol);


  const gridElements = visibleRowIndices.map((r, rIdx) => {
    if (r === ELLIPSIS) {
        return visibleColIndices.map((c, cIdx) => (
             <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>
        ));
    }
    return visibleColIndices.map((c, cIdx) => {
        if (c === ELLIPSIS) {
            return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
        }

        const originalRow = transpose ? c : r;
        const originalCol = transpose ? r : c;

        const isTarget = !!highlightedTarget && highlightedTarget.row === originalRow && highlightedTarget.col === originalCol;

        const isSource = highlightedSources.some(s => {
          if (s.highlightRow) return s.row === originalRow;
          if (s.highlightCol) return s.col === originalCol;
          return s.row === originalRow && s.col === originalCol;
        });

        const isDestination = highlightedDestinations.some(d => {
            if (d.highlightRow) return d.row === originalRow;
            if (d.highlightCol) return d.col === originalCol;
            return d.row === originalRow && d.col === originalCol;
        });

        return (
            <InteractiveSymbolicElement
                key={`elem-r${r}-c${c}`}
                base={symbol.base}
                subscript={symbol.subscript}
                row={originalRow}
                col={originalCol}
                isTarget={isTarget}
                isSource={isSource}
                isDestination={isDestination}
                onClick={() => onSymbolClick({ name, row: originalRow, col: originalCol })}
            />
        );
    });
  });

  let mathSymbol = symbol.base;
  if (symbol.superscript) mathSymbol += `^{${symbol.superscript}}`;
  if (transpose) mathSymbol += '^T';

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`${rows} \\times ${cols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;

  return (
    <div className="symbolic-matrix-container">
      <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
      <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${visibleColIndices.length}, auto)` }}>
        {gridElements}
      </div>
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicMatrix.tsx


================================================================================
### 文件路径: src/components/InteractiveSymbolicVector.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicVector.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { Vector as VectorType } from '../types';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicVectorProps {
  name: string;
  data: VectorType;
  highlight: HighlightState;
  onSymbolClick: (element: ElementIdentifier) => void;
}

export const InteractiveSymbolicVector: React.FC<InteractiveSymbolicVectorProps> = React.memo(({ name, data, highlight, onSymbolClick }) => {
  const displayCols = data.length;
  const symbol = getSymbolParts(name);

  let focusCol = -1;
  if (highlight.target?.name === name) {
    focusCol = highlight.target.col;
  }
  const highlightedSources = highlight.sources.filter(s => s.name === name);
  const highlightedDestinations = highlight.destinations?.filter(d => d.name === name) || [];

  const visibleColIndices = getVisibleIndices(displayCols, focusCol);

  const gridElements = visibleColIndices.map((c, cIdx) => {
    if (c === ELLIPSIS) {
        return <div key={`ellipsis-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
    }

    const isTarget = highlight.target?.name === name && highlight.target.col === c;
    const isSource = highlightedSources.some(s => s.col === c);
    const isDestination = highlightedDestinations.some(d => d.col === c);

    return (
        <InteractiveSymbolicElement
            key={`elem-${c}`}
            base={symbol.base}
            subscript={symbol.subscript}
            col={c}
            isTarget={isTarget}
            isSource={isSource}
            isDestination={isDestination}
            onClick={() => onSymbolClick({ name, row: 0, col: c })}
        />
    );
  });

  let mathSymbol = symbol.base;

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`1 \\times ${displayCols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;


  return (
    <div className="symbolic-matrix-container">
      <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
      <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${gridElements.length}, auto)` }}>
        {gridElements}
      </div>
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicVector.tsx


================================================================================
### 文件路径: src/components/Matrix.tsx
================================================================================

// FILE: src/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
  isTransposed?: boolean;
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, isTransposed = false }) => {
  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const numRows = data.length;
  const numCols = data[0].length;

  const displayRows = isTransposed ? numCols : numRows;
  const displayCols = isTransposed ? numRows : numCols;

  let focusRow = -1;
  let focusCol = -1;

  if(highlight.target?.name === name && !highlight.target.isInternal) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const relevantSource = highlight.sources.find(s => s.name === name && !s.isInternal);
  if (relevantSource) {
      focusRow = relevantSource.row === -1 ? focusRow : relevantSource.row;
      focusCol = relevantSource.col === -1 ? focusCol : relevantSource.col;
  }

  const relevantDestination = highlight.destinations?.find(d => d.name === name && !d.isInternal);
    if (relevantDestination) {
        focusRow = relevantDestination.row === -1 ? focusRow : relevantDestination.row;
        focusCol = relevantDestination.col === -1 ? focusCol : relevantDestination.col;
    }


  const visibleRowIndices = getVisibleIndices(displayRows, isTransposed ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, isTransposed ? focusRow : focusCol);

  const gridTemplateColumns = `repeat(${visibleColIndices.length}, auto)`;

  const symbolParts = getSymbolParts(name);
  let mathSymbol = symbolParts.base;
  if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
  if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;
  if(isTransposed) mathSymbol = `${mathSymbol}^T`;

  const gridElements = visibleRowIndices.map((r, rIdx) => {
    if (r === ELLIPSIS) {
        return visibleColIndices.map((c, cIdx) => (
             <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>
        ));
    }
    return visibleColIndices.map((c, cIdx) => {
        if (c === ELLIPSIS) {
            return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">…</div>;
        }
        const displayRow = r;
        const displayCol = c;
        const originalRow = isTransposed ? displayCol : displayRow;
        const originalCol = isTransposed ? displayRow : displayCol;
        const value = data[originalRow][originalCol];
        return (
             <Element
              key={`${name}-${originalRow}-${originalCol}`}
              name={name}
              row={originalRow}
              col={originalCol}
              value={value}
              highlight={highlight}
              onElementClick={onElementClick}
            />
        )
    });
  });


  return (
    <div className="matrix-wrapper">
      <div className="matrix-container">
        <div className="matrix-grid" style={{ gridTemplateColumns }}>
          {gridElements}
        </div>
      </div>
      <div className="matrix-label-container">
        <div className="matrix-symbol-tag"><InlineMath>{mathSymbol}</InlineMath></div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Matrix.tsx


================================================================================
### 文件路径: src/components/MultiHeadAttention.tsx
================================================================================

// FILE: src/components/MultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface MHAProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const MultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick }) => {
    const headData = data.heads[0];
    const headBaseName = `${baseName}.h0`;
    const isActive = highlight.activeComponent === 'mha';

    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Visualizing head 0
    const LN = MATRIX_NAMES.layer(layerIndex);
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        // First head
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.head(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);

        if (numHeads > 2) {
             // Middle ellipsis
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            // Last head
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.head(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            // Second head
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.head(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };


    // --- Layout Breaking Logic ---
    const wqCols = headData.Wq[0]?.length || 0;
    const qCols = headData.Q[0]?.length || 0;
    const breakQ = wqCols > 15 || qCols > 15 || (wqCols + qCols > 15);

    const wkCols = headData.Wk[0]?.length || 0;
    const kCols = headData.K[0]?.length || 0;
    const breakK = wkCols > 15 || kCols > 15 || (wkCols + kCols > 15);

    const wvCols = headData.Wv[0]?.length || 0;
    const vCols = headData.V[0]?.length || 0;
    const breakV = wvCols > 15 || vCols > 15 || (wvCols + vCols > 15);

    const kTransposedCols = headData.K.length;
    const breakScores = qCols > 15 || kTransposedCols > 15 || (qCols + kTransposedCols > 15);

    const attnWeightsCols = headData.AttentionWeights[0]?.length || 0;
    const breakHeadOutput = attnWeightsCols > 15 || vCols > 15 || (attnWeightsCols + vCols > 15);


    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Multi-Head Attention</div>
            <div className="component-body">
                <p>Input (from previous layer)</p>
                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                    {breakQ ? (
                        <>
                            <div className="viz-formula-row">
                               <span>(Input) ×</span>
                               <Matrix name={`${headBaseName}.Wq`} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="arrow-down">=</div>
                            <div className="viz-formula-row">
                               <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                           <span>(Input) ×</span>
                           <Matrix name={`${headBaseName}.Wq`} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                           <span>=</span>
                           <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                     {breakK ? (
                        <>
                             <div className="viz-formula-row">
                               <span>(Input) ×</span>
                               <Matrix name={`${headBaseName}.Wk`} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="arrow-down">=</div>
                            <div className="viz-formula-row">
                               <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                           <span>(Input) ×</span>
                           <Matrix name={`${headBaseName}.Wk`} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                            <span>=</span>
                           <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                     {breakV ? (
                        <>
                            <div className="viz-formula-row">
                               <span>(Input) ×</span>
                               <Matrix name={`${headBaseName}.Wv`} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="arrow-down">=</div>
                            <div className="viz-formula-row">
                               <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                           <span>(Input) ×</span>
                           <Matrix name={`${headBaseName}.Wv`} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                            <span>=</span>
                           <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    {breakScores ? (
                        <>
                             <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                            </div>
                        </>
                    ) : (
                         <div className="viz-formula-row">
                            <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                            <InlineMath math="\times" />
                            <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                        </div>
                    )}
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.Scores`} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.ScaledScores`} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={`${headBaseName}.AttentionWeights`}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    {breakHeadOutput ? (
                        <>
                            <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                            <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                            <InlineMath math="\times" />
                            <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.HeadOutput`} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                    <div className="viz-formula-row">
                       <InlineMath math="\text{Concat}(" />
                        {renderConcatHeads()}
                       <InlineMath math=")" />
                     </div>

                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={`${baseName}.Wo`} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={LN.mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/MultiHeadAttention.tsx


================================================================================
### 文件路径: src/components/ResidualBlock.tsx
================================================================================

// FILE: src/components/ResidualBlock.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';
import { InlineMath } from 'react-katex';

interface ResidualBlockProps {
  id: string; // e.g., "res1"
  type: 'start' | 'end';
  matrixSymbol: string;
  matrixDims: string;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const ResidualBlock: React.FC<ResidualBlockProps> = ({ id, type, matrixSymbol, matrixDims, highlight, onElementClick }) => {
  const isActive = highlight.activeResidual === id;
  const isStart = type === 'start';
  const icon = isStart ? '↓' : '→';

  const handleClick = () => {
    onElementClick({
      name: `residual.${id}.${type}`,
      row: -1,
      col: -1,
      matrixSymbol,
      matrixDims,
    });
  };

  return (
    <div
      className={`residual-block ${isActive ? 'active' : ''}`}
      onClick={handleClick}
      title={`Residual Connection (${matrixSymbol})`}
    >
      <div className="residual-icon">{icon}</div>
      <div className="residual-info">
          <div className="residual-matrix-symbol"><InlineMath math={matrixSymbol} /></div>
          <div className="residual-matrix-dims">{matrixDims}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/ResidualBlock.tsx


================================================================================
### 文件路径: src/components/Viz.tsx
================================================================================

// FILE: src/components/Viz.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EncoderLayer } from './EncoderLayer';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface VizProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const Viz: React.FC<VizProps> = ({ data, highlight, onElementClick }) => {
    const isInputEmbedActive = highlight.activeComponent === 'input_embed';

    const cols = data.inputEmbeddings[0]?.length || 0;
    const shouldBreak = cols > 15; // Here we only need to check one since they are the same size.

    return (
        <div>
            {/* Input Embedding & Positional Encoding 组件高亮 */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header">Input Embedding & Positional Encoding</div>
                <div className="component-body">
                    {shouldBreak ? (
                         <>
                            <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                            <div className="op-symbol">+</div>
                            <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                         </>
                    ) : (
                        <div className="viz-formula-row">
                             <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                             <div className="op-symbol">+</div>
                             <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                </div>
            </div>

            <div className="arrow-down">↓</div>

            {/* Encoder Input 组件高亮 */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header">Encoder Input (<InlineMath math="Z_0" />)</div>
                <div className="component-body">
                     <Matrix name="encoderInput" data={data.encoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.encoderLayers.map((layer, i) => (
                <EncoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
            ))}
        </div>
    );
};
// END OF FILE: src/components/Viz.tsx


================================================================================
### 文件路径: src/config/matrixNames.ts
================================================================================

// FILE: src/config/matrixNames.ts
// This file is the single source of truth for all matrix and vector names.

export const MATRIX_NAMES = {
    // Input
    inputEmbeddings: 'inputEmbeddings',
    posEncodings: 'posEncodings',
    encoderInput: 'encoderInput',

    // Layer-specific names (functions to generate names for a specific layer)
    layer: (layerIndex: number) => ({
        // Inputs
        encoder_input: `encoder.${layerIndex}.encoder_input`,

        // MHA
        mha_output: `encoder.${layerIndex}.mha.output`,
        Wo: `encoder.${layerIndex}.mha.Wo`,

        // Add & Norm 1
        add_norm_1_output: `encoder.${layerIndex}.add_norm_1_output`,

        // FFN
        W1: `encoder.${layerIndex}.ffn.W1`,
        b1: `encoder.${layerIndex}.ffn.b1`,
        Intermediate: `encoder.${layerIndex}.ffn.Intermediate`,
        Activated: `encoder.${layerIndex}.ffn.Activated`,
        W2: `encoder.${layerIndex}.ffn.W2`,
        b2: `encoder.${layerIndex}.ffn.b2`,
        ffn_output: `encoder.${layerIndex}.ffn.output`,

        // Add & Norm 2
        add_norm_2_output: `encoder.${layerIndex}.add_norm_2_output`,
    }),

    // Head-specific names
    head: (layerIndex: number, headIndex: number) => ({
        Wq: `encoder.${layerIndex}.mha.h${headIndex}.Wq`,
        Wk: `encoder.${layerIndex}.mha.h${headIndex}.Wk`,
        Wv: `encoder.${layerIndex}.mha.h${headIndex}.Wv`,
        Q: `encoder.${layerIndex}.mha.h${headIndex}.Q`,
        K: `encoder.${layerIndex}.mha.h${headIndex}.K`,
        V: `encoder.${layerIndex}.mha.h${headIndex}.V`,
        Scores: `encoder.${layerIndex}.mha.h${headIndex}.Scores`,
        ScaledScores: `encoder.${layerIndex}.mha.h${headIndex}.ScaledScores`,
        AttentionWeights: `encoder.${layerIndex}.mha.h${headIndex}.AttentionWeights`,
        HeadOutput: `encoder.${layerIndex}.mha.h${headIndex}.HeadOutput`,
    }),

    // A conceptual name for the concatenated heads, used only in explanations
    concatOutput: (layerIndex: number) => `encoder.${layerIndex}.mha.ConcatOutput`,
};

// END OF FILE: src/config/matrixNames.ts


================================================================================
### 文件路径: src/config/symbolMapping.ts
================================================================================

// FILE: src/config/symbolMapping.ts

// This file is the single source of truth for mapping a matrix's unique name
// to its mathematical symbol parts for consistent rendering.

interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

const SYMBOL_CONFIG: { [key: string]: SymbolParts } = {
    // Input
    inputEmbeddings: { base: 'E' },
    posEncodings: { base: 'PE' },
    encoderInput: { base: 'Z' },
    encoder_input: { base: 'Z' }, // Alias for layers

    // MHA Weights
    Wq: { base: 'W', superscript: 'Q' },
    Wk: { base: 'W', superscript: 'K' },
    Wv: { base: 'W', superscript: 'V' },
    Wo: { base: 'W', superscript: 'O' },

    // MHA Tensors
    Q: { base: 'Q' },
    K: { base: 'K' },
    V: { base: 'V' },
    Scores: { base: 'S' },
    ScaledScores: { base: "S'" },
    AttentionWeights: { base: 'A' },
    HeadOutput: { base: 'H' },
    ConcatOutput: { base: 'H', subscript: 'cat'},
    output: { base: 'M' }, // Corresponds to MHA output
    mha_output: { base: 'M' },


    // Add & Norm
    add_norm_1_output: { base: "Z'" },
    add_norm_2_output: { base: "Z''" },

    // FFN
    W1: { base: 'W', subscript: '1' },
    b1: { base: 'b', subscript: '1' },
    Intermediate: { base: 'H', subscript: 'ffn' },
    Activated: { base: 'H', subscript: 'act' },
    W2: { base: 'W', subscript: '2' },
    b2: { base: 'b', subscript: '2' },
    ffn_output: { base: 'F' },
};

/**
 * Gets the consistent mathematical symbol parts for a given matrix name.
 * @param name The full, unique name of the matrix (e.g., "encoder.0.add_norm_1_output").
 * @returns An object with base, superscript, and subscript parts.
 */
export const getSymbolParts = (name: string): SymbolParts => {
    const conceptualName = name.split('.').pop() || '';
    return SYMBOL_CONFIG[conceptualName] || { base: 'X' }; // Default to 'X' if not found
};
// END OF FILE: src/config/symbolMapping.ts


================================================================================
### 文件路径: src/hooks/useTransformer.ts
================================================================================

// FILE: src/hooks/useTransformer.ts
import { useMemo } from 'react';
import { Matrix, TransformerData, EncoderLayerData, FFNData, MultiHeadAttentionData, AttentionHeadData, Vector } from '../types';

// --- Utility Functions ---

const createRandomMatrix = (rows: number, cols: number): Matrix => {
  return Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)))
  );
};

const createRandomVector = (size: number): Vector => {
  return Array.from({ length: size }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)));
}

const addMatrices = (A: Matrix, B: Matrix): Matrix => {
  return A.map((row, i) =>
    row.map((val, j) => parseFloat((val + B[i][j]).toFixed(2)))
  );
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
  const rowsA = A.length;
  const colsA = A[0].length;
  const colsB = B[0].length;
  const result: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));

  for (let i = 0; i < rowsA; i++) {
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      result[i][j] = parseFloat(sum.toFixed(2));
    }
  }
  return result;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => {
    return A.map(row => row.map(val => parseFloat((val / scalar).toFixed(2))));
}

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row);
        const exps = row.map(val => Math.exp(val - maxVal));
        const sumExps = exps.reduce((a, b) => a + b, 0);
        return exps.map(exp => parseFloat((exp / sumExps).toFixed(2)));
    });
}

const layerNorm = (A: Matrix): Matrix => {
    return A.map(row => {
        const mean = row.reduce((a,b) => a+b, 0) / row.length;
        const variance = row.map(x => (x - mean) ** 2).reduce((a,b) => a+b,0) / row.length;
        const std = Math.sqrt(variance + 1e-5);
        return row.map(x => parseFloat(((x - mean) / std).toFixed(2)));
    });
}

const applyReLU = (A: Matrix): Matrix => {
    return A.map(row => row.map(val => Math.max(0, val)));
}

const addBias = (A: Matrix, b: Vector): Matrix => {
    return A.map(row => row.map((val, j) => parseFloat((val + b[j]).toFixed(2))));
}

// --- Main Hook ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number;
    n_layers: number;
    d_ff: number;
}

export const useTransformer = (dims: Dims): TransformerData | null => {

  return useMemo(() => {
    try {
        const { d_model, h, seq_len, n_layers, d_ff } = dims;
        if (d_model % h !== 0) return null;
        const d_k = d_model / h;

        const inputEmbeddings = createRandomMatrix(seq_len, d_model);
        const posEncodings: Matrix = Array.from({ length: seq_len }, (_, pos) =>
          Array.from({ length: d_model }, (_, i) =>
            parseFloat((i % 2 === 0
              ? Math.sin(pos / (10000 ** (i / d_model)))
              : Math.cos(pos / (10000 ** ((i - 1) / d_model)))).toFixed(2))
          )
        );
        const encoderInput = addMatrices(inputEmbeddings, posEncodings);

        let currentInput = encoderInput;
        const encoderLayers: EncoderLayerData[] = [];

        for (let i = 0; i < n_layers; i++) {
            const encoder_input = currentInput;

            // MHA
            const heads: AttentionHeadData[] = [];
            const headOutputs: Matrix[] = [];
            for(let j=0; j < h; j++) {
                const Wq = createRandomMatrix(d_model, d_k);
                const Wk = createRandomMatrix(d_model, d_k);
                const Wv = createRandomMatrix(d_model, d_k);

                const Q = multiplyMatrices(encoder_input, Wq);
                const K = multiplyMatrices(encoder_input, Wk);
                const V = multiplyMatrices(encoder_input, Wv);

                const K_T: Matrix = Array.from({ length: d_k }, (_, r) => Array.from({ length: seq_len }, (_, c) => K[c][r]));
                const Scores = multiplyMatrices(Q, K_T);

                const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
                const AttentionWeights = softmaxByRow(ScaledScores);
                const HeadOutput = multiplyMatrices(AttentionWeights, V);

                heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
                headOutputs.push(HeadOutput);
            }
            const ConcatOutput = headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(seq_len).fill(0).map(() => []));
            const Wo = createRandomMatrix(d_model, d_model);
            const mha_output = multiplyMatrices(ConcatOutput, Wo);
            const mha: MultiHeadAttentionData = { heads, Wo, output: mha_output };

            const add_norm_1_sum = addMatrices(encoder_input, mha_output);
            const add_norm_1_output = layerNorm(add_norm_1_sum);

            const W1 = createRandomMatrix(d_model, d_ff);
            const b1 = createRandomVector(d_ff);
            const Intermediate = addBias(multiplyMatrices(add_norm_1_output, W1), b1);
            const Activated = applyReLU(Intermediate);
            const W2 = createRandomMatrix(d_ff, d_model);
            const b2 = createRandomVector(d_model);
            const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
            const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };

            const add_norm_2_sum = addMatrices(add_norm_1_output, ffn_output);
            const add_norm_2_output = layerNorm(add_norm_2_sum);

            encoderLayers.push({
                encoder_input,
                mha,
                mha_output,
                add_norm_1_output,
                ffn,
                ffn_output,
                add_norm_2_output
            });

            currentInput = add_norm_2_output;
        }

        return {
            inputEmbeddings,
            posEncodings,
            encoderInput,
            encoderLayers
        };
    } catch (e) {
        console.error("Error during transformer calculation:", e);
        return null;
    }
  }, [dims]);
};
// END OF FILE: src/hooks/useTransformer.ts


================================================================================
### 文件路径: src/utils/matrixView.ts
================================================================================

// FILE: src/utils/matrixView.ts
export const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12; // e.g., 4 + 3 + 4 + 1 ellipsis = 12

/**
 * Calculates the visible indices for a row or column of a matrix based on a focus point.
 * It always shows the first and last `alwaysShowCount` items.
 * It shows a `windowSize` around the `focusIndex`.
 *
 * @param totalSize - The total number of items (rows or columns).
 * @param focusIndex - The index of the focused item, or -1 if no focus.
 * @param alwaysShowCount - The number of items to always show at the beginning and end.
 * @param windowSize - The size of the focus window around the focusIndex.
 * @returns An array of indices to display, with ELLIPSIS string for gaps.
 */
export const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {

  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }

  const visible = new Set<number>();

  // 1. Add always-visible indices
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }

  // 2. Add focus window indices
  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }

  // 3. Build the final array with ellipses for gaps
  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];

  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }

  return result;
};
// END OF FILE: src/utils/matrixView.ts


================================================================================
### 文件路径: public/index.html
================================================================================

<!-- START OF FILE: public/index.html -->
<!--# FILE: public/index.html-->

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>终极 Transformer 深度探索器</title>
    <!-- 引入 MathJax 用于渲染 LaTeX 公式 -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

<!--# END OF FILE: public/index.html-->


