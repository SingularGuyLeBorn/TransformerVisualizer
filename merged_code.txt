================================================================================
### 文件路径: src/App.css
================================================================================

/*// FILE: src/App.css*/
:root {
  --highlight-color: #c0392b;
  --highlight-bg: rgba(192, 57, 43, 0.08);
  --border-color: #dcdfe6;
  --bg-color: #f5f7fa;
  --text-color: #303133;
  --arrow-color: #888;
  --component-bg: #ffffff;
  --component-header-bg: #f8f9fa;
  --residual-bg: #f0f4c3;
  --residual-border: #dce775;

  /* Highlighting */
  /* [MODIFIED] Changed to softer, semi-transparent colors for better aesthetics */
  --highlight-target-bg: rgba(230, 57, 70, 0.15);
  --highlight-target-color: #d63031;
  --highlight-target-border: #e63946;
  --highlight-source-bg: rgba(96, 98, 102, 0.1);
  --highlight-source-color: #2f3542;
  --highlight-source-border: #606266;

  --highlight-formula-bg: rgba(252, 163, 17, 0.15);
  --highlight-formula-border: #fca311;
  --highlight-vector-bg: rgba(69, 123, 157, 0.2);
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  background-color: var(--bg-color);
  color: var(--text-color);
  margin: 0;
  font-size: 15px;
}

#root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

h1 {
  text-align: center;
  color: #000;
  margin: 0;
  padding: 20px 0;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; /* Prevent title from shrinking */
}

.main-layout {
  display: flex;
  gap: 20px;
  flex-grow: 1; /* Allow layout to fill remaining space */
  overflow: hidden;
  padding: 20px;
  min-height: 0; /* Important for flex children scrolling */
  position: relative; /* [ADDED] Needed for positioning the tooltip */
}

.column {
  flex: 1;
  background: var(--component-bg);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
  overflow-y: auto; /* THIS IS THE KEY FOR SCROLLING */
  min-height: 0;
  min-width: 0; /* [ADDED] Critical fix for responsive overflow */
}

.column-content {
  padding: 20px;
}

.column.left-column {
  flex: 1.4;
}

.column h2 {
  font-size: 1.6em;
  margin: -20px -20px 20px -20px;
  padding: 20px 20px 15px 20px;
  text-align: center;
  color: #000;
  position: sticky;
  top: -21px; /* Adjust to hide top border */
  background: inherit;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
  border-radius: 12px 12px 0 0;
}

/* --- Left Column: Viz --- */
.diagram-component {
  border: 2px solid var(--border-color);
  border-radius: 10px;
  margin-bottom: 15px;
  background-color: #fdfdfd;
  transition: all 0.3s ease;
}
/* [MODIFIED] Style for component click-to-scroll */
.diagram-component .component-header {
    cursor: pointer;
    transition: background-color 0.3s ease;
}
.diagram-component .component-header:hover {
    background-color: #f0f2f5;
}
.diagram-component.active {
    border-color: var(--highlight-formula-border) !important;
    box-shadow: 0 0 30px var(--highlight-formula-bg) !important;
    transform: scale(1.01);
}

.component-header {
  background-color: var(--component-header-bg);
  padding: 8px 15px;
  font-weight: bold;
  font-size: 1.1em;
  border-bottom: 1px solid var(--border-color);
  border-radius: 8px 8px 0 0;
}
.component-body {
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  width: 100%; /* [ADDED] Critical fix for child element scrolling */
  box-sizing: border-box; /* Ensure padding is included in the width */
}

.arrow-down {
  width: 100%;
  text-align: center;
  font-size: 24px;
  color: var(--arrow-color);
  margin: 5px 0;
}

/* --- Matrix Styles --- */

.matrix-wrapper {
    position: relative;
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    vertical-align: middle; /* 改善在 flex 布局行中的对齐 */
}

.matrix-container {
  display: inline-block;
  border: 1px solid #ccc;
  padding: 5px;
  border-radius: 4px;
  background-color: #f9f9f9;
}
.matrix-grid {
  display: grid;
  gap: 3px;
}

.matrix-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
  z-index: 2;
  font-weight: normal; /* 确保不加粗 */
}

/* [ADDED] Styling for ellipsis cell in matrix grid */
.matrix-ellipsis {
    width: 45px;
    height: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #aaa;
    font-size: 1.2em;
    font-family: monospace;
}


.matrix-element:hover {
  transform: scale(1.1);
  border-color: #007bff;
  box-shadow: 0 0 5px rgba(0,123,255,0.5);
  z-index: 5;
}

/* [MODIFIED] Updated highlighting styles */
.matrix-element.source {
  background-color: var(--highlight-source-bg);
  color: var(--highlight-source-color);
  border: 1.5px solid var(--highlight-source-border);
}
.matrix-element.target {
  background-color: var(--highlight-target-bg);
  color: var(--highlight-target-color);
  border: 1.5px solid var(--highlight-target-border);
}

/* [NEW] Style for highlighting the max probability in a row */
.matrix-element.prob-max {
    box-shadow: 0 0 8px 2px var(--highlight-target-border);
    font-weight: bold;
    transform: scale(1.15);
    z-index: 6;
}

.matrix-element.destination {
  background-color: var(--highlight-formula-bg);
  border: 1px solid var(--highlight-formula-border);
}

.matrix-label-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}

.matrix-label {
  text-align: center;
  font-weight: bold;
  font-family: monospace;
  font-size: 1.1em;
  margin: 0;
}

.matrix-symbol-tag {
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    font-size: 1.1em;
    border: 1px solid #ced4da;
    line-height: 1;
    font-family: 'Times New Roman', serif;
}


.op-symbol {
    font-size: 2em;
    font-weight: bold;
    color: #909399;
    align-self: center; /* [ADDED] Better alignment in flex */
}

/* [REMOVED] Old absolute positioned header styles */
/*
.matrix-col-headers { ... }
.matrix-row-headers { ... }
*/

/* [MODIFIED] Styles for Matrix Index Headers integrated into the grid */
.matrix-header-item {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5;
    color: #909399;
    font-family: monospace;
    font-size: 0.8em;
    font-weight: bold;
    border-radius: 2px;
    padding: 2px;
    box-sizing: border-box;
    min-height: 15px; /* For column headers */
}

.symbolic-header-item {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: transparent;
    color: #909399;
    font-family: monospace;
    font-size: 0.8em;
    font-weight: bold;
}


/* --- Right Column: Explanation --- */
.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block.active {
  border-color: var(--highlight-formula-border) !important;
  box-shadow: 0 0 30px var(--highlight-bg) !important;
  transform: scale(1.01);
  background-color: var(--highlight-formula-bg);
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li, .math-block h5 {
    line-height: 1.7;
    margin: 1em 0;
}
.math-block h5 {
    font-size: 1.1em;
    margin-top: 1.5em;
    margin-bottom: 0.5em;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

.formula-display {
    display: flex;
    justify-content: flex-start; /* Aligned to left for better scroll */
    align-items: center;
    gap: 15px;
    overflow-x: auto; /* CRITICAL FIX: Allow horizontal scrolling */
    margin: 20px 0;
    padding: 15px 10px;
    background-color: rgba(0,0,0,0.02);
    border-radius: 8px;
    flex-wrap: wrap; /* [MODIFIED] Allow wrapping by default */
}
.formula-display > * {
    flex-shrink: 0; /* CRITICAL FIX: Prevent items from shrinking */
}
.formula-display.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.formula-display.vertical .viz-formula-row {
    justify-content: flex-start;
}

.katex-display {
    margin: 0 !important;
}

.matrix-scroll-wrapper {
    overflow-x: auto;
    padding: 5px;
    flex-shrink: 0; /* Changed from 1 to 0 */
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Symbolic Matrix & Highlighting */
.symbolic-matrix-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.symbolic-matrix-grid {
    display: grid;
    gap: 2px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f9f9f9;
}
.symbolic-element, .symbolic-ellipsis {
    min-width: 60px;
    min-height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9em;
    border-radius: 2px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    transition: all 0.2s ease-in-out;
}
.symbolic-ellipsis {
    border-style: dashed;
    color: #aaa;
}
.symbolic-element.source {
  background-color: var(--highlight-source-bg);
  border-color: var(--highlight-source-border);
}
.symbolic-element.target {
  background-color: var(--highlight-target-bg);
  border-color: var(--highlight-target-border);
}
.symbolic-element.destination {
    background-color: var(--highlight-formula-bg);
    border-color: var(--highlight-formula-border);
}


/* Controls */
.controls-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 15px 20px;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  gap: 20px; /* Reduced gap */
  flex-wrap: wrap; /* Allow wrapping */
  flex-shrink: 0;
}
.control-group {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.control-group label {
  font-size: 0.9em;
  margin-bottom: 5px;
  color: #606266;
}
.control-group input[type="number"] {
  width: 60px;
  padding: 6px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  text-align: center;
  font-size: 1em;
}
.control-group input[type="text"] {
    width: 250px;
    padding: 6px 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 1em;
}

.d_k-value {
    width: 60px;
    padding: 6px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: center;
    font-size: 1em;
    font-weight: bold;
    background-color: #f0f2f5;
}

/* [MODIFIED] Fixed Controls Panel in top-right */
.controls-panel {
    position: fixed; /* Changed from absolute to fixed */
    top: 85px; /* Position below main title */
    right: 20px;
    z-index: 100;
    background: var(--component-bg);
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid var(--border-color);
    overflow: hidden;
    transition: width 0.3s ease-in-out, height 0.3s ease-in-out;
    max-width: 90vw;
}
.controls-panel-header {
    /* No longer draggable */
    background-color: var(--component-header-bg);
}
.controls-panel-header:active {
    /* No longer draggable */
    cursor: default;
}
.controls-panel.collapsed {
    width: 50px;
    height: 50px;
    padding: 0;
}
.controls-toggle-btn {
    width: 100%;
    height: 100%;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 24px;
    color: var(--text-color);
    transition: transform 0.3s ease;
}
.controls-panel.collapsed .controls-toggle-btn {
    transform: rotate(45deg);
}
.controls-panel:not(.collapsed) .controls-toggle-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 30px;
    height: 30px;
    font-size: 20px;
}
.controls-panel .controls-container {
    border-bottom: none;
    padding: 20px;
    padding-top: 40px;
    transition: opacity 0.3s ease;
}
.controls-panel.collapsed .controls-container {
    opacity: 0;
    pointer-events: none;
}


/* [MODIFIED] Grouping and Scrolling Logic */
.viz-formula-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%; /* Use 100% to enable internal scrolling */
    max-width: 100%; /* Prevent overflow from parent */
    overflow-x: auto;
    padding: 15px 10px;
    border: 1px solid #eef;
    border-radius: 8px;
    background-color: rgba(0,0,0,0.015);
    gap: 5px; /* Spacing between rows/arrows inside a group */
    box-sizing: border-box; /* Ensure padding is included in the width */
}
.viz-formula-group > * {
    flex-shrink: 0; /* Ensure content inside does not shrink */
}
.viz-formula-row {
    display: flex;
    align-items: center;
    gap: 15px;
    justify-content: center;
    width: max-content; /* Let the row size to its content */
    padding: 0 5px; /* Remove vertical padding */
    flex-wrap: nowrap; /* [MODIFIED] Default to no-wrap */
}
.viz-formula-row.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.viz-formula-row > * {
    flex-shrink: 0;
}


/* Styling for sub-steps in visualization components */
.viz-step-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #606266;
    margin-top: 10px;
    margin-bottom: 5px;
    font-size: 0.9em;
    border-bottom: 1px solid #eef;
    padding-bottom: 5px;
}
.viz-formula-group .viz-step-title {
    margin-top: -5px; /* Adjust margin when inside a group */
    margin-bottom: 10px;
}

/* Styling for Elementwise Operation Visualization */
.elementwise-op-container {
    width: 100%;
    padding: 10px;
    margin: 5px 0;
    border: 1px dashed #ccc;
    border-radius: 8px;
    background-color: #f8f9fa;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    box-sizing: border-box;
}
.elementwise-op-label {
    font-weight: bold;
    font-size: 1.1em;
}
.elementwise-op-viz {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    font-family: monospace;
    font-size: 1.2em;
    padding-bottom: 5px;
}
.elementwise-op-viz > * {
    flex-shrink: 0;
}
/* [ADDED] Wrapper for function call to keep items on one line */
.elementwise-op-function-call {
    display: flex;
    align-items: center;
    gap: 5px;
}

.elementwise-op-row {
    display: flex;
    gap: 5px;
    border: 1px solid #ddd;
    padding: 4px;
    border-radius: 4px;
    background: #fff;
    align-items: center;
}
.elementwise-op-element {
  /* Inherits from .matrix-element */
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
}
/* [ADDED] Style for ellipsis in elementwise op */
.elementwise-op-element.symbolic-ellipsis {
    border: none;
    background-color: transparent;
    color: #aaa;
    width: auto;
}

/* [NEW] Styles for ElementwiseCalculation */
.elementwise-calc-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: 100%;
    font-size: 0.9em;
}
.calc-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}
.calc-label {
    color: #555;
    font-size: 0.9em;
}
.elementwise-op-element.sum {
    width: auto;
    padding: 0 10px;
    font-weight: bold;
}
.elementwise-op-element.source, .elementwise-op-element.sum.source {
    background-color: var(--highlight-source-bg) !important;
    color: var(--highlight-source-color) !important;
    border-color: var(--highlight-source-border) !important;
}
.elementwise-op-element.target, .elementwise-op-element.sum.target {
    background-color: var(--highlight-target-bg) !important;
    color: var(--highlight-target-color) !important;
    border-color: var(--highlight-target-border) !important;
}

/* [NEW] Styles for Residual Block */
.residual-block {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px 10px;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #fcfcfc;
}
.residual-block:hover {
    border-color: var(--highlight-formula-border);
    background-color: var(--highlight-formula-bg);
}
.residual-icon {
    font-size: 1.6em;
    font-weight: bold;
    color: var(--arrow-color);
    line-height: 1;
}
.residual-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
}
.residual-matrix-symbol {
    font-size: 1.2em;
}
.residual-matrix-dims {
    font-size: 0.8em;
    color: #666;
    font-family: monospace;
}
.residual-block.active {
    border-color: var(--highlight-formula-border);
    border-style: solid;
    box-shadow: 0 0 15px var(--highlight-formula-bg);
    transform: scale(1.05);
}
.residual-block.active .residual-icon {
    color: var(--highlight-formula-border);
}

.add-norm-component-body {
    flex-direction: column; /* Changed for vertical layout */
}

.add-norm-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap; /* Allow wrapping on small screens */
}

/* [NEW] Styles for Tokenization and Decoding */
.token-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 5px;
    cursor: pointer;
    border-radius: 4px;
    border: 2px solid transparent;
    transition: all 0.2s ease-in-out;
}
.token-container:hover {
    transform: scale(1.05);
    background-color: rgba(0,0,0,0.02);
}
.token-container.target {
    border-color: var(--highlight-target-border);
    background-color: var(--highlight-target-bg);
}
.token-container.source {
    border-color: var(--highlight-source-border);
    background-color: var(--highlight-source-bg);
}
.token-text {
    padding: 4px 8px;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-family: monospace;
    font-size: 1.05em;
    min-width: 25px;
    text-align: center;
}
.token-id {
    padding: 2px 6px;
    background-color: #e9ecef;
    border: 1px solid #ced4da;
    border-radius: 10px;
    font-size: 0.8em;
    color: #495057;
}

.token-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
}

.decoding-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
}
.decoding-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
}
.decoding-matrix-wrapper {
    flex-shrink: 1;
    min-width: 0;
}
.decoding-token-wrapper {
    flex-shrink: 0;
}

/* [MODIFIED] Calculation Tooltip now fixed in top-left */
.calculation-tooltip {
    position: absolute;
    top: 20px;
    left: 20px;
    background-color: #ffffff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    width: auto;
    max-width: 500px;
    font-size: 0.95em;
    transition: opacity 0.2s ease-in-out, height 0.3s ease;
    overflow: hidden; /* Important for collapse animation */
}
.tooltip-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #eee;
    padding: 8px 15px;
    margin: 0;
    cursor: default; /* No longer draggable */
}
.tooltip-header:active {
    cursor: default; /* No longer draggable */
}
.tooltip-title {
    font-weight: bold;
    font-size: 1.1em;
}
.tooltip-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}
.tooltip-toggle-btn, .tooltip-close-btn {
    background: none;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
    color: #999;
    padding: 0 5px;
    line-height: 1;
}
.tooltip-toggle-btn:hover, .tooltip-close-btn:hover {
    color: #333;
}
.tooltip-content-wrapper {
    transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
    max-height: 500px; /* Adjust as needed */
    overflow: hidden;
}
.calculation-tooltip.collapsed .tooltip-content-wrapper {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
}
.tooltip-body {
    font-family: monospace;
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 15px;
}
.tooltip-step {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap; /* Allow wrapping for small widths */
}
.tooltip-vector {
    display: flex;
    gap: 4px;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 2px 4px;
    background-color: #f9f9f9;
    overflow-x: auto;
}
.tooltip-element {
    padding: 2px 4px;
    background-color: #fff;
    border-radius: 2px;
}
.tooltip-element.source {
    background-color: var(--highlight-source-bg);
}
.tooltip-op {
    font-weight: bold;
}
.tooltip-result {
    padding: 2px 6px;
    border-radius: 4px;
    background-color: var(--highlight-target-bg);
    border: 1px solid var(--highlight-target-border);
    color: var(--highlight-target-color);
    font-weight: bold;
}
.tooltip-explanation {
    margin-top: 10px;
    font-style: italic;
    color: #666;
    font-size: 0.9em;
    font-family: sans-serif;
}

/* [ADDED] Styles for detailed calculation view in tooltip */
.tooltip-calculation-detail {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #eee;
}
.tooltip-calc-title {
    font-weight: bold;
    font-size: 0.9em;
    color: #333;
    margin-bottom: 8px;
    font-family: sans-serif;
}
.tooltip-calc-equation {
    font-family: monospace;
    font-size: 0.95em;
    color: #555;
    background-color: #f8f9fa;
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto;
    white-space: pre;
}
.tooltip-calc-equation .op {
    color: #c0392b;
    font-weight: bold;
}
.tooltip-calc-equation .result {
    font-weight: bold;
    color: var(--highlight-target-color);
}
.tooltip-calc-equation .ellipsis {
    color: #999;
}


/* [NEW] Styles for EmbeddingLookup Component */
.embedding-lookup-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
    width: 100%;
    position: relative;
    padding: 10px;
    box-sizing: border-box;
}
/* [ADDED] Vertical layout for embedding lookup */
.embedding-lookup-container.vertical {
    flex-direction: column;
}

.embedding-lookup-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allow clicks to pass through */
    z-index: 1;
}
.embedding-lookup-svg path {
    fill: none;
    stroke-width: 2px;
    stroke: var(--arrow-color);
    stroke-dasharray: 5 5;
    transition: all 0.3s ease;
}
.embedding-lookup-svg path.highlighted {
    stroke: var(--highlight-target-border);
    stroke-width: 3px;
    stroke-dasharray: none;
}

.embedding-lookup-column {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
    flex-shrink: 0;
}
.embedding-lookup-vocab {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    min-width: 0; /* Allow shrinking */
}
/*// END OF FILE: src/App.css*/


================================================================================
### 文件路径: src/App.tsx
================================================================================

// FILE: src/App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';
import { HomePage } from './pages/HomePage';
import { TopicPage } from './pages/TopicPage';
import './App.css'; // Global styles remain

function App() {
  return (
    <Router>
      <div className="app-container">
        <header className="app-header">
            <h1><Link to="/" style={{ textDecoration: 'none', color: 'inherit' }}>AI 深度探索专题</Link></h1>
        </header>
        <main className="app-main-content">
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/topic/:topicId" element={<TopicPage />} />
          </Routes>
        </main>
      </div>
    </Router>
  );
}

// Add new global styles for the new layout
const globalStyles = `
  .app-header {
    flex-shrink: 0;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--component-bg);
    z-index: 1001; /* Ensure header is on top */
  }
  .app-header h1 {
    padding: 15px 0;
    font-size: 1.8em;
  }
  .app-main-content {
    flex-grow: 1;
    overflow-y: auto; /* Allow main content to scroll */
    height: calc(100vh - 78px); /* Full height minus header */
  }
`;

const styleSheet = document.createElement("style");
styleSheet.innerText = globalStyles;
document.head.appendChild(styleSheet);


export default App;



================================================================================
### 文件路径: src/index.tsx
================================================================================

// FILE: src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Add this empty export statement to treat this file as a module.
export {};
// END OF FILE: src/index.tsx


================================================================================
### 文件路径: src/components/MarkdownRenderer.tsx
================================================================================

// FILE: src/components/MarkdownRenderer.tsx
import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import { InlineMath, BlockMath } from 'react-katex';
import 'katex/dist/katex.min.css';

interface MarkdownRendererProps {
    markdown: string;
}

export const MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ markdown }) => {
    // 定义我们所有的渲染组件，包括标准的和自定义的
    const components = {
        // [修复] 为 remark-math 插件生成的自定义节点提供渲染器
        // 'math' 对应 $$...$$
        // 'inlineMath' 对应 $...$
        math: ({ value }: { value: string }) => <BlockMath math={value} />,
        inlineMath: ({ value }: { value: string }) => <InlineMath math={value} />,
        
        // 我们也可以在这里覆盖标准HTML标签的样式
        // 使用 'any' 类型来避免对 props 的繁琐类型定义
        img: ({node, ...props}: any) => (
            <img 
                style={{maxWidth: '100%', height: 'auto', borderRadius: '8px', boxShadow: '0 4px 12px rgba(0,0,0,0.1)'}} 
                {...props} 
                alt="" 
            />
        )
    };

    return (
        <ReactMarkdown
            remarkPlugins={[remarkGfm, remarkMath]}
            // [最终解决方案] 将 components 对象断言为 'any' 类型。
            // 这会告诉 TypeScript 编译器：“忽略类型检查，接受我提供的所有自定义渲染器”，
            // 从而彻底解决 TS2322 错误。
            components={components as any}
        >
            {markdown}
        </ReactMarkdown>
    );
};


================================================================================
### 文件路径: src/pages/HomePage.css
================================================================================

/* FILE: src/pages/HomePage.css */
.homepage-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 40px 20px;
}

.homepage-intro {
    text-align: center;
    margin-bottom: 40px;
}

.homepage-intro h2 {
    font-size: 2.5em;
    color: #303133;
}

.homepage-intro p {
    font-size: 1.2em;
    color: #606266;
}

.topic-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 25px;
}

.topic-card-link {
    text-decoration: none;
    color: inherit;
}

.topic-card {
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
    padding: 25px;
    border: 1px solid #dcdfe6;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    flex-direction: column;
    height: 100%;
}

.topic-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12);
}

.topic-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    border-bottom: 1px solid #e4e7ed;
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.topic-card-title {
    font-size: 1.5em;
    margin: 0;
    color: #000;
}

.topic-card-date {
    font-size: 0.85em;
    color: #909399;
    flex-shrink: 0;
    margin-left: 10px;
}

.topic-card-description {
    font-size: 1em;
    line-height: 1.6;
    flex-grow: 1;
    margin-bottom: 20px;
}

.topic-card-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.topic-card-tag {
    background-color: #f0f2f5;
    color: #606266;
    padding: 4px 10px;
    border-radius: 15px;
    font-size: 0.8em;
}


================================================================================
### 文件路径: src/pages/HomePage.tsx
================================================================================

// FILE: src/pages/HomePage.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { topics, Topic } from '../topics';
import './HomePage.css';

const TopicCard: React.FC<{ topic: Topic }> = ({ topic }) => {
    return (
        <Link to={`/topic/${topic.id}`} className="topic-card-link">
            <div className="topic-card">
                <div className="topic-card-header">
                    <h2 className="topic-card-title">{topic.title}</h2>
                    <span className="topic-card-date">{topic.date}</span>
                </div>
                <p className="topic-card-description">{topic.description}</p>
                 <div className="topic-card-tags">
                    {topic.tags.map(tag => <span key={tag} className="topic-card-tag">{tag}</span>)}
                </div>
            </div>
        </Link>
    );
};


export const HomePage: React.FC = () => {
    return (
        <div className="homepage-container">
            <div className="homepage-intro">
                <h2>欢迎来到 AI 深度探索</h2>
                <p>一个旨在通过交互式可视化和深度文章，剖析前沿AI技术的知识平台。</p>
            </div>
            <div className="topic-grid">
                {topics.map(topic => (
                    <TopicCard key={topic.id} topic={topic} />
                ))}
            </div>
        </div>
    );
};


================================================================================
### 文件路径: src/pages/TopicPage.tsx
================================================================================

// FILE: src/pages/TopicPage.tsx
import React from 'react';
import { useParams } from 'react-router-dom';
import { topics } from '../topics';

export const TopicPage: React.FC = () => {
    const { topicId } = useParams<{ topicId: string }>();
    const topic = topics.find(t => t.id === topicId);

    if (!topic) {
        return <div style={{textAlign: 'center', padding: '40px'}}>专题 '{topicId}' 未找到！</div>;
    }

    const TopicComponent = topic.component;

    // For the transformer explorer, we render it directly to control its unique layout
    if (topic.id === 'transformer-explorer') {
        return <TopicComponent />;
    }

    // For other topics (like markdown articles), wrap them in a standard container
    return (
        <div className="topic-page-container">
            <TopicComponent />
        </div>
    );
};

export {}


================================================================================
### 文件路径: src/topics/index.tsx
================================================================================

// FILE: src/topics/index.tsx
import React from 'react'; // 必须导入 React 才能使用 React.FC
import { TransformerExplorerTopic } from './transformer-explorer/TransformerExplorerTopic';
import { AttentionVariantsTopic } from './attention-variants/AttentionVariantsTopic';

export interface Topic {
    id: string;
    title: string;
    description: string;
    date: string;
    tags: string[];
    component: React.FC;
}

export const topics: Topic[] = [
    {
        id: 'attention-variants',
        title: '多头注意力变体: 从MHA, MQA, GQA到MLA',
        description: '深入探讨注意力机制从Multi-Head到Multi-head Latent的演进过程，分析其设计理念、数学原理，以及对KV Cache效率和性能的影响。',
        date: '2025年9月7日',
        tags: ['Attention', 'LLM', 'GQA', 'MLA', '深度剖析'],
        component: AttentionVariantsTopic,
    },
    {
        id: 'transformer-explorer',
        title: 'Transformer 深度探索器',
        description: '一个完全交互式的可视化工具，带您深入探索Transformer模型内部的数据流动、矩阵变换和数学原理。点击任何数字，追溯它的计算来源。',
        date: '2025年9月6日',
        tags: ['Transformer', 'Visualization', 'Interactive', 'PyTorch'],
        component: TransformerExplorerTopic,
    },
    // 未来可以在这里添加更多专题...
];

// [最终修复] 即使已有其他 export 语句，在 .tsx 文件中再添加一个空的 export
// 是最明确、最可靠地将其标记为模块的方式，可以彻底解决 TS1208 错误。
export {};


================================================================================
### 文件路径: src/topics/attention-variants/AttentionVariantsTopic.css
================================================================================

/* FILE: src/topics/attention-variants/AttentionVariantsTopic.css */
.attention-variants-container {
    background-color: #fff;
    padding: 30px 40px;
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
    max-width: 900px;
    margin: 20px auto; /* Add margin for spacing from header */
    font-size: 16px;
    line-height: 1.8;
}

.attention-variants-container h1,
.attention-variants-container h2,
.attention-variants-container h3,
.attention-variants-container h4,
.attention-variants-container h5 {
    color: #000;
    border-bottom: 1px solid #e4e7ed;
    padding-bottom: 10px;
    margin-top: 2em;
    margin-bottom: 1.2em;
}

.attention-variants-container h1 {
    font-size: 2.2em;
    text-align: center;
    border-bottom: 2px solid #dcdfe6;
}

.attention-variants-container h2 {
    font-size: 1.8em;
}

.attention-variants-container p {
    margin-bottom: 1.2em;
}

.attention-variants-container ul,
.attention-variants-container ol {
    padding-left: 25px;
    margin-bottom: 1.2em;
}

.attention-variants-container li {
    margin-bottom: 0.5em;
}

.attention-variants-container code {
    background-color: #e9ecef;
    padding: 2px 5px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.9em;
}

.attention-variants-container blockquote {
    border-left: 4px solid #dcdfe6;
    padding-left: 15px;
    margin: 1.5em 0;
    color: #606266;
    background-color: #f8f9fa;
}

.attention-variants-container table {
    width: 100%;
    border-collapse: collapse;
    margin: 2em 0;
}

.attention-variants-container th,
.attention-variants-container td {
    border: 1px solid #dcdfe6;
    padding: 12px 15px;
    text-align: left;
}

.attention-variants-container th {
    background-color: #f8f9fa;
    font-weight: bold;
}

.attention-variants-container tr:nth-child(even) {
    background-color: #fcfcfc;
}


================================================================================
### 文件路径: src/topics/attention-variants/AttentionVariantsTopic.tsx
================================================================================

// FILE: src/topics/attention-variants/AttentionVariantsTopic.tsx
import React from 'react';
import './AttentionVariantsTopic.css';

export const AttentionVariantsTopic: React.FC = () => {
    return (
        <div className="attention-variants-container">
            <h2>多头注意力变体: 从MHA, MQA, GQA到MLA</h2>
            <p style={{ textAlign: 'center', fontSize: '1.2em', color: '#606266' }}>
                此专题内容正在准备中，敬请期待...
            </p>
            {/*
                当您准备好 markdown 文件后，
                可以用下面这段代码替换上面的 <p> 标签和 <h2> 标签，
                并确保 MarkdownRenderer 组件存在。

                const [content, setContent] = useState('');

                useEffect(() => {
                    fetch(rawMarkdown)
                        .then(response => response.text())
                        .then(text => setContent(text.replace('# FILE: src/topics/attention-variants/content.md', '')));
                }, []);

                if (!content) {
                    return <div>Loading content...</div>;
                }

                return (
                    <div className="attention-variants-container">
                        <MarkdownRenderer markdown={content} />
                    </div>
                );
            */}
        </div>
    );
};


================================================================================
### 文件路径: src/topics/transformer-explorer/TransformerExplorerTopic.tsx
================================================================================

// FILE: src/topics/transformer-explorer/TransformerExplorerTopic.tsx
import React, { useState, useCallback, useEffect } from 'react';

// [FIXED] 路径已更新，指向当前专题内的文件
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { CalculationTooltip } from './components/CalculationTooltip';
import { useTransformer } from './hooks/useTransformer';
import { ElementIdentifier, HighlightSource, HighlightState, TransformerData, TooltipState, Matrix, CalculationComponent } from './types';
import { MATRIX_NAMES } from './config/matrixNames';
import { getSymbolParts } from './config/symbolMapping';


// ============================================================================
// [COPIED] 从旧 App.tsx 复制过来的辅助函数
// ============================================================================

const getLayerAndHeadIndices = (name: string): [number, number] => {
    const layerIdxMatch = name.match(/\.(encoder|decoder)\.(\d+)/);
    const layerIdx = layerIdxMatch ? parseInt(layerIdxMatch[2], 10) : 0;
    const headIdxMatch = name.match(/\.h(\d+)\./);
    const headIdx = headIdxMatch ? parseInt(headIdxMatch[1], 10) : 0;
    return [layerIdx, headIdx];
};

const getMatrixByName = (name: string, data: TransformerData, l: number, h: number): Matrix | undefined => {
    const LNe = MATRIX_NAMES.layer(l);
    const HNe = MATRIX_NAMES.head(l, h);
    const LNd = MATRIX_NAMES.decoderLayer(l);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(l, h);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(l, h);

    if (name === MATRIX_NAMES.inputEmbeddings) return data.inputEmbeddings;
    if (name === MATRIX_NAMES.posEncodings) return data.posEncodings;
    if (name === MATRIX_NAMES.outputEmbeddings) return data.outputEmbeddings;
    if (name === MATRIX_NAMES.decoderPosEncodings) return data.decoderPosEncodings;
    if (name === MATRIX_NAMES.finalEncoderOutput) return data.finalEncoderOutput;
    if (name === MATRIX_NAMES.logits) return data.logits;
    if (name === MATRIX_NAMES.outputProbabilities) return data.outputProbabilities;
    if (name === MATRIX_NAMES.finalLinear) return data.finalLinear;

    const encLayer = data.encoderLayers[l];
    if (encLayer) {
        if (name === LNe.encoder_input) return encLayer.encoder_input;
        if (name === LNe.mha_output) return encLayer.mha_output;
        if (name === LNe.Wo) return encLayer.mha.Wo;
        if (name === LNe.add_norm_1_output) return encLayer.add_norm_1_output;
        if (name === LNe.ffn_output) return encLayer.ffn_output;
        if (name === LNe.add_norm_2_output) return encLayer.add_norm_2_output;
        if (name === LNe.Intermediate) return encLayer.ffn.Intermediate;
        if (name === LNe.Activated) return encLayer.ffn.Activated;
        if (name === LNe.W1) return encLayer.ffn.W1;
        if (name === LNe.b1) return [encLayer.ffn.b1];
        if (name === LNe.W2) return encLayer.ffn.W2;
        if (name === LNe.b2) return [encLayer.ffn.b2];
        const encHead = encLayer.mha.heads[h];
        if (encHead) {
            if (name === HNe.Wq) return encHead.Wq;
            if (name === HNe.Wk) return encHead.Wk;
            if (name === HNe.Wv) return encHead.Wv;
            if (name === HNe.Q) return encHead.Q;
            if (name === HNe.K) return encHead.K;
            if (name === HNe.V) return encHead.V;
            if (name === HNe.Scores) return encHead.Scores;
            if (name === HNe.ScaledScores) return encHead.ScaledScores;
            if (name === HNe.AttentionWeights) return encHead.AttentionWeights;
            if (name === HNe.HeadOutput) return encHead.HeadOutput;
        }
    }

    const decLayer = data.decoderLayers[l];
    if (decLayer) {
        if (name === LNd.decoder_input) return decLayer.decoder_input;
        if (name === LNd.masked_mha_output) return decLayer.masked_mha_output;
        if (name === LNd.Wo_masked) return decLayer.masked_mha.Wo;
        if (name === LNd.add_norm_1_output) return decLayer.add_norm_1_output;
        if (name === LNd.enc_dec_mha_output) return decLayer.enc_dec_mha.output;
        if (name === LNd.Wo_enc_dec) return decLayer.enc_dec_mha.Wo;
        if (name === LNd.add_norm_2_output) return decLayer.add_norm_2_output;
        if (name === LNd.ffn_output) return decLayer.ffn_output;
        if (name === LNd.add_norm_3_output) return decLayer.add_norm_3_output;
        if (name === LNd.Intermediate) return decLayer.ffn.Intermediate;
        if (name === LNd.Activated) return decLayer.ffn.Activated;
        if (name === LNd.W1) return decLayer.ffn.W1;
        if (name === LNd.b1) return [decLayer.ffn.b1];
        if (name === LNd.W2) return decLayer.ffn.W2;
        if (name === LNd.b2) return [decLayer.ffn.b2];
        const maskedMhaHead = decLayer.masked_mha.heads[h];
        if (maskedMhaHead) {
            if (name === HNd_masked.Wq) return maskedMhaHead.Wq;
            if (name === HNd_masked.Wk) return maskedMhaHead.Wk;
            if (name === HNd_masked.Wv) return maskedMhaHead.Wv;
            if (name === HNd_masked.Q) return maskedMhaHead.Q;
            if (name === HNd_masked.K) return maskedMhaHead.K;
            if (name === HNd_masked.V) return maskedMhaHead.V;
            if (name === HNd_masked.Scores) return maskedMhaHead.Scores;
            if (name === HNd_masked.ScaledScores) return maskedMhaHead.ScaledScores;
            if (name === HNd_masked.AttentionWeights) return maskedMhaHead.AttentionWeights;
            if (name === HNd_masked.HeadOutput) return maskedMhaHead.HeadOutput;
        }
        const encDecMhaHead = decLayer.enc_dec_mha.heads[h];
        if (encDecMhaHead) {
            if (name === HNd_encdec.Wq) return encDecMhaHead.Wq;
            if (name === HNd_encdec.Wk) return encDecMhaHead.Wk;
            if (name === HNd_encdec.Wv) return encDecMhaHead.Wv;
            if (name === HNd_encdec.Q) return encDecMhaHead.Q;
            if (name === HNd_encdec.K) return encDecMhaHead.K;
            if (name === HNd_encdec.V) return encDecMhaHead.V;
            if (name === HNd_encdec.Scores) return encDecMhaHead.Scores;
            if (name === HNd_encdec.ScaledScores) return encDecMhaHead.ScaledScores;
            if (name === HNd_encdec.AttentionWeights) return encDecMhaHead.AttentionWeights;
            if (name === HNd_encdec.HeadOutput) return encDecMhaHead.HeadOutput;
        }
    }
    return undefined;
}

const generateTooltipData = (element: ElementIdentifier, transformerData: TransformerData, sources: HighlightSource[]): TooltipState | null => {
    const { name, row, col } = element;
    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    let opType: TooltipState['opType'] = 'info';
    let steps: TooltipState['steps'] = [];
    const targetMatrix = getMatrixByName(name, transformerData, layerIdx, headIdx);
    const targetValue = targetMatrix?.[row]?.[col] ?? 0;

    if (sources.length === 2 && sources[0].highlightRow && sources[1].highlightCol) {
        opType = 'matmul';
        const source1 = sources[0];
        const source2 = sources[1];
        const matrixA = getMatrixByName(source1.name, transformerData, layerIdx, headIdx);
        const matrixB = getMatrixByName(source2.name, transformerData, layerIdx, headIdx);
        if (matrixA && matrixB && matrixA[source1.row] && matrixB.length > 0 && matrixB[0].length > source2.col) {
            const vecA = matrixA[source1.row];
            const vecB = matrixB.map(r => r[source2.col]);
            const components: CalculationComponent[] = vecA.map((val, i) => ({ a: val, b: vecB[i] }));
            steps.push({ a: vecA, b: vecB, op: '·', result: targetValue, aSymbol: getSymbolParts(source1.name).base, bSymbol: getSymbolParts(source2.name).base, components });
        }
    } else if (sources.length === 2 && !sources[0].highlightRow && !sources[1].highlightRow) {
        opType = 'add';
        const source1 = sources[0];
        const source2 = sources[1];
        const matrixA = getMatrixByName(source1.name, transformerData, layerIdx, headIdx);
        const matrixB = getMatrixByName(source2.name, transformerData, layerIdx, headIdx);
        if (matrixA && matrixB && matrixA[source1.row]?.[source1.col] !== undefined && matrixB[source2.row]?.[source2.col] !== undefined) {
            const valA = matrixA[source1.row][source1.col];
            const valB = matrixB[source2.row][source2.col];
            const components: CalculationComponent[] = [{ a: valA, b: valB }];
            steps.push({ a: [valA], b: [valB], op: '+', result: targetValue, aSymbol: getSymbolParts(source1.name).base, bSymbol: getSymbolParts(source2.name).base, components });
        }
    }
    if (steps.length === 0) return null;
    return { target: element, opType, steps, title: `Calculation for ${getSymbolParts(name).base}[${row},${col}]`, initialPosition: { x: 0, y: 0 } };
};

const createBackwardHighlight = (element: ElementIdentifier, transformerData: TransformerData, dims: any): { highlight: HighlightState } => {
    const { name, row, col, isInternal } = element;
    let newSources: HighlightSource[] = [];
    let newTarget: ElementIdentifier | null = element;
    let activeComponent: string | null = null;
    let activeResidual: string | null = null;

    if (name.startsWith('residual.')) {
        const [, resId] = name.split('.');
        activeResidual = resId;
        const layerIdx = parseInt(resId.match(/l(\d+)/)?.[1] || '0', 10);
        const part = parseInt(resId.match(/(\d+)$/)?.[1] || '1', 10);
        if (resId.includes('-d')) {
            const LN = MATRIX_NAMES.decoderLayer(layerIdx);
            if (part === 1) { activeComponent = 'add_norm_1_dec'; newSources.push({ name: LN.decoder_input, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.masked_mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2_dec'; newSources.push({ name: LN.add_norm_1_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.enc_dec_mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 3) { activeComponent = 'add_norm_3_dec'; newSources.push({ name: LN.add_norm_2_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.ffn_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
        } else {
            const LN = MATRIX_NAMES.layer(layerIdx);
            if (part === 1) { activeComponent = 'add_norm_1'; newSources.push({ name: LN.encoder_input, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2'; newSources.push({ name: LN.add_norm_1_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.ffn_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
        }
        return { highlight: { target: null, sources: newSources, activeComponent, activeResidual, destinations: [] } };
    }

    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    const LNe = MATRIX_NAMES.layer(layerIdx);
    const HNe = MATRIX_NAMES.head(layerIdx, headIdx);
    const LNd = MATRIX_NAMES.decoderLayer(layerIdx);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIdx, headIdx);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(layerIdx, headIdx);
    const baseName = isInternal ? name.replace('.internal', '') : name;

    if (name.startsWith('encoder')) {
        if (Object.values(HNe).includes(baseName) || [LNe.mha_output, LNe.Wo, LNe.encoder_input].includes(baseName)) activeComponent = 'mha';
        else if ([LNe.add_norm_1_output].includes(baseName)) activeComponent = 'add_norm_1';
        else if ([LNe.add_norm_2_output].includes(baseName)) activeComponent = 'add_norm_2';
        else if (baseName.includes('.ffn.')) activeComponent = 'ffn';
    } else if (name.startsWith('decoder')) {
        if (Object.values(HNd_masked).includes(baseName) || [LNd.masked_mha_output, LNd.Wo_masked, LNd.decoder_input].includes(baseName)) activeComponent = 'masked_mha';
        else if (Object.values(HNd_encdec).includes(baseName) || [LNd.enc_dec_mha_output, LNd.Wo_enc_dec, LNd.add_norm_1_output, MATRIX_NAMES.finalEncoderOutput].includes(baseName)) activeComponent = 'enc_dec_mha';
        else if (baseName === LNd.add_norm_1_output) activeComponent = 'add_norm_1_dec';
        else if (baseName === LNd.add_norm_2_output) activeComponent = 'add_norm_2_dec';
        else if (baseName === LNd.add_norm_3_output) activeComponent = 'add_norm_3_dec';
        else if (baseName.includes('.ffn.')) activeComponent = 'ffn_dec';
    } else if (name === 'inputToken' || name === 'embeddingMatrix' || name === 'inputEmbeddings') {
        activeComponent = 'token_embed';
    } else if ([MATRIX_NAMES.posEncodings, MATRIX_NAMES.encoderInput].includes(baseName) || baseName === LNe.encoder_input) {
        activeComponent = 'input_embed';
    } else if ([MATRIX_NAMES.outputEmbeddings, MATRIX_NAMES.decoderPosEncodings, MATRIX_NAMES.decoderInput].includes(baseName) || baseName === LNd.decoder_input) {
        activeComponent = 'output_embed';
    } else if ([MATRIX_NAMES.finalLinear, MATRIX_NAMES.logits].includes(baseName)) {
        activeComponent = 'final_output';
    } else if (name === MATRIX_NAMES.outputProbabilities || name === 'outputToken') {
        activeComponent = 'decoding';
    }

    if (isInternal) {
        newTarget = { name, row, col, isInternal: true };
        if (baseName.includes('AttentionWeights')) {
            const scaledScoresName = baseName.includes('masked_mha') ? HNd_masked.ScaledScores : baseName.includes('enc_dec_mha') ? HNd_encdec.ScaledScores : HNe.ScaledScores;
            newSources.push({ name: scaledScoresName, row, col: -1, highlightRow: true });
        } else if (baseName.includes('Activated')) {
            const intermediateName = baseName.includes('decoder') ? LNd.Intermediate : LNe.Intermediate;
            newSources.push({ name: intermediateName, row, col });
        }
    }
    else if (name === 'inputToken') { newSources.push({ name: MATRIX_NAMES.inputEmbeddings, row, col: -1, highlightRow: true }) }
    else if (name === MATRIX_NAMES.inputEmbeddings) { newSources.push({ name: 'inputToken', row, col: -1 }); newSources.push({ name: 'embeddingMatrix', row: transformerData.tokenizedInput[row], col: -1, highlightRow: true }) }
    else if (name === LNe.encoder_input) {
        if (layerIdx === 0) {
            newSources.push({ name: MATRIX_NAMES.inputEmbeddings, row, col });
            newSources.push({ name: MATRIX_NAMES.posEncodings, row, col });
        } else {
            newSources.push({ name: MATRIX_NAMES.layer(layerIdx - 1).add_norm_2_output, row, col });
        }
    }
    else if (name === HNe.Q || name === HNe.K || name === HNe.V) { const type = name.split('.').pop()!; newSources.push({ name: LNe.encoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: HNe[`W${type.toLowerCase()}` as 'Wq' | 'Wk' | 'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNe.Scores) { newSources.push({ name: HNe.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNe.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNe.ScaledScores) { newSources.push({ name: HNe.Scores, row, col }); }
    else if (name === HNe.AttentionWeights) { newSources.push({ name: HNe.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNe.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNe.HeadOutput) { newSources.push({ name: HNe.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNe.V, row: -1, col, highlightCol: true }); }
    else if (name === LNe.mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.head(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.Wo, row: -1, col, highlightCol: true }); }
    else if (name === LNe.add_norm_1_output) { newSources.push({ name: LNe.encoder_input, row, col }); newSources.push({ name: LNe.mha_output, row, col }); }
    else if (name === LNe.Intermediate) { newSources.push({ name: LNe.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.W1, row: -1, col, highlightCol: true }); newSources.push({ name: LNe.b1, row: 0, col }); }
    else if (name === LNe.Activated) { newSources.push({ name: LNe.Intermediate, row, col }); newSources.push({ name: `${LNe.Activated}.internal`, row, col, isInternal: true }); }
    else if (name === LNe.ffn_output) { newSources.push({ name: LNe.Activated, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.W2, row: -1, col, highlightCol: true }); newSources.push({ name: LNe.b2, row: 0, col }); }
    else if (name === LNe.add_norm_2_output) { newSources.push({ name: LNe.add_norm_1_output, row, col }); newSources.push({ name: LNe.ffn_output, row, col }); }
    else if (name === LNd.decoder_input) {
        if (layerIdx === 0) {
            newSources.push({ name: MATRIX_NAMES.outputEmbeddings, row, col });
            newSources.push({ name: MATRIX_NAMES.decoderPosEncodings, row, col });
        } else {
            newSources.push({ name: MATRIX_NAMES.decoderLayer(layerIdx - 1).add_norm_3_output, row, col });
        }
    }
    else if (name === HNd_masked.Q || name === HNd_masked.K || name === HNd_masked.V) { const type = name.split('.').pop()!; newSources.push({ name: LNd.decoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked[`W${type.toLowerCase()}` as 'Wq' | 'Wk' | 'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNd_masked.Scores) { newSources.push({ name: HNd_masked.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNd_masked.ScaledScores) { newSources.push({ name: HNd_masked.Scores, row, col }); }
    else if (name === HNd_masked.AttentionWeights) { newSources.push({ name: HNd_masked.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNd_masked.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNd_masked.HeadOutput) { newSources.push({ name: HNd_masked.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked.V, row: -1, col, highlightCol: true }); }
    else if (name === LNd.masked_mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.maskedMhaHead(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.Wo_masked, row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_1_output) { newSources.push({ name: LNd.decoder_input, row, col }); newSources.push({ name: LNd.masked_mha_output, row, col }); }
    else if (name === HNd_encdec.Q) { newSources.push({ name: LNd.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_encdec.Wq, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.K) { newSources.push({ name: MATRIX_NAMES.finalEncoderOutput, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: HNd_encdec.Wk, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.V) { newSources.push({ name: MATRIX_NAMES.finalEncoderOutput, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: HNd_encdec.Wv, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.Scores) { newSources.push({ name: HNd_encdec.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_encdec.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNd_encdec.ScaledScores) { newSources.push({ name: HNd_encdec.Scores, row, col }); }
    else if (name === HNd_encdec.AttentionWeights) { newSources.push({ name: HNd_encdec.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNd_encdec.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNd_encdec.HeadOutput) { newSources.push({ name: HNd_encdec.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_encdec.V, row: -1, col, highlightCol: true }); }
    else if (name === LNd.enc_dec_mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.encDecMhaHead(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.Wo_enc_dec, row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_2_output) { newSources.push({ name: LNd.add_norm_1_output, row, col }); newSources.push({ name: LNd.enc_dec_mha_output, row, col }); }
    else if (name === LNd.Intermediate) { newSources.push({ name: LNd.add_norm_2_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.W1, row: -1, col, highlightCol: true }); newSources.push({ name: LNd.b1, row: 0, col }); }
    else if (name === LNd.Activated) { newSources.push({ name: LNd.Intermediate, row, col }); newSources.push({ name: `${LNd.Activated}.internal`, row, col, isInternal: true }); }
    else if (name === LNd.ffn_output) { newSources.push({ name: LNd.Activated, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.W2, row: -1, col, highlightCol: true }); newSources.push({ name: LNd.b2, row: 0, col }); }
    else if (name === LNd.add_norm_3_output) { newSources.push({ name: LNd.add_norm_2_output, row, col }); newSources.push({ name: LNd.ffn_output, row, col }); }
    else if (name === MATRIX_NAMES.logits) { newSources.push({ name: MATRIX_NAMES.decoderLayer(dims.n_layers - 1).add_norm_3_output, row, col: -1, highlightRow: true }); newSources.push({ name: MATRIX_NAMES.finalLinear, row: -1, col, highlightCol: true }) }
    else if (name === MATRIX_NAMES.outputProbabilities) { newSources.push({ name: MATRIX_NAMES.logits, row, col: -1, highlightRow: true }) }
    else if (name === 'outputToken') { newSources.push({ name: MATRIX_NAMES.outputProbabilities, row, col: -1, highlightRow: true, highlightProbCol: true }) }

    const highlight = { target: newTarget, sources: newSources, activeComponent, activeResidual, destinations: [] };
    return { highlight };
};


export const TransformerExplorerTopic: React.FC = () => {
    const [dims, setDims] = useState({ d_model: 8, h: 2, seq_len: 2, n_layers: 1, d_ff: 32 });
    const [inputText, setInputText] = useState("I am a student");
    const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [], destinations: [], activeComponent: null, activeResidual: null });
    const [tooltip, setTooltip] = useState<TooltipState | null>(null);

    const transformerData: TransformerData | null = useTransformer(inputText, dims);

    useEffect(() => {
        if (highlight.activeComponent) {
          const explanationEl = document.getElementById(`math_${highlight.activeComponent}`);
          if (explanationEl) {
              setTimeout(() => {
                  explanationEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }, 100);
          }
        }
      }, [highlight.activeComponent]);

    const handleInteraction = useCallback((element: ElementIdentifier, event: React.MouseEvent) => {
        if (!transformerData) return;
        const { highlight: newHighlight } = createBackwardHighlight(element, transformerData, dims);

        let newTooltip: TooltipState | null = null;
        if (newHighlight.target && newHighlight.sources.length > 0 && !newHighlight.target.isInternal) {
            newTooltip = generateTooltipData(element, transformerData, newHighlight.sources);
        }

        setHighlight(newHighlight);
        setTooltip(newTooltip);
    }, [transformerData, dims]);

    const handleComponentClick = useCallback((componentId: string) => {
      setHighlight(prev => ({
          target: null, sources: [], destinations: [], activeComponent: componentId, activeResidual: null
      }));
      setTooltip(null);
    }, []);

    const closeTooltip = useCallback(() => setTooltip(null), []);

    if (!transformerData) {
        return <div style={{padding: "20px", textAlign: "center"}}>正在加载或维度设置无效... (d_model 必须能被 h 整除)</div>
    }

    const explanationDims = {
      ...dims,
      encoder_seq_len: transformerData.encoderInput.length,
      decoder_seq_len: transformerData.decoderInput.length,
      vocab_size: Object.keys(transformerData.vocab).length
  };

    return (
        <div className="main-layout" style={{padding: '0', gap: '0'}}>
            {tooltip && <CalculationTooltip tooltip={tooltip} onClose={closeTooltip} />}
            <Controls dims={dims} setDims={setDims} inputText={inputText} setInputText={setInputText}/>
            <div className="column left-column" style={{borderRadius: '0', boxShadow: 'none'}}>
                <div className="column-content">
                    <h2>模型结构与数据流</h2>
                    <p style={{textAlign: 'center', margin: '-10px 0 15px 0', fontSize: '0.9em', color: '#555'}}>
                        提示: 点击任何计算结果 (红色高亮) 的单元格,即可查看其详细计算过程.
                    </p>
                    <Viz
                        data={transformerData}
                        highlight={highlight}
                        onElementClick={handleInteraction}
                        onComponentClick={handleComponentClick}
                    />
                </div>
            </div>
            <div className="column right-column" style={{borderRadius: '0', boxShadow: 'none'}}>
                <div className="column-content">
                    <h2>数学原理详解</h2>
                    <Explanation
                        dims={explanationDims}
                        highlight={highlight}
                        onSymbolClick={handleInteraction}
                    />
                </div>
            </div>
        </div>
    );
}


================================================================================
### 文件路径: src/topics/transformer-explorer/types.ts
================================================================================

// FILE: src/types.ts
export type Matrix = number[][];
export type Vector = number[];

export interface ElementIdentifier {
  name: string; // e.g., "encoder.0.mha.h0.Q" or "residual.res1.start"
  row: number;
  col: number;
  isInternal?: boolean; // True if it's part of an internal calculation visualization
  matrixSymbol?: string; // e.g., "Z"
  matrixDims?: string; // e.g., "3x8"
  tokenId?: number; // e.g., 10 for "I"
  tokenStr?: string; // e.g., "I"
  probValue?: number; // For decoding, the probability of the chosen token
}

export interface HighlightSource extends ElementIdentifier {
  highlightRow?: boolean;
  highlightCol?: boolean;
  highlightProbCol?: boolean;
}

export interface HighlightState {
  activeComponent: string | null; // e.g., "mha", "ffn"
  activeResidual: string | null; // e.g., "res1"
  target: ElementIdentifier | null;
  sources: HighlightSource[];
  destinations?: HighlightSource[]; // For forward tracing
}

export interface CalculationComponent {
    a: number;
    b: number;
}

export interface CalculationStep {
    a: Vector;
    b: Vector;
    op: string; // e.g., '·', '+', '...'
    result: number;
    aSymbol: string;
    bSymbol: string;
    components?: CalculationComponent[]; // [NEW] For detailed breakdown of calculations
}

export interface TooltipState {
    target: ElementIdentifier;
    opType: 'matmul' | 'add' | 'info';
    steps: CalculationStep[];
    title: string;
    initialPosition: { x: number, y: number }; // [NEW] For positioning the tooltip
}

export interface AttentionHeadData {
  Wq: Matrix;
  Wk: Matrix;
  Wv: Matrix;
  Q: Matrix;
  K: Matrix;
  V: Matrix;
  Scores: Matrix;
  ScaledScores: Matrix;
  AttentionWeights: Matrix;
  HeadOutput: Matrix;
}

export interface MultiHeadAttentionData {
    heads: AttentionHeadData[];
    Wo: Matrix;
    output: Matrix;
}

export interface FFNData {
    W1: Matrix;
    b1: Vector; // bias is part of FFN data
    Intermediate: Matrix;
    Activated: Matrix;
    W2: Matrix;
    b2: Vector; // bias is part of FFN data
    Output: Matrix;
}

export interface EncoderLayerData {
    encoder_input: Matrix;
    mha: MultiHeadAttentionData;
    mha_output: Matrix;

    add_norm_1_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;

    add_norm_2_output: Matrix;
}

export interface DecoderLayerData {
    decoder_input: Matrix;
    masked_mha: MultiHeadAttentionData;
    masked_mha_output: Matrix;
    add_norm_1_output: Matrix;

    enc_dec_mha: MultiHeadAttentionData;
    enc_dec_mha_output: Matrix;
    add_norm_2_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;
    add_norm_3_output: Matrix;
}

export interface TransformerData {
    // Input Stage
    inputText: string[];
    tokenizedInput: number[];
    embeddingMatrix: Matrix;
    vocab: { [key: number]: string };

    // Encoder
    inputEmbeddings: Matrix;
    posEncodings: Matrix;
    encoderInput: Matrix;
    encoderLayers: EncoderLayerData[];
    finalEncoderOutput: Matrix;

    // Decoder
    outputEmbeddings: Matrix;
    decoderPosEncodings: Matrix;
    decoderInput: Matrix;
    decoderLayers: DecoderLayerData[];
    finalDecoderOutput: Matrix;
    finalLinear: Matrix; // Weights for the final linear layer
    logits: Matrix;
    outputProbabilities: Matrix;

    // Output Stage
    decodedTokens: number[];
    outputText: string[];
}
// END OF FILE: src/types.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/components/AddNorm.tsx
================================================================================

// FILE: src/components/AddNorm.tsx
import React from 'react';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { ResidualBlock } from './ResidualBlock';

interface AddNormProps {
    residualInput: MatrixType; // [MODIFIED] Pass the full residual input matrix
    residualInputName: string; // [MODIFIED] Name of the residual input matrix
    inputSublayer: MatrixType;
    output: MatrixType;
    sublayerMatrixName: string;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    activeId: string;
    residualId: string;
    residualMatrixSymbol: string;
    residualMatrixDims: string;
}

export const AddNorm: React.FC<AddNormProps> = ({
    residualInput,
    residualInputName,
    inputSublayer,
    output,
    sublayerMatrixName,
    outputMatrixName,
    highlight,
    onElementClick,
    onComponentClick,
    activeId,
    residualId,
    residualMatrixSymbol,
    residualMatrixDims,
}) => {
    const isActive = highlight.activeComponent === activeId;

    return (
         <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick(activeId)}>Add & LayerNorm</div>
            <div className="component-body add-norm-component-body">
                <div className="add-norm-inputs">
                    {/* [MODIFIED] Show the full matrix for the residual connection */}
                    <Matrix name={residualInputName} data={residualInput} highlight={highlight} onElementClick={onElementClick} />
                    <ResidualBlock
                        id={residualId}
                        type="end"
                        highlight={highlight}
                        onElementClick={(el, e) => onElementClick(el, e)}
                        matrixSymbol={residualMatrixSymbol}
                        matrixDims={residualMatrixDims}
                    />
                    <div className="op-symbol">+</div>
                    <Matrix name={sublayerMatrixName} data={inputSublayer} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down"><InlineMath math="\xrightarrow{\text{LayerNorm}}" /></div>

                <Matrix name={outputMatrixName} data={output} highlight={highlight} onElementClick={onElementClick} />
            </div>
        </div>
    );
};
// END OF FILE: src/components/AddNorm.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/CalculationTooltip.tsx
================================================================================

// FILE: src/components/CalculationTooltip.tsx
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { TooltipState, CalculationComponent } from '../types';

interface CalculationTooltipProps {
  tooltip: TooltipState;
  onClose: () => void;
}

const renderVector = (vec: number[], type: 'source' | 'target' | 'none') => {
    return (
        <div className="tooltip-vector">
            {vec.map((val, i) => (
                <span key={i} className={`tooltip-element ${type}`}>{val.toFixed(4)}</span>
            ))}
        </div>
    );
};

const renderCalculationDetail = (opType: 'matmul' | 'add' | 'info', components: CalculationComponent[], result: number) => {
    if (!components || components.length === 0) return null;

    let equation: React.ReactNode;
    let title: string;

    if (opType === 'matmul') {
        title = "点积计算分解 (Dot Product Breakdown):";
        const MAX_TERMS = 4;
        const terms = components.map((comp, i) => (
            <span key={i}>
                {i > 0 && <span className="op"> + </span>}
                <span>({comp.a.toFixed(4)} <span className="op">×</span> {comp.b.toFixed(4)})</span>
            </span>
        ));

        let displayedTerms;
        if (terms.length > (MAX_TERMS * 2)) {
            displayedTerms = [
                ...terms.slice(0, MAX_TERMS),
                <span key="ellipsis" className="ellipsis"> ... </span>,
                ...terms.slice(terms.length - MAX_TERMS)
            ];
        } else {
            displayedTerms = terms;
        }

        equation = (
            <>
                {displayedTerms}
                <span> = <span className="result">{result.toFixed(2)}</span></span>
            </>
        );

    } else if (opType === 'add') {
        title = "逐元素加法 (Element-wise Addition):";
        const comp = components[0];
        equation = (
            <>
                <span>{comp.a.toFixed(4)} <span className="op">+</span> {comp.b.toFixed(4)}</span>
                <span> = <span className="result">{result.toFixed(2)}</span></span>
            </>
        );
    } else {
        return null;
    }


    return (
        <div className="tooltip-calculation-detail">
            <div className="tooltip-calc-title">{title}</div>
            <div className="tooltip-calc-equation">{equation}</div>
        </div>
    );
};

export const CalculationTooltip: React.FC<CalculationTooltipProps> = ({ tooltip, onClose }) => {
    const tooltipRef = useRef<HTMLDivElement>(null);
    const [isCollapsed, setIsCollapsed] = useState(false);

    useEffect(() => {
        setIsCollapsed(false); // Expand tooltip whenever it changes
    }, [tooltip]);

    return (
        <div className={`calculation-tooltip ${isCollapsed ? 'collapsed' : ''}`} ref={tooltipRef}>
            <div className="tooltip-header">
                <span className="tooltip-title">{tooltip.title}</span>
                <div className="tooltip-controls">
                     <button onClick={() => setIsCollapsed(!isCollapsed)} className="tooltip-toggle-btn">
                        {isCollapsed ? '⊕' : '⊖'}
                    </button>
                    <button onClick={onClose} className="tooltip-close-btn">&times;</button>
                </div>
            </div>
            <div className="tooltip-content-wrapper">
                <div className="tooltip-body">
                    {tooltip.steps.map((step, index) => (
                        <div key={index}>
                            <div className="tooltip-step">
                                {renderVector(step.a, 'source')}
                                <span className="tooltip-op">{step.op}</span>
                                {renderVector(step.b, 'source')}
                                <span className="tooltip-op">=</span>
                                <span className="tooltip-result">{step.result.toFixed(2)}</span>
                            </div>
                            {renderCalculationDetail(tooltip.opType, step.components || [], step.result)}
                        </div>
                    ))}
                    {tooltip.opType === 'matmul' &&
                        <p className="tooltip-explanation">
                            Showing dot product of row {tooltip.target.row} from the first matrix and column {tooltip.target.col} from the second.
                        </p>
                    }
                    {tooltip.opType === 'add' &&
                        <p className="tooltip-explanation">
                            Showing element-wise addition for position ({tooltip.target.row}, {tooltip.target.col}).
                        </p>
                    }
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/CalculationTooltip.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Controls.tsx
================================================================================

// FILE: src/components/Controls.tsx
import React, { useState, useCallback, useEffect, useRef } from 'react';

interface ControlsProps {
  dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
  setDims: (dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number }) => void;
  inputText: string;
  setInputText: (text: string) => void;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims, inputText, setInputText }) => {
  const [isControlsVisible, setIsControlsVisible] = useState(true);
  const panelRef = useRef<HTMLDivElement>(null);

  // [REMOVED] Dragging logic is no longer needed
  // const [position, setPosition] = useState(...);
  // const dragData = useRef(...);
  // const handleMouseDown = useCallback(...);
  // const handleMouseMove = useCallback(...);
  // const handleMouseUp = useCallback(...);
  // useEffect for mouse events...

  const handleDimChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    let newDims = { ...dims, [id]: parseInt(value, 10) || 1 };

    // Ensure d_model is divisible by h
    if (id === 'h') {
        if (newDims.d_model % newDims.h !== 0) {
             newDims.d_model = Math.max(newDims.h, Math.ceil(newDims.d_model / newDims.h) * newDims.h);
        }
    }
    if (id === 'd_model') {
         if (newDims.d_model % newDims.h !== 0) {
             let best_h = 1;
             for (let i = 1; i <= newDims.d_model; i++) {
                 if (newDims.d_model % i === 0) {
                    if (Math.abs(i - newDims.h) < Math.abs(best_h - newDims.h)) {
                       best_h = i;
                    }
                 }
             }
             newDims.h = best_h;
         }
    }

    if(id === 'd_model') {
        newDims.d_ff = newDims.d_model * 4;
    }

    setDims(newDims);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      setInputText(e.target.value);
  }

  const d_k = dims.d_model % dims.h === 0 ? dims.d_model / dims.h : 'N/A';

  // [REMOVED] Inline style for positioning is now handled by CSS
  // const panelStyle: React.CSSProperties = { ... };

  return (
    <div ref={panelRef} className={`controls-panel ${!isControlsVisible ? 'collapsed' : ''}`}>
      {/* [REMOVED] onMouseDown handler for dragging */}
      <div className="controls-panel-header">
        <button className="controls-toggle-btn" onClick={() => setIsControlsVisible(!isControlsVisible)}>
          {isControlsVisible ? '×' : '⚙️'}
        </button>
      </div>
      <div className="controls-container">
        <div className="control-group">
          <label htmlFor="inputText">输入文本 (Encoder Input)</label>
          <input type="text" id="inputText" value={inputText} onChange={handleInputChange} />
        </div>
        <div className="control-group">
          <label htmlFor="seq_len">解码器长度 (Decoder Len)</label>
          <input type="number" id="seq_len" value={dims.seq_len} onChange={handleDimChange} min="1" max="4" />
        </div>
        <div className="control-group">
          <label htmlFor="d_model">模型维度 (d_model)</label>
          <input type="number" id="d_model" value={dims.d_model} onChange={handleDimChange} step={1} min={2} max="16"/>
        </div>
        <div className="control-group">
          <label htmlFor="h">注意力头数 (h)</label>
          <input type="number" id="h" value={dims.h} onChange={handleDimChange} min="1" max={dims.d_model}/>
        </div>
        <div className="control-group">
          <label htmlFor="n_layers">层数 (N)</label>
          <input type="number" id="n_layers" value={dims.n_layers} onChange={handleDimChange} min="1" max="3"/>
        </div>
        <div className="control-group">
          <label>键/查询维度 (d_k)</label>
          <div className="d_k-value">{d_k}</div>
        </div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Controls.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/DecoderLayer.tsx
================================================================================

// FILE: src/components/DecoderLayer.tsx
import React from 'react';
import { DecoderLayerData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../config/symbolMapping';
import { Matrix } from './Matrix';
import { MaskedMultiHeadAttention } from './MaskedMultiHeadAttention';
import { EncoderDecoderAttention } from './EncoderDecoderAttention';

interface DecoderLayerProps {
  layerIndex: number;
  data: DecoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  onComponentClick: (componentId: string) => void;
  finalEncoderOutput: MatrixType; // [ADDED]
}

export const DecoderLayer: React.FC<DecoderLayerProps> = ({ layerIndex, data, highlight, onElementClick, onComponentClick, finalEncoderOutput }) => {
  const baseName = `decoder.${layerIndex}`;
  const LN = MATRIX_NAMES.decoderLayer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.decoder_input);
  const dimsRes1 = `${data.decoder_input.length}x${data.decoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  const symbolRes3 = getSymbolParts(LN.add_norm_2_output);
  const dimsRes3 = `${data.add_norm_2_output.length}x${data.add_norm_2_output[0].length}`;
  const mathSymbolRes3 = symbolRes3.base + (symbolRes3.subscript ? `_{${symbolRes3.subscript}}` : '') + (symbolRes3.superscript ? `^{${symbolRes3.superscript}}` : '');

  return (
    <div className="decoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#d1c4e9', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#ede7f6'}}>解码器层 (Decoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- Masked MHA Sub-layer --- */}
                <Matrix name={LN.decoder_input} data={data.decoder_input} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-d1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MaskedMultiHeadAttention
                    baseName={`${baseName}.masked_mha`}
                    data={data.masked_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.decoder_input}
                    residualInputName={LN.decoder_input}
                    inputSublayer={data.masked_mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.masked_mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_1_dec"
                    residualId={`res-l${layerIndex}-d1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />
                <div className="arrow-down">↓</div>

                {/* --- Encoder-Decoder Attention Sub-layer --- */}
                <ResidualBlock id={`res-l${layerIndex}-d2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <EncoderDecoderAttention
                    baseName={`${baseName}.enc_dec_mha`}
                    data={data.enc_dec_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    finalEncoderOutput={finalEncoderOutput}
                />
                <AddNorm
                    residualInput={data.add_norm_1_output}
                    residualInputName={LN.add_norm_1_output}
                    inputSublayer={data.enc_dec_mha_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.enc_dec_mha_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_2_dec"
                    residualId={`res-l${layerIndex}-d2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />
                <div className="arrow-down">↓</div>

                {/* --- FFN Sub-layer --- */}
                <ResidualBlock id={`res-l${layerIndex}-d3`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes3} matrixDims={dimsRes3} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_2_output}
                    inputName={LN.add_norm_2_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.add_norm_2_output}
                    residualInputName={LN.add_norm_2_output}
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_3_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_3_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_3_dec"
                    residualId={`res-l${layerIndex}-d3`}
                    residualMatrixSymbol={mathSymbolRes3}
                    residualMatrixDims={dimsRes3}
                />
            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/DecoderLayer.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Decoding.tsx
================================================================================

// FILE: src/components/Decoding.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { EmbeddingLookup } from './EmbeddingLookup';

interface DecodingProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    isActive: boolean;
}

export const Decoding: React.FC<DecodingProps> = ({ data, highlight, onElementClick, onComponentClick, isActive }) => {
    // Create a list of ElementIdentifier for the output tokens
    const outputTokensForLookup: ElementIdentifier[] = data.outputText.map((token, i) => {
        const correspondingProbRow = data.outputProbabilities[i];
        const maxProb = Math.max(...correspondingProbRow);
        return {
            name: "outputToken",
            row: i,
            col: -1, // Not a cell in a matrix
            tokenId: data.decodedTokens[i],
            tokenStr: token,
            probValue: maxProb
        };
    });

    const shouldBreak = (data.embeddingMatrix[0]?.length || 0) > 10;

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('decoding')}>Output: Decoding Probabilities to Text</div>
            <div className="component-body">

                <div className="decoding-step">
                    <div className="viz-step-title">1. Find Index of Max Probability per Row (Argmax)</div>
                    <p style={{textAlign: 'center', margin: '0 0 10px 0', fontSize: '0.9em', color: '#555'}}>Click a row in the probability matrix to see which token it generates.</p>
                     <Matrix name="outputProbabilities" data={data.outputProbabilities} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down">↓</div>

                <div className="decoding-step">
                     <div className="viz-step-title">2. Use Token IDs to Lookup Text from Vocabulary</div>
                     <EmbeddingLookup
                        mode="id-to-token"
                        tokens={outputTokensForLookup}
                        embeddingMatrix={data.embeddingMatrix}
                        vocab={data.vocab}
                        matrixName="embeddingMatrix"
                        highlight={highlight}
                        onElementClick={onElementClick}
                        shouldBreak={shouldBreak}
                     />
                </div>

            </div>
        </div>
    );
};
// END OF FILE: src/components/Decoding.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Element.tsx
================================================================================

// FILE: src/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isProbMax?: boolean; // [NEW] To specifically highlight the argmax result
}

export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick, isProbMax = false }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col && !highlight.target.isInternal;

  const isSource = highlight.sources.some(s => {
    if (s.name !== name || s.isInternal) return false;
    if (s.highlightRow) return s.row === row;
    if (s.highlightCol) return s.col === col;
    return s.row === row && s.col === col;
  });

  const isDestination = highlight.destinations?.some(d => {
    if (d.name !== name || d.isInternal) return false;
    if (d.highlightRow) return d.row === row;
    if (d.highlightCol) return d.col === col;
    return d.row === row && d.col === col;
  });

  const classNames = ['matrix-element'];
  if (isTarget) classNames.push('target');
  if (isSource) classNames.push('source');
  if (isDestination) classNames.push('destination');
  if (isProbMax) classNames.push('prob-max');

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({ name, row, col }, event);
  };

  const displayValue = () => {
      if (value === -Infinity) return '-∞';
      if (value === Infinity) return '+∞';
      return value.toFixed(2);
  }

  return (
    <div className={classNames.join(' ')} onClick={handleClick}>
      {displayValue()}
    </div>
  );
});
// END OF FILE: src/components/Element.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/ElementwiseCalculation.tsx
================================================================================

// FILE: src/components/ElementwiseCalculation.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier, HighlightState } from '../types';
import { getVisibleIndices, ELLIPSIS } from '../../../utils/matrixView';

interface ElementwiseCalculationProps {
  opType: 'softmax' | 'relu';
  inputRow: number[];
  outputRow: number[];
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  baseName: string; // e.g., "encoder.0.mha.h0.AttentionWeights"
  rowIndex: number;
}

const formatNumber = (num: number, precision = 2) => num.toFixed(precision);

export const ElementwiseCalculation: React.FC<ElementwiseCalculationProps> = ({
  opType,
  inputRow,
  outputRow,
  highlight,
  onElementClick,
  baseName,
  rowIndex,
}) => {
  const targetCol = highlight.target?.isInternal && highlight.target.row === rowIndex ? highlight.target.col : -1;
  const visibleCols = getVisibleIndices(inputRow.length, targetCol);

  const handleClick = (event: React.MouseEvent, colIndex: number) => {
    onElementClick({
      name: `${baseName}.internal`, // Special name for internal calculation
      row: rowIndex,
      col: colIndex,
      isInternal: true,
    }, event);
  };

  const isSource = (colIndex: number) => {
      return highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === colIndex);
  }
  const isTarget = (colIndex: number) => {
      return highlight.target?.isInternal && highlight.target.row === rowIndex && highlight.target.col === colIndex;
  }


  const renderVisibleElements = (data: (number | string)[], type: 'input' | 'output' | 'exp' | 'sum') => {
    return visibleCols.map((col, i) => {
      if (col === ELLIPSIS) {
        return <div key={`ellipsis-${i}`} className="elementwise-op-element symbolic-ellipsis">...</div>;
      }
      const value = data[col];
      const className = `elementwise-op-element ${isSource(col) ? 'source' : ''} ${isTarget(col) ? 'target' : ''}`;
      return (
        <div key={`${type}-${col}`} className={className} onClick={(e) => handleClick(e, col)}>
          {typeof value === 'number' ? formatNumber(value) : value}
        </div>
      );
    });
  };

  const renderSoftmax = () => {
    const maxVal = Math.max(...inputRow);
    const exps = inputRow.map(val => Math.exp(val - maxVal));
    const sumExps = exps.reduce((a, b) => a + b, 0);

    const fullSumIsSource = highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === -1); // -1 indicates whole row/sum

    return (
      <>
        {/* Step 1: exp(x - max(x)) */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(x_i - \text{max}(\mathbf{x}))" /></div>
          <div className="elementwise-op-row">
            {renderVisibleElements(exps.map(v => Number(formatNumber(v, 4))), 'exp')}
          </div>
        </div>
        {/* Step 2: Sum */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\sum \text{exp}(\dots)" /></div>
          <div className={`elementwise-op-element sum ${fullSumIsSource ? 'source' : ''}`} onClick={(e) => handleClick(e, -1)}>
            {formatNumber(sumExps, 4)}
          </div>
        </div>
        {/* Step 3: Division */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(\dots) / \sum" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };

  const renderReLU = () => {
    return (
      <>
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{max}(0, x_i)" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };


  return (
    <div className="elementwise-calc-container">
        {opType === 'softmax' ? renderSoftmax() : renderReLU()}
    </div>
  );
};
// END OF FILE: src/components/ElementwiseCalculation.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/ElementwiseOperation.tsx
================================================================================

// FILE: src/components/ElementwiseOperation.tsx
import React from 'react';
import { Matrix, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { ElementwiseCalculation } from './ElementwiseCalculation';

interface ElementwiseOperationProps {
    opType: 'softmax' | 'relu';
    inputMatrix: Matrix;
    inputMatrixName: string; // [FIXED] Added required prop
    outputMatrix: Matrix;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    layerIndex: number;
    headIndex?: number;
}

export const ElementwiseOperation: React.FC<ElementwiseOperationProps> = ({
    opType,
    inputMatrix,
    inputMatrixName, // [FIXED] Destructure prop
    outputMatrix,
    outputMatrixName,
    highlight,
    onElementClick,
    layerIndex,
    headIndex,
}) => {
    let targetRowIndex = 0;

    // [FIXED] Use the passed inputMatrixName for correct highlight detection
    if (highlight.target) {
        if (highlight.target.name === inputMatrixName || highlight.target.name === outputMatrixName) {
            targetRowIndex = highlight.target.row;
        } else if (highlight.target.isInternal && highlight.target.name.startsWith(outputMatrixName)) {
            targetRowIndex = highlight.target.row;
        }
    }

    const inputRow = inputMatrix[targetRowIndex] || [];
    const outputRow = outputMatrix[targetRowIndex] || [];

    const opName = opType.charAt(0).toUpperCase() + opType.slice(1);
    const opFunction = opType === 'relu' ? 'max(0, x)' : 'softmax(x_i)';

    return (
        <div className="elementwise-op-container">
            <div className="elementwise-op-label">
                <InlineMath math={`\\text{Detailed Calculation: } ${opName}(x_i) = ${opFunction}`} />
            </div>
            <p style={{margin: '0', fontSize: '0.8em', color: '#666'}}>* Showing calculation for Row {targetRowIndex}</p>
            <ElementwiseCalculation
                opType={opType}
                inputRow={inputRow}
                outputRow={outputRow}
                highlight={highlight}
                onElementClick={onElementClick}
                baseName={outputMatrixName}
                rowIndex={targetRowIndex}
            />
        </div>
    );
};
// END OF FILE: src/components/ElementwiseOperation.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/EmbeddingLookup.tsx
================================================================================

// FILE: src/components/EmbeddingLookup.tsx
import React, { useRef, useEffect, useState } from 'react';
import { TransformerData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { Token } from './Token';

interface EmbeddingLookupProps {
    mode: 'token-to-vector' | 'id-to-token';
    tokens: ElementIdentifier[];
    embeddingMatrix: MatrixType;
    matrixName: string;
    vocab?: TransformerData['vocab']; // For id-to-token mode
    outputVectors?: MatrixType; // For token-to-vector mode
    outputMatrixName?: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    shouldBreak: boolean; // [ADDED] Prop to control layout
}

export const EmbeddingLookup: React.FC<EmbeddingLookupProps> = ({
    mode,
    tokens,
    embeddingMatrix,
    matrixName,
    vocab,
    outputVectors,
    outputMatrixName,
    highlight,
    onElementClick,
    shouldBreak,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [lines, setLines] = useState<any[]>([]);

    useEffect(() => {
        const calculateLines = () => {
            if (!containerRef.current) return;

            const newLines: any[] = [];
            const tokenElements = Array.from(containerRef.current.querySelectorAll('.token-container'));
            const matrixRowElements = Array.from(containerRef.current.querySelectorAll(`.matrix-grid[data-name="${matrixName}"] .matrix-element`));
            const outputElements = Array.from(containerRef.current.querySelectorAll(mode === 'token-to-vector' ? `.matrix-wrapper[data-name="${outputMatrixName}"]` : '.token-container.output-token'));

            const matrixGridEl = containerRef.current.querySelector(`.matrix-wrapper[data-name="${matrixName}"]`);
            if (!matrixGridEl) return;
            const matrixRect = matrixGridEl.getBoundingClientRect();
            const containerRect = containerRef.current.getBoundingClientRect();

            tokens.forEach((token, index) => {
                const tokenId = token.tokenId!;
                const isHighlighted = highlight.sources.some(s => s.name === 'inputToken' && s.row === index) ||
                                      highlight.target?.name === 'inputToken' && highlight.target?.row === index ||
                                      highlight.sources.some(s => s.name === 'outputProbabilities' && s.row === index) ||
                                      highlight.target?.name === 'outputToken' && highlight.target?.row === index;

                const tokenEl = tokenElements[index];

                // Find the corresponding matrix row element (might be virtualized)
                // Added null check for containerRef.current here to satisfy TypeScript
                const matrixRowEl = containerRef.current?.querySelector(`.matrix-element[data-row="${tokenId}"]`);
                const outputEl = outputElements[index];

                if (tokenEl && matrixRowEl && outputEl) {
                    const tokenRect = tokenEl.getBoundingClientRect();
                    const matrixRowRect = matrixRowEl.getBoundingClientRect();
                    const outputRect = outputEl.getBoundingClientRect();

                    let path1, path2;

                    if (shouldBreak) { // Vertical layout paths
                        const startX1 = tokenRect.left + tokenRect.width / 2 - containerRect.left;
                        const startY1 = tokenRect.bottom - containerRect.top;
                        const endX1 = matrixRect.left + matrixRect.width / 2 - containerRect.left;
                        const endY1 = matrixRect.top - containerRect.top;
                        path1 = `M ${startX1} ${startY1} C ${startX1} ${startY1 + 40} ${endX1} ${endY1 - 40} ${endX1} ${endY1}`;

                        const startX2 = endX1;
                        const startY2 = matrixRect.bottom - containerRect.top;
                        const endX2 = outputRect.left + outputRect.width / 2 - containerRect.left;
                        const endY2 = outputRect.top - containerRect.top;
                        path2 = `M ${startX2} ${startY2} C ${startX2} ${startY2 + 40} ${endX2} ${endY2 - 40} ${endX2} ${endY2}`;
                    } else { // Horizontal layout paths
                        const startX1 = tokenRect.right - containerRect.left;
                        const startY1 = tokenRect.top + tokenRect.height / 2 - containerRect.top;
                        const endX1 = matrixRect.left - containerRect.left;
                        const endY1 = matrixRowRect.top + matrixRowRect.height / 2 - containerRect.top;
                        path1 = `M ${startX1} ${startY1} C ${startX1 + 50} ${startY1} ${endX1 - 50} ${endY1} ${endX1} ${endY1}`;

                        const startX2 = matrixRect.right - containerRect.left;
                        const startY2 = endY1; // Same Y as the matrix row
                        const endX2 = outputRect.left - containerRect.left;
                        const endY2 = outputRect.top + outputRect.height / 2 - containerRect.top;
                        path2 = `M ${startX2} ${startY2} C ${startX2 + 50} ${startY2} ${endX2 - 50} ${endY2} ${endX2} ${endY2}`;
                    }

                    newLines.push({ id: `line-${index}`, path1, path2, highlighted: isHighlighted });
                }
            });
            setLines(newLines);
        };
        calculateLines();
        const resizeObserver = new ResizeObserver(calculateLines);
        if (containerRef.current) {
            resizeObserver.observe(containerRef.current);
        }
        return () => resizeObserver.disconnect();
    }, [highlight, tokens, matrixName, outputMatrixName, mode, shouldBreak]);


    return (
        <div className={`embedding-lookup-container ${shouldBreak ? 'vertical' : ''}`} ref={containerRef}>
            <svg className="embedding-lookup-svg">
                {lines.map(line => (
                    <React.Fragment key={line.id}>
                        <path d={line.path1} className={line.highlighted ? 'highlighted' : ''} />
                        <path d={line.path2} className={line.highlighted ? 'highlighted' : ''} />
                    </React.Fragment>
                ))}
            </svg>

            {/* Input Column */}
            <div className="embedding-lookup-column">
                {tokens.map((token, i) => (
                    mode === 'token-to-vector'
                        ? <Token key={i} tokenStr={token.tokenStr!} tokenId={token.tokenId!} position={i} name={token.name} highlight={highlight} onElementClick={onElementClick} />
                        : <div key={i} style={{height: '59px', display: 'flex', alignItems: 'center', fontFamily: 'monospace'}}>ID: {token.tokenId}</div> // Placeholder for IDs
                ))}
            </div>

            {shouldBreak && <div className="arrow-down">↓</div>}

            {/* Vocabulary Matrix Column */}
            <div className="embedding-lookup-vocab" data-name={matrixName}>
                 <Matrix name={matrixName} data={embeddingMatrix} highlight={highlight} onElementClick={onElementClick} />
            </div>

            {shouldBreak && <div className="arrow-down">↓</div>}

            {/* Output Column */}
            <div className="embedding-lookup-column">
                 {mode === 'token-to-vector' && outputVectors && outputMatrixName ? (
                    <Matrix name={outputMatrixName} data={outputVectors} highlight={highlight} onElementClick={onElementClick} />
                 ) : (
                    tokens.map((token, i) => (
                         <Token key={i} tokenStr={token.tokenStr!} tokenId={token.tokenId!} position={i} name={token.name} highlight={highlight} onElementClick={onElementClick} />
                    ))
                 )}
            </div>
        </div>
    );
};
// END OF FILE: src/components/EmbeddingLookup.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/EncoderDecoderAttention.tsx
================================================================================

// FILE: src/components/EncoderDecoderAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface EncDecAttentionProps {
    baseName: string; // e.g., decoder.0.enc_dec_mha
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    finalEncoderOutput: MatrixType; // [ADDED]
}

export const EncoderDecoderAttention: React.FC<EncDecAttentionProps> = ({ baseName, data, highlight, onElementClick, onComponentClick, finalEncoderOutput }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Assume we visualize head 0
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'enc_dec_mha';
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.encDecMhaHead(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        if (numHeads > 2) {
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.encDecMhaHead(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.encDecMhaHead(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('enc_dec_mha')}>Encoder-Decoder Attention</div>
            <div className="component-body">
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Prepare Inputs</div>
                     <div className="viz-formula-row">
                        <div style={{display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px'}}>
                           <span style={{fontWeight: 'bold'}}>Q Input (from Decoder)</span>
                           <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).add_norm_1_output} data={finalEncoderOutput} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                        <div style={{display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px'}}>
                           <span style={{fontWeight: 'bold'}}>K & V Input (from Encoder)</span>
                           <Matrix name={MATRIX_NAMES.finalEncoderOutput} data={finalEncoderOutput} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Generate Q, K, V (Head 1)</div>
                     <div className="viz-formula-row">
                       <span>(Q Input) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(K Input) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(V Input) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Scaled Dot-Product Attention (Head 1)</div>
                     <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        inputMatrixName={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).ScaledScores}
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">4. Concat & Final Projection</div>
                     <div className="viz-formula-row">
                        {renderConcatHeads()}
                     </div>
                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).Wo_enc_dec} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).enc_dec_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/EncoderDecoderAttention.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/EncoderLayer.tsx
================================================================================

// FILE: src/components/EncoderLayer.tsx
import React from 'react';
import { EncoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { MultiHeadAttention } from './MultiHeadAttention';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../config/symbolMapping';
import { Matrix } from './Matrix';

interface EncoderLayerProps {
  layerIndex: number;
  data: EncoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  onComponentClick: (componentId: string) => void;
}

export const EncoderLayer: React.FC<EncoderLayerProps> = ({ layerIndex, data, highlight, onElementClick, onComponentClick }) => {
  const baseName = `encoder.${layerIndex}`;
  const LN = MATRIX_NAMES.layer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.encoder_input);
  const dimsRes1 = `${data.encoder_input.length}x${data.encoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  return (
    <div className="encoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#e3f2fd', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#e3f2fd'}}>编码器层 (Encoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- MHA Sub-layer with Residual Connection --- */}
                <ResidualBlock id={`res-l${layerIndex}-1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MultiHeadAttention
                    baseName={`${baseName}.mha`}
                    data={data.mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.encoder_input}
                    residualInputName={LN.encoder_input}
                    inputSublayer={data.mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_1"
                    residualId={`res-l${layerIndex}-1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />

                {/* --- FFN Sub-layer with Residual Connection --- */}
                <div className="arrow-down">↓</div>
                <ResidualBlock id={`res-l${layerIndex}-2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_1_output}
                    inputName={LN.add_norm_1_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
                <AddNorm
                    residualInput={data.add_norm_1_output}
                    residualInputName={LN.add_norm_1_output}
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    activeId="add_norm_2"
                    residualId={`res-l${layerIndex}-2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />

            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/EncoderLayer.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Explanation.tsx
================================================================================

// FILE: src/components/Explanation.tsx
import React from 'react';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import { InteractiveSymbolicVector } from './InteractiveSymbolicVector';
import { HighlightState, ElementIdentifier } from '../types';
import { MATRIX_NAMES } from '../config/matrixNames';

interface ExplanationProps {
    dims: { d_model: number; h: number, n_layers: number, d_ff: number, encoder_seq_len: number, decoder_seq_len: number, vocab_size: number };
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

interface MathBlockProps {
    id: string;
    title: string;
    children: React.ReactNode;
    highlight: HighlightState;
}

const MathBlock: React.FC<MathBlockProps> = ({ id, title, children, highlight }) => {
    const isActive = highlight.activeComponent === id;
    return (
        <div id={`math_${id}`} className={`math-block ${isActive ? 'active' : ''}`}>
            <h3>{title}</h3>
            {children}
        </div>
    );
};

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight, onSymbolClick }) => {
    const LNe = MATRIX_NAMES.layer(0);
    const FinalLNe = MATRIX_NAMES.layer(dims.n_layers - 1);
    const HNe = MATRIX_NAMES.head(0, 0);
    const LNd = MATRIX_NAMES.decoderLayer(0);
    const FinalLNd = MATRIX_NAMES.decoderLayer(dims.n_layers - 1);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(0, 0);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(0, 0);
    const d_k = dims.d_model / dims.h;

    const shouldBreakAddNorm = dims.d_model > 8;
    const shouldBreakMhaProj = dims.d_model > 8;
    const shouldBreakFFN1 = dims.d_model + dims.d_ff > 8;
    const shouldBreakFFN2 = dims.d_ff + dims.d_model > 8;
    const shouldBreakFinalOutput = dims.d_model + dims.vocab_size > 8;

    // [FIXED] Specific breaking logic for Enc-Dec Attention
    const shouldBreakEncDecScores = d_k + dims.encoder_seq_len > 8;
    const shouldBreakEncDecHeadOutput = dims.encoder_seq_len + d_k > 8;


    return (
        <div>
            <div className="math-block">
                <h3>Transformer 架构概览</h3>
                <p>Transformer 模型由两个核心部分组成:<b>编码器 (Encoder)</b> 和 <b>解码器 (Decoder)</b>. 编码器的任务是“理解”输入的整个句子(例如,"I am a student"),并将其转化为一组富含上下文信息的数字表示. 解码器的任务是利用这些数字表示,并结合已经生成的内容,一次一个词地生成目标句子(例如,“我 是 一个 学生”). </p>
                <p>在2017年的原始论文《Attention Is All You Need》中,编码器和解码器都由 N 个相同的层堆叠而成. 此可视化工具将带您深入探索其内部的数据流动和数学原理. </p>
            </div>

            {/* --- ENCODER EXPLANATIONS --- */}
            <h2 style={{textAlign: 'center', margin: '30px 0'}}>编码器 (Encoder)</h2>
             <MathBlock id="token_embed" title="编码器第0步:分词与词嵌入" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将您在上方控件中输入的自然语言文本,转换为模型可以处理的数值矩阵. 这是所有后续计算的起点. </p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>分词 (Tokenization):</b> 使用简单的空格分词器,将输入句子分解为一个个独立的词元(Token). </li>
                    <li><b>ID映射 (ID Mapping):</b> 使用一个预先构建好的词汇表(Vocabulary),将每个词元映射到一个唯一的整数ID. 任何未知的词汇都会被映射为 <code>[UNK]</code> (Unknown). </li>
                    <li><b>词嵌入 (Embedding Lookup):</b> 使用一个巨大的、可学习的“查询表”(Embedding Matrix),根据每个词元的ID,从中“提取”出对应的向量. 这个向量就是该词元的初始数值表示. </li>
                </ol>
                <h5>深入理解:从文本到向量的“魔法”</h5>
                <p>您可能会问:“一个词(比如'student')是如何变成一长串数字(向量)的？” 关键在于那块巨大的 <b>词嵌入矩阵 (Embedding Matrix)</b>. </p>
                <p>您可以把这个矩阵想象成一本**模型在训练中自己学会编写的“超级词典”**:</p>
                <ul>
                    <li><b>词条编号 (Token ID):</b> 词汇表中的每个词都有一个独一无二的ID,比如 `student` 的ID是 `6`. 这就像是词典里的页码或词条号. </li>
                    <li><b>词条释义 (Embedding Vector):</b> 矩阵中**第 `6` 行**的那一整行向量,就是 `student` 这个词的“释义”. 这个释义不是用人类语言写的,而是用一串数字(例如一个长度为 {dims.d_model} 的向量)来定义的. 这个向量捕捉了 `student` 这个词的丰富语义信息——它和 `school`、`learn` 在语义空间中比较接近,但和 `apple`、`sky` 比较疏远. </li>
                </ul>
                <p>所以,整个过程并不是“计算”出一个向量,而是一个高效的**“查词典”**的过程. 模型通过海量数据的训练,学会了如何为每个词编写最精准的、富含信息的“数字释义”,我们在这里只是根据ID去查询而已. </p>
            </MathBlock>
            <MathBlock id="input_embed" title="编码器第1步:输入预处理" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将输入的文本序列(一串文字)转换为模型可以处理的、包含“词义”和“位置”信息的数值向量矩阵. 当前输入序列长度为 {dims.encoder_seq_len},模型维度 <InlineMath math={`d_{model}=${dims.d_model}`}/>. </p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>词嵌入 (Token Embedding):</b> 从上一步获得的矩阵,代表了每个词的“词义”. </li>
                    <li><b>位置编码 (Positional Encoding):</b> 为模型注入关于序列顺序的绝对位置信息. 这是一个固定的、根据三角函数生成的矩阵. </li>
                    <li><b>逐元素相加:</b> 得到编码器最终的输入表示 <InlineMath math="Z"/>. </li>
                </ol>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.inputEmbeddings} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.posEncodings} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="mha" title="编码器子层1:多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此机制的核心目的是计算句子中每个词与其他所有词的“关注度”或“相关性”,并根据这个关注度重新计算每个词的向量表示,从而让每个词的向量都融入其上下文信息. </p>
                <h5>输入矩阵 (Input Matrix)</h5>
                <div className="formula-display">
                    <InlineMath math="\text{Input} = " />
                    <InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false} />
                </div>
                <h5>计算流程 (以单个注意力头为例)</h5>
                 <p>输入矩阵 <InlineMath math="Z"/> 被并行地送入 {dims.h} 个独立的注意力头. 每个头都拥有三块自己专属、可学习的权重矩阵. 通过矩阵乘法,将输入 <InlineMath math="Z"/> 投影到三个新的矩阵:查询 (Query, <InlineMath math="Q"/>), 键 (Key, <InlineMath math="K"/>), 和 值 (Value, <InlineMath math="V"/>). </p>
                <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.Q} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>然后计算注意力分数, 进行缩放和Softmax得到权重, 最后加权求和. </p>
                <BlockMath math={`A = \\text{Softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)`} />
                <BlockMath math={`H = A V`} />
                 <div className="formula-display vertical">
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={HNe.AttentionWeights} rows={dims.encoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNe.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNe.HeadOutput} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <h5>拼接与最终投影</h5>
                <p>将所有 {dims.h} 个头的输出矩阵 <InlineMath math="H_i"/> 拼接 (Concatenate) 起来, 然后通过一个最终的投影权重矩阵 <InlineMath math="W^O"/> 得到该子层的最终输出 <InlineMath math="M"/>. </p>
                 <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNe.Wo} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNe.mha_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_1" title="组件:残差连接与层归一化 (1)" highlight={highlight}>
                <p>在每个子层之后,都会跟随一个“Add & Norm”模块. 它包含两个关键步骤:<b>残差连接</b>将子层的输入与输出直接相加,缓解梯度消失;<b>层归一化</b>则稳定训练过程. </p>
                <BlockMath math={`Z' = \\text{LayerNorm}(Z + \\text{MultiHeadAttention}(Z))`} />
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.mha_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="ffn" title="编码器子层2:位置前馈网络" highlight={highlight}>
                <p>前馈网络 (FFN) 对每个位置的向量独立地进行一次复杂的非线性变换,极大地增加了模型的表达能力. </p>
                <BlockMath math={`F = \\text{ReLU}(Z' W_1 + b_1) W_2 + b_2`} />
                <h5>第一次线性变换 & ReLU</h5>
                <div className={`formula-display ${shouldBreakFFN1 ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNe.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                 <div className="formula-display vertical">
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Intermediate} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Activated} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                <h5>第二次线性变换</h5>
                <div className={`formula-display ${shouldBreakFFN2 ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Activated} rows={dims.encoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.W2} rows={dims.d_ff} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNe.b2} data={Array(dims.d_model).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="="/>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.ffn_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_2" title="组件:残差连接与层归一化 (2)" highlight={highlight}>
                <p>与第一个 "Add & Norm" 层完全相同,此步骤将 FFN 子层的输出与输入结合,产生该编码器层的最终输出. </p>
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.ffn_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_2_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>

            {/* --- DECODER EXPLANATIONS --- */}
            <h2 style={{textAlign: 'center', margin: '30px 0'}}>解码器 (Decoder)</h2>
            <MathBlock id="output_embed" title="解码器第1步:输出预处理" highlight={highlight}>
                 <h5>做什么？</h5>
                <p>此步骤与编码器输入预处理类似,但作用于目标语言序列(即解码器要生成的内容). 它将目标序列(通常是已经生成的词加上一个起始符)转换为模型可以处理的数值向量矩阵. </p>
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputEmbeddings} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.decoderPosEncodings} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.decoder_input} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="masked_mha" title="解码器子层1:带掩码的多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是解码器的第一个关键子层. 它与编码器的自注意力机制几乎完全相同,但有一个至关重要的区别:<b>前瞻遮罩 (Look-Ahead Mask)</b>. </p>
                <h5>设计思路</h5>
                <p>在生成任务中,模型在预测第 <code>i</code> 个词时,只能看到第 <code>i</code> 个词之前(包括第 <code>i</code> 个词)的内容,绝不能“偷看”未来的词. 为了在并行的矩阵运算中实现这一点,我们在计算注意力分数后,会应用一个遮罩. 这个遮罩将分数矩阵 <InlineMath math="S"/> 的上三角部分(代表未来位置)设置为一个非常大的负数(-∞). 这样,在经过 Softmax 运算后,这些位置的注意力权重将变为0,从而确保了模型无法关注未来的信息. </p>
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_masked.Scores} rows={dims.decoder_seq_len} cols={dims.decoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math={`\\xrightarrow{\\text{Mask}}`} />
                    <p>上三角区域被设为-∞</p>
                </div>
                 <h5>计算流程</h5>
                <p>除了应用掩码外,后续计算与编码器自注意力完全相同.</p>
                <BlockMath math={`H = \\text{Softmax}\\left(\\text{Mask}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)\\right) V`} />
                 <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNd.Wo_masked} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNd.masked_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_1_dec" title="解码器组件:残差连接与层归一化 (1)" highlight={highlight}>
                <p>此模块接收解码器输入 <InlineMath math="Y"/> 和带掩码自注意力子层的输出 <InlineMath math="M_{mmha}"/>,将它们相加后进行层归一化. </p>
                <BlockMath math={`Y' = \\text{LayerNorm}(Y + \\text{Masked-MHA}(Y))`} />
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.decoder_input} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.masked_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
             <MathBlock id="enc_dec_mha" title="解码器子层2:编码器-解码器注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是连接编码器和解码器的桥梁,也是 Transformer 架构的精髓所在. 在这一层,解码器会“审视”编码器的全部输出,并判断输入序列中的哪些部分对于生成当前目标词最重要. </p>
                 <h5>输入矩阵</h5>
                 <div className="formula-display vertical">
                    <div>
                        <p style={{textAlign: 'center', marginBottom: '5px'}}>Query Input (from Decoder):</p>
                        <InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false}/>
                    </div>
                     <div style={{marginTop: '15px'}}>
                        <p style={{textAlign: 'center', marginBottom: '5px'}}>Key/Value Input (from Encoder):</p>
                        <InteractiveSymbolicMatrix name={FinalLNe.add_norm_2_output} rows={dims.encoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} truncate={false}/>
                    </div>
                 </div>
                 <h5>计算流程 (以单个注意力头为例)</h5>
                <ol>
                    <li><b>Query (<InlineMath math="Q"/>)</b>: 来自解码器前一层的输出 (<InlineMath math="Y'"/>). 它代表了“我当前需要什么信息来生成下一个词？”</li>
                    <li><b>Key (<InlineMath math="K"/>) 和 Value (<InlineMath math="V"/>)</b>: <b>均来自编码器的最终输出 (<InlineMath math="Z_{final}"/>)</b>. 它们代表了整个输入序列的上下文信息. </li>
                </ol>
                 <div className="formula-display vertical">
                    <div className="viz-formula-row"><InlineMath math="Y'" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z_{final}" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wk} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <div className="viz-formula-row"><InlineMath math="Z_{final}" /><BlockMath math="\times" /><InteractiveSymbolicMatrix name={HNd_encdec.Wv} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /><BlockMath math="=" /><InteractiveSymbolicMatrix name={HNd_encdec.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>通过计算 <InlineMath math="Q_{dec} \cdot K_{enc}^T"/>,解码器能够评估其当前的生成需求与输入序列中每个词的相关性,然后利用这个相关性(注意力权重)从 <InlineMath math="V_{enc}"/> 中加权提取最需要的信息来辅助生成. </p>
                {/* [FIXED] Added missing formulas for enc-dec attention */}
                <h5>注意力计算与输出</h5>
                <div className={`formula-display ${shouldBreakEncDecScores ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.Q} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.K} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} transpose={true}/></div>
                    <BlockMath math="\xrightarrow{\text{Scale + Softmax}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.AttentionWeights} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                 <div className={`formula-display ${shouldBreakEncDecHeadOutput ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.AttentionWeights} rows={dims.decoder_seq_len} cols={dims.encoder_seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.V} rows={dims.encoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_encdec.HeadOutput} rows={dims.decoder_seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                 <div className={`formula-display ${shouldBreakMhaProj ? 'vertical' : ''}`}>
                    <InlineMath math="\text{Concat}(H_0, ..., H_{h-1})" />
                    <BlockMath math="\times" />
                    <InteractiveSymbolicMatrix name={LNd.Wo_enc_dec} rows={dims.d_model} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                    <BlockMath math="=" />
                    <InteractiveSymbolicMatrix name={LNd.enc_dec_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} />
                </div>
            </MathBlock>
            <MathBlock id="add_norm_2_dec" title="解码器组件:残差连接与层归一化 (2)" highlight={highlight}>
                <p>此步骤结合了编码器-解码器注意力子层的输入 (<InlineMath math="Y'"/>) 与其输出 (<InlineMath math="M_{ed}"/>),并进行层归一化,以稳定训练过程并融合来自编码器的信息. </p>
                 <BlockMath math={`Y'' = \\text{LayerNorm}(Y' + \\text{Enc-Dec-MHA}(Y', Z_{final}))`} />
                  <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_1_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.enc_dec_mha_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="ffn_dec" title="解码器子层3:前馈网络" highlight={highlight}>
                <p>与编码器中的 FFN 类似,解码器中的前馈网络 (FFN) 也对每个位置的向量 (<InlineMath math="Y''"/>) 独立地进行一次复杂的非线性变换,进一步增强模型的表达能力,为最终的输出预测做准备. </p>
                <BlockMath math={`F = \\text{ReLU}(Y'' W_1 + b_1) W_2 + b_2`} />
                 <div className="formula-display vertical">
                     <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times"/>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="+"/>
                    <div className="viz-formula-row"><InteractiveSymbolicVector name={LNd.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="viz-formula-row"><InteractiveSymbolicMatrix name={LNd.Activated} rows={dims.decoder_seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_3_dec" title="解码器组件:残差连接与层归一化 (3)" highlight={highlight}>
                 <p>这是解码器层中的最后一个 Add & Norm 步骤,它将 FFN 的输入 (<InlineMath math="Y''"/>) 与其输出 (<InlineMath math="F"/>) 相结合,产生该解码器层的最终输出 <InlineMath math="Y_{final}"/>. </p>
                 <BlockMath math={`Y_{final} = \\text{LayerNorm}(Y'' + \\text{FFN}(Y''))`} />
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.ffn_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_3_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
             <MathBlock id="final_output" title="最终输出层:线性层与Softmax" highlight={highlight}>
                <h5>做什么？</h5>
                <p>在经过所有解码器层的处理后,我们得到一个最终的输出矩阵. 此步骤将其转换为每个位置上词汇表中所有单词的概率分布. </p>
                 <h5>计算流程</h5>
                <ol>
                    <li><b>线性层 (Linear Layer):</b> 将解码器输出矩阵通过一个大的线性投影层,将其维度从 <InlineMath math="d_{model}"/> 扩展到词汇表大小 (<InlineMath math="V_{size}"/>). 这会为每个位置生成一个分数向量,称为 Logits. </li>
                    <li><b>Softmax:</b> 对 Logits 矩阵的每一行应用 Softmax 函数,将其转换为概率分布. </li>
                </ol>
                 <div className={`formula-display ${shouldBreakFinalOutput ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={FinalLNd.add_norm_3_output} rows={dims.decoder_seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.finalLinear} rows={dims.d_model} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                 </div>
                 <div className="formula-display">
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.logits} rows={dims.decoder_seq_len} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\xrightarrow{\text{Softmax}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputProbabilities} rows={dims.decoder_seq_len} cols={dims.vocab_size} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
                 <p>现在,矩阵 <InlineMath math="P"/> 中的每一行都是一个概率分布,代表了在那个位置上生成词汇表中任何一个单词的可能性. </p>
            </MathBlock>
            <MathBlock id="decoding" title="最终解码:Argmax 与文本生成" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是生成过程的最后一步,将代表概率的数字变回人类可读的文本. </p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>Argmax:</b> 对概率矩阵 <InlineMath math="P"/> 的每一行,找到其中概率值最大的那个元素的<b>索引 (index)</b>. 这个索引就对应了词汇表中该位置最有可能的词元ID. 这个过程通常被称为“贪心解码 (Greedy Decoding)”. </li>
                    <li><b>ID到文本映射:</b> 将得到的词元ID序列,通过反向查询词汇表,映射回原始的文本词元. </li>
                </ol>
                <h5>深入理解:从向量到文本的“翻译”</h5>
                <p>这里是“魔法”发生逆转的地方. 我们手上有一个 <b>概率矩阵</b> <code>P</code>,它告诉我们在每个输出位置上,词汇表里每个单词的可能性. </p>
                <p>以第一个输出位置为例,我们关注矩阵 <code>P</code> 的<b>第一行</b> (下标为0的那一行). 这一行是一个概率向量,其长度等于整个词汇表的大小. 向量中第 <code>j</code> 个位置的数值,就代表词汇表中 ID 为 <code>j</code> 的单词是正确答案的概率. </p>
                <p><b>Argmax</b> 函数的作用非常简单:它会扫描这一整行,找到那个最大的概率值,然后返回它的<b>位置索引</b>. 这个索引就是模型预测出的 <b>Token ID！</b></p>
                <p>最后一步,我们拿着这个ID,去反查我们的“超级词典”(词汇表),就能找到ID对应的单词. 于是,模型就成功地将一串概率数字“翻译”回了人类能懂的单词. 对每一行都重复这个过程,就能生成整个句子. </p>
            </MathBlock>
        </div>
    );
};
// END OF FILE: src/components/Explanation.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/FeedForward.tsx
================================================================================

// FILE: src/components/FeedForward.tsx
import React from 'react';
import { FFNData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface FFNProps {
    baseName: string;
    input: MatrixType;
    inputName: string;
    data: FFNData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const FeedForward: React.FC<FFNProps> = ({ baseName, input, inputName, data, highlight, onElementClick, onComponentClick }) => {
    const isEncoder = baseName.includes('encoder');
    const componentId = isEncoder ? 'ffn' : 'ffn_dec';
    const isActive = highlight.activeComponent === componentId;
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const LN = isEncoder ? MATRIX_NAMES.layer(layerIndex) : MATRIX_NAMES.decoderLayer(layerIndex);

    // --- Layout Breaking Logic ---
    const inputCols1 = input[0]?.length || 0;
    const w1Cols = data.W1[0]?.length || 0;
    const breakStep1 = inputCols1 > 8 || w1Cols > 8 || (inputCols1 + w1Cols > 15);

    const activatedCols = data.Activated[0]?.length || 0;
    const w2Cols = data.W2[0]?.length || 0;
    const breakStep2 = activatedCols > 8 || w2Cols > 8 || (activatedCols + w2Cols > 15);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick(componentId)}>Feed-Forward Network</div>
            <div className="component-body">
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. First Linear Layer & ReLU</div>
                     <div className={`viz-formula-row ${breakStep1 ? 'vertical' : ''}`}>
                         <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                         <span className="op-symbol">×</span>
                         <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b1} data={[data.b1]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.Intermediate} data={data.Intermediate} highlight={highlight} onElementClick={onElementClick} />
                    </div>

                    <ElementwiseOperation
                        opType="relu"
                        inputMatrix={data.Intermediate}
                        inputMatrixName={LN.Intermediate} // [FIXED] Pass the input matrix name
                        outputMatrix={data.Activated}
                        outputMatrixName={LN.Activated}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Second Linear Layer</div>
                    <div className={`viz-formula-row ${breakStep2 ? 'vertical' : ''}`}>
                        <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                        <span className="op-symbol">×</span>
                        <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b2} data={[data.b2]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LN.ffn_output} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/FeedForward.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicElement.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicElement.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { HighlightState } from '../types';
import { useHighlighting } from '../hooks/useHighlighting';

interface InteractiveSymbolicElementProps {
  name: string; // [ADDED] Pass the full matrix name for the hook
  base: string;
  subscript?: string;
  row?: number;
  col?: number;
  highlight: HighlightState; // [ADDED] Pass the full highlight state
  onClick: (event: React.MouseEvent) => void;
}

export const InteractiveSymbolicElement: React.FC<InteractiveSymbolicElementProps> = React.memo(({ name, base, subscript, row, col, highlight, onClick }) => {
  // [MODIFIED] Centralized highlighting logic by using the new hook.
  // We handle undefined row/col for vectors.
  // [FIXED] Removed the 5th argument 'true' which caused the compilation error.
  const { isTarget, isSource, isDestination } = useHighlighting(name, row ?? 0, col ?? 0, highlight);

  const elementBase = base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
  const subscriptContent = [subscript, row, col].filter(s => s !== undefined && s !== null).join(',');
  const mathString = `${elementBase}_{${subscriptContent}}`;

  const className = `symbolic-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''} ${isDestination ? 'destination' : ''}`;

  return (
    <div className={className} onClick={onClick} style={{cursor: 'pointer'}}>
      <InlineMath math={mathString} />
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicElement.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicMatrix.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicMatrix.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../../../utils/matrixView';

interface InteractiveSymbolicMatrixProps {
  name: string;
  rows: number;
  cols: number;
  highlight: HighlightState;
  transpose?: boolean;
  truncate?: boolean; // [ADDED] New prop to control truncation
  onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const InteractiveSymbolicMatrix: React.FC<InteractiveSymbolicMatrixProps> = React.memo(({ name, rows, cols, highlight, transpose = false, truncate = true, onSymbolClick }) => {
  const displayRows = transpose ? cols : rows;
  const displayCols = transpose ? rows : cols;
  const symbol = getSymbolParts(name);

  let focusRow = -1;
  let focusCol = -1;

  if (highlight.target?.name === name) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const highlightedTarget = (highlight.target?.name === name) ? highlight.target : null;

  const visibleRowIndices = truncate ? getVisibleIndices(displayRows, transpose ? focusCol : focusRow) : Array.from({ length: displayRows }, (_, i) => i);
  const visibleColIndices = truncate ? getVisibleIndices(displayCols, transpose ? focusRow : focusCol) : Array.from({ length: displayCols }, (_, i) => i);

  const isTargetMatrix = !!highlightedTarget;

  const gridStyle: React.CSSProperties = {
      gridTemplateColumns: isTargetMatrix
          ? `auto repeat(${visibleColIndices.length}, auto)`
          : `repeat(${visibleColIndices.length}, auto)`,
  };


  let mathSymbol = symbol.base;
  if (symbol.superscript) mathSymbol += `^{${symbol.superscript}}`;
  if (transpose) mathSymbol += '^T';

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`${rows} \\times ${cols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;

  return (
    <div className="symbolic-matrix-container">
      <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
      <div className="symbolic-matrix-grid" style={gridStyle}>
        {/* Top-left corner, column headers */}
        {isTargetMatrix && <div key="corner" />}
        {isTargetMatrix && visibleColIndices.map((c, cIdx) => (
            <div key={`ch-${cIdx}`} className="symbolic-header-item">{c}</div>
        ))}

        {/* Row headers and matrix elements */}
        {visibleRowIndices.map((r, rIdx) => {
            const rowContent = visibleColIndices.map((c, cIdx) => {
                 if (r === ELLIPSIS) {
                    return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                }
                if (c === ELLIPSIS) {
                    return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
                }

                const originalRow = transpose ? c : r;
                const originalCol = transpose ? r : c;

                return (
                    <InteractiveSymbolicElement
                        key={`elem-r${r}-c${c}`}
                        name={name}
                        base={symbol.base}
                        subscript={symbol.subscript}
                        row={originalRow}
                        col={originalCol}
                        highlight={highlight}
                        onClick={(event) => onSymbolClick({ name, row: originalRow, col: originalCol }, event)}
                    />
                );
            });

            return (
                <React.Fragment key={`row-frag-${rIdx}`}>
                    {isTargetMatrix && <div className="symbolic-header-item">{r}</div>}
                    {rowContent}
                </React.Fragment>
            );
        })}
      </div>
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicMatrix.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/InteractiveSymbolicVector.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicVector.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { Vector as VectorType } from '../types';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../../../utils/matrixView';

interface InteractiveSymbolicVectorProps {
  name: string;
  data: VectorType;
  highlight: HighlightState;
  onSymbolClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const InteractiveSymbolicVector: React.FC<InteractiveSymbolicVectorProps> = React.memo(({ name, data, highlight, onSymbolClick }) => {
  const displayCols = data.length;
  const symbol = getSymbolParts(name);

  let focusCol = -1;
  if (highlight.target?.name === name) {
    focusCol = highlight.target.col;
  }

  const visibleColIndices = getVisibleIndices(displayCols, focusCol);

  const gridElements = visibleColIndices.map((c, cIdx) => {
    if (c === ELLIPSIS) {
        return <div key={`ellipsis-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
    }

    return (
        <InteractiveSymbolicElement
            key={`elem-${c}`}
            name={name}
            base={symbol.base}
            subscript={symbol.subscript}
            col={c}
            highlight={highlight}
            onClick={(event) => onSymbolClick({ name, row: 0, col: c }, event)}
        />
    );
  });

  let mathSymbol = symbol.base;

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`1 \\times ${displayCols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;


  return (
    <div className="symbolic-matrix-container">
      <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
      <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${gridElements.length}, auto)` }}>
        {gridElements}
      </div>
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicVector.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/MaskedMultiHeadAttention.tsx
================================================================================

// FILE: src/components/MaskedMultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface MHAProps {
    baseName: string; // e.g., decoder.0.masked_mha
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MaskedMultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick, onComponentClick }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Assume we visualize head 0
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'masked_mha';
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('masked_mha')}>Masked Multi-Head Attention</div>
            <div className="component-body">
                {/* Visualizations for Q, K, V generation */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={HNd_masked.Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={HNd_masked.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={HNd_masked.Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNd_masked.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={HNd_masked.Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNd_masked.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                {/* Scaled Dot-Product Attention */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={HNd_masked.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">= (Scores)</div>
                    <div className="arrow-down" style={{fontSize: '1em', color: '#e63946', fontWeight: 'bold'}}>Apply Look-Ahead Mask</div>
                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        inputMatrixName={HNd_masked.ScaledScores} // [FIXED] Pass the input matrix name
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={HNd_masked.AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="viz-formula-row">
                        <Matrix name={HNd_masked.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={HNd_masked.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={HNd_masked.HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                {/* Final Projection */}
                 <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                    <div className="viz-formula-row">
                       <InlineMath math="\text{Concat}(H_0, \dots, H_{N})" />
                     </div>
                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).Wo_masked} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).masked_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

            </div>
        </div>
    );
};
// END OF FILE: src/components/MaskedMultiHeadAttention.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Matrix.tsx
================================================================================

// FILE: src/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { getVisibleIndices, ELLIPSIS } from '../../../utils/matrixView';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
  isTransposed?: boolean;
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, isTransposed = false }) => {

  // [FIXED] Hook is now at the top level, before any returns.
  const maxProbCols = React.useMemo(() => {
    const maxCols: { [key: number]: number } = {};
    if (!data) return maxCols; // Handle invalid data gracefully

    const probSources = highlight.sources.filter(s => s.name === name && s.highlightProbCol);
    for (const source of probSources) {
        if (source.row !== -1 && data[source.row]) {
            const rowData = data[source.row];
            const maxVal = Math.max(...rowData);
            maxCols[source.row] = rowData.indexOf(maxVal);
        }
    }
    return maxCols;
  }, [highlight.sources, name, data]);

  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const numRows = data.length;
  const numCols = data[0].length;

  const displayRows = isTransposed ? numCols : numRows;
  const displayCols = isTransposed ? numRows : numCols;

  let focusRow = -1;
  let focusCol = -1;

  if(highlight.target?.name === name && !highlight.target.isInternal) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const relevantSource = highlight.sources.find(s => s.name === name && !s.isInternal);
  if (relevantSource) {
      focusRow = relevantSource.row === -1 ? focusRow : relevantSource.row;
      focusCol = relevantSource.col === -1 ? focusCol : relevantSource.col;
  }

  const relevantDestination = highlight.destinations?.find(d => d.name === name && !d.isInternal);
    if (relevantDestination) {
        focusRow = relevantDestination.row === -1 ? focusRow : relevantDestination.row;
        focusCol = relevantDestination.col === -1 ? focusCol : relevantDestination.col;
    }

  const visibleRowIndices = getVisibleIndices(displayRows, isTransposed ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, isTransposed ? focusRow : focusCol);

  const symbolParts = getSymbolParts(name);
  let mathSymbol = symbolParts.base;
  if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
  if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;
  if(isTransposed) mathSymbol = `${mathSymbol}^T`;

  const isTargetMatrix = highlight.target?.name === name && !highlight.target.isInternal;

   const gridContainerStyle: React.CSSProperties = {
      gridTemplateColumns: isTargetMatrix
          ? `auto repeat(${visibleColIndices.length}, auto)`
          : `repeat(${visibleColIndices.length}, auto)`,
  };

  return (
    <div className="matrix-wrapper" data-name={name}>
      <div className="matrix-container">
        <div className="matrix-grid" data-name={name} style={gridContainerStyle}>
            {/* Top-left corner & Column Headers */}
            {isTargetMatrix && <div key="corner" />}
            {isTargetMatrix && visibleColIndices.map((c, cIdx) => (
                <div key={`ch-${cIdx}`} className="matrix-header-item">{c}</div>
            ))}

            {/* Row Headers & Matrix Elements */}
            {visibleRowIndices.map((r, rIdx) => {
                const rowContent = visibleColIndices.map((c, cIdx) => {
                    if (r === ELLIPSIS) {
                        return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>;
                    }
                    if (c === ELLIPSIS) {
                        return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">…</div>;
                    }
                    const displayRow = r;
                    const displayCol = c;
                    const originalRow = isTransposed ? displayCol : displayRow;
                    const originalCol = isTransposed ? displayRow : displayCol;
                    const value = data[originalRow][originalCol];
                    return (
                        <Element
                            key={`${name}-${originalRow}-${originalCol}`}
                            name={name}
                            row={originalRow}
                            col={originalCol}
                            value={value}
                            highlight={highlight}
                            onElementClick={onElementClick}
                            isProbMax={maxProbCols[originalRow] === originalCol}
                        />
                    );
                });

                return (
                    <React.Fragment key={`row-frag-${rIdx}`}>
                        {isTargetMatrix && <div className="matrix-header-item">{r}</div>}
                        {rowContent}
                    </React.Fragment>
                );
            })}
        </div>
      </div>
      <div className="matrix-label-container">
        <div className="matrix-symbol-tag"><InlineMath>{mathSymbol}</InlineMath></div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Matrix.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/MultiHeadAttention.tsx
================================================================================

// FILE: src/components/MultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface MHAProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const MultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick, onComponentClick }) => {
    const headData = data.heads[0];
    const headBaseName = `${baseName}.h0`;
    const isActive = highlight.activeComponent === 'mha';

    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Visualizing head 0
    const LN = MATRIX_NAMES.layer(layerIndex);
    const HNe = MATRIX_NAMES.head(layerIndex, headIndex);
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        // First head
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.head(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);

        if (numHeads > 2) {
             // Middle ellipsis
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            // Last head
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.head(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            // Second head
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.head(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };


    // --- Layout Breaking Logic ---
    const inputCols = data.heads[0].Wq.length;
    const wqCols = headData.Wq[0]?.length || 0;
    const breakQ = inputCols > 8 || wqCols > 8 || (inputCols + wqCols > 15);

    const wkCols = headData.Wk[0]?.length || 0;
    const breakK = inputCols > 8 || wkCols > 8 || (inputCols + wkCols > 15);

    const wvCols = headData.Wv[0]?.length || 0;
    const breakV = inputCols > 8 || wvCols > 8 || (inputCols + wvCols > 15);

    const qCols = headData.Q[0]?.length || 0;
    const kTransposedCols = headData.K.length;
    const breakScores = qCols > 8 || kTransposedCols > 8 || (qCols + kTransposedCols > 15);

    const attnWeightsCols = headData.AttentionWeights[0]?.length || 0;
    const vCols = headData.V[0]?.length || 0;
    const breakHeadOutput = attnWeightsCols > 8 || vCols > 8 || (attnWeightsCols + vCols > 15);

    const headOutputCols = headData.HeadOutput[0]?.length || 0;
    const woCols = data.Wo[0]?.length || 0;
    const breakFinalProj = (headOutputCols * numHeads) > 8 || woCols > 8 || ((headOutputCols * numHeads) + woCols > 15);


    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('mha')}>Multi-Head Attention</div>
            <div className="component-body">

                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                    <div className={`viz-formula-row ${breakQ ? 'vertical' : ''}`}>
                       <span>(Input) ×</span>
                       <Matrix name={HNe.Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={HNe.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className={`viz-formula-row ${breakK ? 'vertical' : ''}`}>
                       <span>(Input) ×</span>
                       <Matrix name={HNe.Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNe.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className={`viz-formula-row ${breakV ? 'vertical' : ''}`}>
                       <span>(Input) ×</span>
                       <Matrix name={HNe.Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={HNe.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    <div className={`viz-formula-row ${breakScores ? 'vertical' : ''}`}>
                        <Matrix name={HNe.Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={HNe.K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        inputMatrixName={HNe.ScaledScores} // [FIXED] Pass the input matrix name
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={HNe.AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                        <Matrix name={HNe.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className={`viz-formula-row ${breakHeadOutput ? 'vertical' : ''}`}>
                        <Matrix name={HNe.AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={HNe.V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={HNe.HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                    <div className="viz-formula-row">
                       <InlineMath math="\text{Concat}(" />
                        {renderConcatHeads()}
                       <InlineMath math=")" />
                     </div>

                     <div className={`viz-formula-row ${breakFinalProj ? 'vertical' : ''}`}>
                       <span>(Concatenated) ×</span>
                       <Matrix name={LN.Wo} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={LN.mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/MultiHeadAttention.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/ResidualBlock.tsx
================================================================================

// FILE: src/components/ResidualBlock.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';
import { InlineMath } from 'react-katex';

interface ResidualBlockProps {
  id: string; // e.g., "res1"
  type: 'start' | 'end';
  matrixSymbol: string;
  matrixDims: string;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const ResidualBlock: React.FC<ResidualBlockProps> = ({ id, type, matrixSymbol, matrixDims, highlight, onElementClick }) => {
  const isActive = highlight.activeResidual === id;
  const isStart = type === 'start';
  const icon = isStart ? '↓' : '←'; // [MODIFIED] Changed end icon to left arrow

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({
      name: `residual.${id}.${type}`,
      row: -1,
      col: -1,
      matrixSymbol,
      matrixDims,
    }, event);
  };

  return (
    <div
      className={`residual-block ${isActive ? 'active' : ''}`}
      onClick={handleClick}
      title={`Residual Connection (${matrixSymbol})`}
    >
      <div className="residual-icon">{icon}</div>
      <div className="residual-info">
          <div className="residual-matrix-symbol"><InlineMath math={matrixSymbol} /></div>
          <div className="residual-matrix-dims">{matrixDims}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/ResidualBlock.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Token.tsx
================================================================================

// FILE: src/components/Token.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';

interface TokenProps {
  tokenStr: string;
  tokenId: number;
  position: number;
  name: string; // "inputToken" or "outputToken"
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
}

export const Token: React.FC<TokenProps> = ({
  tokenStr,
  tokenId,
  position,
  name,
  highlight,
  onElementClick,
}) => {
  const isTarget =
    highlight.target?.name === name && highlight.target?.row === position;
  const isSource = highlight.sources.some(
    (s) => s.name === name && s.row === position
  );

  const handleClick = (event: React.MouseEvent) => {
    onElementClick({ name, row: position, col: -1, tokenStr, tokenId }, event);
  };

  const className = `token-container ${isTarget ? 'target' : ''} ${
    isSource ? 'source' : ''
  }`;

  return (
    <div className={className} onClick={handleClick}>
      <div className="token-text">{tokenStr}</div>
      <div className="token-id">ID: {tokenId}</div>
    </div>
  );
};
// END OF FILE: src/components/Token.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/TokenizationEmbedding.tsx
================================================================================

// FILE: src/components/TokenizationEmbedding.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EmbeddingLookup } from './EmbeddingLookup';

interface TokenizationEmbeddingProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
    isActive: boolean;
}

export const TokenizationEmbedding: React.FC<TokenizationEmbeddingProps> = ({ data, highlight, onElementClick, onComponentClick, isActive }) => {
    // Create a list of ElementIdentifier for the input tokens
    const inputTokensForLookup: ElementIdentifier[] = data.inputText.map((token, i) => ({
        name: "inputToken",
        row: i,
        col: -1, // Not a cell in a matrix
        tokenId: data.tokenizedInput[i],
        tokenStr: token
    }));

    const shouldBreak = (data.embeddingMatrix[0]?.length || 0) > 10;

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header" onClick={() => onComponentClick('token_embed')}>Input: Tokenization & Embedding Lookup</div>
            <div className="component-body">
                <div className="viz-step-title">1. Text is tokenized, then each Token ID looks up its vector in the Embedding Matrix</div>
                <p style={{textAlign: 'center', margin: '0 0 10px 0', fontSize: '0.9em', color: '#555'}}>Click a Token to see its corresponding row in the Embedding Matrix.</p>
                <EmbeddingLookup
                    mode="token-to-vector"
                    tokens={inputTokensForLookup}
                    embeddingMatrix={data.embeddingMatrix}
                    matrixName="embeddingMatrix"
                    outputVectors={data.inputEmbeddings}
                    outputMatrixName="inputEmbeddings"
                    highlight={highlight}
                    onElementClick={onElementClick}
                    shouldBreak={shouldBreak}
                />
            </div>
        </div>
    );
};
// END OF FILE: src/components/TokenizationEmbedding.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/components/Viz.tsx
================================================================================

// FILE: src/components/Viz.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EncoderLayer } from './EncoderLayer';
import { DecoderLayer } from './DecoderLayer';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { TokenizationEmbedding } from './TokenizationEmbedding';
import { Decoding } from './Decoding';
import { MATRIX_NAMES } from '../config/matrixNames';

interface VizProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier, event: React.MouseEvent) => void;
    onComponentClick: (componentId: string) => void;
}

export const Viz: React.FC<VizProps> = ({ data, highlight, onElementClick, onComponentClick }) => {
    const isTokenEmbedActive = highlight.activeComponent === 'token_embed';
    const isInputEmbedActive = highlight.activeComponent === 'input_embed';
    const isOutputEmbedActive = highlight.activeComponent === 'output_embed';
    const isFinalOutputActive = highlight.activeComponent === 'final_output';
    const isDecodingActive = highlight.activeComponent === 'decoding';

    const cols = data.inputEmbeddings[0]?.length || 0;
    const shouldBreak = cols > 15;

    return (
        <div style={{ position: 'relative' }}>
            {/* Tooltip is now managed in App.tsx to sit on top of the entire layout */}

            {/* --- Input Stage --- */}
            <TokenizationEmbedding
                data={data}
                highlight={highlight}
                onElementClick={onElementClick}
                onComponentClick={onComponentClick}
                isActive={isTokenEmbedActive}
            />

            <div className="arrow-down">↓</div>

            {/* --- Encoder Side --- */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('input_embed')}>Positional Encoding Addition</div>
                <div className="component-body">
                    {shouldBreak ? (
                         <>
                            <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                            <div className="op-symbol">+</div>
                            <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                         </>
                    ) : (
                        <div className="viz-formula-row">
                             <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                             <div className="op-symbol">+</div>
                             <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                </div>
            </div>

            <div className="arrow-down">↓</div>

            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                 <div className="component-header" onClick={() => onComponentClick('input_embed')}>Encoder Input (<InlineMath math="Z" />)</div>
                <div className="component-body">
                     <Matrix name={MATRIX_NAMES.layer(0).encoder_input} data={data.encoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.encoderLayers.map((layer, i) => (
                <EncoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                />
            ))}

            {/* --- Decoder Side --- */}
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`} style={{marginTop: '30px'}}>
                <div className="component-header" onClick={() => onComponentClick('output_embed')}>Decoder Input & Positional Encoding</div>
                <div className="component-body">
                     <div className="viz-formula-row">
                         <Matrix name="outputEmbeddings" data={data.outputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                         <div className="op-symbol">+</div>
                         <Matrix name="decoderPosEncodings" data={data.decoderPosEncodings} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
            <div className="arrow-down">↓</div>
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('output_embed')}>Decoder Input (<InlineMath math="Y" />)</div>
                <div className="component-body">
                     <Matrix name={MATRIX_NAMES.decoderLayer(0).decoder_input} data={data.decoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.decoderLayers.map((layer, i) => (
                <DecoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    onComponentClick={onComponentClick}
                    finalEncoderOutput={data.finalEncoderOutput}
                />
            ))}

            {/* --- Final Output --- */}
            <div className="arrow-down">↓</div>
             <div className={`diagram-component ${isFinalOutputActive ? 'active' : ''}`}>
                <div className="component-header" onClick={() => onComponentClick('final_output')}>Final Linear & Softmax</div>
                <div className="component-body">
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.decoderLayer(data.decoderLayers.length - 1).add_norm_3_output} data={data.finalDecoderOutput} highlight={highlight} onElementClick={onElementClick} />
                         <div className="op-symbol">×</div>
                         <Matrix name="finalLinear" data={data.finalLinear} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">= (Logits)</div>
                    <Matrix name="logits" data={data.logits} highlight={highlight} onElementClick={onElementClick} />
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Softmax}}" /></div>
                    <Matrix name="outputProbabilities" data={data.outputProbabilities} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {/* --- Decoding Stage --- */}
            <div className="arrow-down">↓</div>
            <Decoding
                data={data}
                highlight={highlight}
                onElementClick={onElementClick}
                onComponentClick={onComponentClick}
                isActive={isDecodingActive}
            />

        </div>
    );
};
// END OF FILE: src/components/Viz.tsx


================================================================================
### 文件路径: src/topics/transformer-explorer/config/matrixNames.ts
================================================================================

// FILE: src/config/matrixNames.ts
// This file is the single source of truth for all matrix and vector names.

const generateHeadNames = (base: string) => ({
    Wq: `${base}.Wq`, Wk: `${base}.Wk`, Wv: `${base}.Wv`,
    Q: `${base}.Q`, K: `${base}.K`, V: `${base}.V`,
    Scores: `${base}.Scores`, ScaledScores: `${base}.ScaledScores`,
    AttentionWeights: `${base}.AttentionWeights`, HeadOutput: `${base}.HeadOutput`,
});

export const MATRIX_NAMES = {
    // Input
    inputEmbeddings: 'inputEmbeddings',
    posEncodings: 'posEncodings',
    encoderInput: 'encoderInput', // Deprecated, use layer(0).encoder_input
    finalEncoderOutput: 'finalEncoderOutput',

    // Encoder Layer
    layer: (layerIndex: number) => ({
        encoder_input: `encoder.${layerIndex}.encoder_input`,
        mha_output: `encoder.${layerIndex}.mha.output`,
        Wo: `encoder.${layerIndex}.mha.Wo`,
        add_norm_1_output: `encoder.${layerIndex}.add_norm_1_output`,
        W1: `encoder.${layerIndex}.ffn.W1`, b1: `encoder.${layerIndex}.ffn.b1`,
        Intermediate: `encoder.${layerIndex}.ffn.Intermediate`, Activated: `encoder.${layerIndex}.ffn.Activated`,
        W2: `encoder.${layerIndex}.ffn.W2`, b2: `encoder.${layerIndex}.ffn.b2`,
        ffn_output: `encoder.${layerIndex}.ffn.output`,
        add_norm_2_output: `encoder.${layerIndex}.add_norm_2_output`,
    }),

    // Encoder Head
    head: (layerIndex: number, headIndex: number) => generateHeadNames(`encoder.${layerIndex}.mha.h${headIndex}`),
    concatOutput: (layerIndex: number) => `encoder.${layerIndex}.mha.ConcatOutput`,

    // Decoder Input
    outputEmbeddings: 'outputEmbeddings',
    decoderPosEncodings: 'decoderPosEncodings',
    decoderInput: 'decoderInput', // Deprecated, use decoderLayer(0).decoder_input

    // Decoder Layer
    decoderLayer: (layerIndex: number) => ({
        decoder_input: `decoder.${layerIndex}.decoder_input`,

        masked_mha_output: `decoder.${layerIndex}.masked_mha.output`,
        Wo_masked: `decoder.${layerIndex}.masked_mha.Wo`,
        add_norm_1_output: `decoder.${layerIndex}.add_norm_1_output`,

        enc_dec_mha_output: `decoder.${layerIndex}.enc_dec_mha.output`,
        Wo_enc_dec: `decoder.${layerIndex}.enc_dec_mha.Wo`,
        add_norm_2_output: `decoder.${layerIndex}.add_norm_2_output`,

        W1: `decoder.${layerIndex}.ffn.W1`, b1: `decoder.${layerIndex}.ffn.b1`,
        Intermediate: `decoder.${layerIndex}.ffn.Intermediate`, Activated: `decoder.${layerIndex}.ffn.Activated`,
        W2: `decoder.${layerIndex}.ffn.W2`, b2: `decoder.${layerIndex}.ffn.b2`,
        ffn_output: `decoder.${layerIndex}.ffn.output`,
        add_norm_3_output: `decoder.${layerIndex}.add_norm_3_output`,
    }),

    // Decoder Heads
    maskedMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.masked_mha.h${headIndex}`),
    encDecMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.enc_dec_mha.h${headIndex}`),

    // Final Output
    finalLinear: 'finalLinear',
    logits: 'logits',
    outputProbabilities: 'outputProbabilities',
};
// END OF FILE: src/config/matrixNames.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/config/symbolMapping.ts
================================================================================

// FILE: src/config/symbolMapping.ts

// This file is the single source of truth for mapping a matrix's unique name
// to its mathematical symbol parts for consistent rendering.

interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

const SYMBOL_CONFIG: { [key: string]: SymbolParts } = {
    // Input
    inputEmbeddings: { base: 'E' },
    posEncodings: { base: 'PE' },
    encoderInput: { base: 'Z' }, // Z_0
    encoder_input: { base: 'Z' },

    // MHA Weights
    Wq: { base: 'W', superscript: 'Q' },
    Wk: { base: 'W', superscript: 'K' },
    Wv: { base: 'W', superscript: 'V' },
    Wo: { base: 'W', superscript: 'O' },

    // MHA Tensors
    Q: { base: 'Q' },
    K: { base: 'K' },
    V: { base: 'V' },
    Scores: { base: 'S' },
    ScaledScores: { base: "S'" },
    AttentionWeights: { base: 'A' },
    HeadOutput: { base: 'H' },
    ConcatOutput: { base: 'H', subscript: 'cat'},
    output: { base: 'M' },
    mha_output: { base: 'M' },

    // Add & Norm (Context-dependent, see getSymbolParts)
    add_norm_1_output: { base: "Z'" }, // Default for Encoder
    add_norm_2_output: { base: "Z''" }, // Default for Encoder
    add_norm_3_output: { base: "Y", subscript: "final" }, // Default for Decoder

    // FFN
    W1: { base: 'W', subscript: '1' },
    b1: { base: 'b', subscript: '1' },
    Intermediate: { base: 'H', subscript: 'ffn' },
    Activated: { base: 'H', subscript: 'act' },
    W2: { base: 'W', subscript: '2' },
    b2: { base: 'b', subscript: '2' },
    ffn_output: { base: 'F' },

    // --- Decoder Specific ---
    outputEmbeddings: { base: 'E', subscript: 'out' },
    decoderPosEncodings: { base: 'PE', subscript: 'dec' },
    decoderInput: { base: 'Y' }, // Y_0
    decoder_input: { base: 'Y' },

    masked_mha_output: { base: 'M', subscript: 'mmha' },
    Wo_masked: { base: 'W', superscript: 'O' },

    enc_dec_mha_output: { base: 'M', subscript: 'ed' },
    Wo_enc_dec: { base: 'W', superscript: 'O' },

    // Final Output
    finalLinear: { base: 'W', subscript: 'proj' },
    logits: { base: 'L' },
    outputProbabilities: { base: 'P' },
};

/**
 * Gets the consistent mathematical symbol parts for a given matrix name.
 * @param name The full, unique name of the matrix (e.g., "encoder.0.add_norm_1_output").
 * @returns An object with base, superscript, and subscript parts.
 */
export const getSymbolParts = (name: string): SymbolParts => {
    const conceptualName = name.split('.').pop() || '';
    const isDecoderContext = name.includes('decoder');

    // [MODIFIED] Handle context-sensitive Add & Norm symbols
    if (isDecoderContext) {
        if (conceptualName === 'add_norm_1_output') return { base: "Y'" };
        if (conceptualName === 'add_norm_2_output') return { base: "Y''" };
        if (conceptualName === 'add_norm_3_output') return { base: "Y", subscript: "final" };
    } else { // Encoder context
        if (conceptualName === 'add_norm_1_output') return { base: "Z'" };
        if (conceptualName === 'add_norm_2_output') return { base: "Z", subscript: "final" };
    }

    if (conceptualName.startsWith('Wq') || conceptualName.startsWith('Wk') || conceptualName.startsWith('Wv') || conceptualName.startsWith('Wo')) {
        return SYMBOL_CONFIG[conceptualName.substring(0,2)];
    }
    return SYMBOL_CONFIG[conceptualName] || { base: 'X' }; // Default to 'X' if not found
};
// END OF FILE: src/config/symbolMapping.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/hooks/useHighlighting.ts
================================================================================

// FILE: src/hooks/useHighlighting.ts
import { useMemo } from 'react';
import { HighlightState } from '../types';

/**
 * A centralized hook to determine the highlight status of an element.
 * This prevents logic duplication and ensures consistent highlighting behavior
 * across the entire application (e.g., in Viz.tsx and Explanation.tsx).
 *
 * @param name - The unique name of the component's matrix/vector.
 * @param row - The row index of the element.
 * @param col - The column index of the element.
 * @param highlight - The global highlight state object.
 * @returns An object { isTarget, isSource, isDestination } indicating the element's highlight status.
 */
export const useHighlighting = (
  name: string,
  row: number,
  col: number,
  highlight: HighlightState
) => {
  return useMemo(() => {
    const { target, sources, destinations } = highlight;

    // Check if this element is the primary target
    const isTarget =
      !!target &&
      target.name === name &&
      target.row === row &&
      target.col === col &&
      !target.isInternal;

    // Check if this element is a source
    const isSource = sources.some(s => {
      if (s.name !== name || s.isInternal) return false;

      // [FIXED] Correctly handle row, column, and single-cell highlighting.
      if (s.highlightRow && s.highlightCol) {
          // This case means the entire matrix is a source, e.g., for residual connections.
          return true;
      }
      if (s.highlightRow) {
          return s.row === row;
      }
      if (s.highlightCol) {
          return s.col === col;
      }
      // Default to single-cell check if no specific highlight type is given
      return s.row === row && s.col === col;
    });

    // Check if this element is a destination
    const isDestination = (destinations || []).some(d => {
       if (d.name !== name || d.isInternal) return false;

       if (d.highlightRow && d.highlightCol) {
          return true;
       }
       if (d.highlightRow) {
           return d.row === row;
       }
       if (d.highlightCol) {
           return d.col === col;
       }
       return d.row === row && d.col === col;
    });

    return { isTarget, isSource, isDestination };
  // The dependency array is correct as we are only using props passed to the hook.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [name, row, col, highlight]);
};
// END OF FILE: src/hooks/useHighlighting.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/hooks/useTransformer.ts
================================================================================

// FILE: src/hooks/useTransformer.ts
import { useMemo } from 'react';
import { TransformerData } from '../types';
import { calculateTransformer } from '../lib/transformer';

// --- Main Hook ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number; // Decoder sequence length
    n_layers: number;
    d_ff: number;
}

/**
 * A React hook that calculates the entire state of a Transformer model.
 * It uses a deterministic calculation function from `lib/transformer` and
 * memoizes the result to avoid re-computation on every render.
 *
 * @param inputText - The input sentence for the encoder.
 * @param dims - The dimensions of the Transformer model.
 * @returns A `TransformerData` object containing all intermediate matrices,
 *          or `null` if the dimensions are invalid or a calculation error occurs.
 */
export const useTransformer = (inputText: string, dims: Dims): TransformerData | null => {
  return useMemo(() => {
    if (!inputText.trim()) {
        return null; // Return null if input is empty to avoid calculation errors
    }
    try {
      // The core logic is now delegated to a pure function.
      // This makes the hook cleaner and separates concerns.
      // The heavy computation is in `calculateTransformer`.
      const transformerData = calculateTransformer(inputText, dims);
      return transformerData;
    } catch (e) {
      console.error("Error during transformer calculation:", e);
      // If any error occurs during the complex calculation,
      // return null to indicate failure to the UI.
      return null;
    }
  }, [inputText, dims]); // The hook will only re-run if the dimensions or input text change.
};
// END OF FILE: src/hooks/useTransformer.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/lib/fixedWeights.ts
================================================================================

// FILE: lib/fixedWeights.ts
// This file provides a deterministic set of weights for the Transformer model.
// All values are hardcoded to ensure the visualization is reproducible.
// This replaces the previous random number generation.

interface Dims {
    d_model: number;
    h: number;
    seq_len: number;
    n_layers: number;
    d_ff: number;
}

// A simple seeding function for pseudo-random but deterministic numbers.
const createSeededRandom = (seed: number) => {
    let state = seed;
    return () => {
        state = (state * 9301 + 49297) % 233280;
        return (state / 233280.0) * 2 - 1; // Return value between -1 and 1
    };
};

const createFixedMatrix = (rows: number, cols: number, seed: number): number[][] => {
    const random = createSeededRandom(seed);
    return Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => random())
    );
};

const createFixedVector = (size: number, seed: number): number[] => {
    const random = createSeededRandom(seed);
    return Array.from({ length: size }, () => random());
};

export const fixedWeights = (dims: Dims) => {
    const { d_model, h, n_layers, d_ff, seq_len } = dims;
    const d_k = d_model / h;

    const VOCAB_SIZE = 16;
    const vocab: { [key: number]: string } = {
        0: '<PAD>', 1: '<SOS>', 2: '<EOS>', 3: 'I', 4: 'am', 5: 'a', 6: 'student',
        7: '我', 8: '是', 9: '一个', 10: '学生', 11: 'he', 12: 'she', 13: 'is',
        14: 'good', 15: '[UNK]'
    };

    const embeddingMatrix = createFixedMatrix(VOCAB_SIZE, d_model, 1);
    const posEncodings = Array.from({ length: 10 }, (_, pos) => // Max seq_len of 10
      Array.from({ length: d_model }, (_, i) =>
        i % 2 === 0
          ? Math.sin(pos / (10000 ** (i / d_model)))
          : Math.cos(pos / (10000 ** ((i - 1) / d_model)))
      )
    );

    const encoderLayers = Array.from({ length: n_layers }, (_, l) => ({
        mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 100 + l * 10 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 150 + l),
        },
        ffn: {
            W1: createFixedMatrix(d_model, d_ff, 200 + l * 2 + 0),
            b1: createFixedVector(d_ff, 201 + l * 2 + 0),
            W2: createFixedMatrix(d_ff, d_model, 200 + l * 2 + 1),
            b2: createFixedVector(d_model, 201 + l * 2 + 1),
        },
    }));

    const decoderLayers = Array.from({ length: n_layers }, (_, l) => ({
        masked_mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 300 + l * 20 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 350 + l),
        },
        enc_dec_mha: {
            heads: Array.from({ length: h }, (_, head) => ({
                Wq: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 0),
                Wk: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 1),
                Wv: createFixedMatrix(d_model, d_k, 400 + l * 20 + head * 3 + 2),
            })),
            Wo: createFixedMatrix(d_model, d_model, 450 + l),
        },
        ffn: {
            W1: createFixedMatrix(d_model, d_ff, 500 + l * 2 + 0),
            b1: createFixedVector(d_ff, 501 + l * 2 + 0),
            W2: createFixedMatrix(d_ff, d_model, 500 + l * 2 + 1),
            b2: createFixedVector(d_model, 501 + l * 2 + 1),
        },
    }));

    const finalLinear = createFixedMatrix(d_model, VOCAB_SIZE, 999);

    return {
        vocab,
        embeddingMatrix,
        posEncodings,
        encoderLayers,
        decoderLayers,
        finalLinear,
    };
};
// END OF FILE: lib/fixedWeights.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/lib/tokenizer.ts
================================================================================

// FILE: src/lib/tokenizer.ts
/**
 * A simple whitespace tokenizer.
 * Splits text by spaces and removes empty strings.
 * @param text The input string.
 * @returns An array of tokens.
 */
export const whitespaceTokenizer = (text: string): string[] => {
    return text.trim().split(/\s+/).filter(Boolean);
};

// END OF FILE: src/lib/tokenizer.ts


================================================================================
### 文件路径: src/topics/transformer-explorer/lib/transformer.ts
================================================================================

// FILE: lib/transformer.ts
import { Matrix, TransformerData, EncoderLayerData, FFNData, MultiHeadAttentionData, AttentionHeadData, Vector, DecoderLayerData } from '../types';
import { fixedWeights } from './fixedWeights';
import { whitespaceTokenizer } from './tokenizer';

// --- Utility Functions ---

const createMatrixFrom2DArray = (data: number[][]): Matrix => {
    return data.map(row => row.slice());
};

const createVectorFrom1DArray = (data: number[]): Vector => {
    return data.slice();
};

const addMatrices = (A: Matrix, B: Matrix): Matrix => {
  return A.map((row, i) =>
    row.map((val, j) => val + B[i][j])
  );
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
  const rowsA = A.length;
  if (rowsA === 0) return [];
  const colsA = A[0].length;
  if (colsA === 0) return A.map(() => []);
  const colsB = B[0]?.length ?? 0;
  if (colsB === 0) return A.map(() => []);

  const result: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));

  for (let i = 0; i < rowsA; i++) {
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      result[i][j] = sum;
    }
  }
  return result;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => {
    return A.map(row => row.map(val => val / scalar));
}

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row.filter(v => isFinite(v)));
        const exps = row.map(val => isFinite(val) ? Math.exp(val - maxVal) : 0);
        const sumExps = exps.reduce((a, b) => a + b, 0);
        if (sumExps === 0) return row.map(() => 1 / row.length); // Avoid division by zero
        return exps.map(exp => exp / sumExps);
    });
}

const layerNorm = (A: Matrix): Matrix => {
    if (A.length === 0 || A[0].length === 0) return [];
    return A.map(row => {
        const mean = row.reduce((a,b) => a+b, 0) / row.length;
        const variance = row.map(x => (x - mean) ** 2).reduce((a,b) => a+b,0) / row.length;
        const std = Math.sqrt(variance + 1e-5);
        return row.map(x => (x - mean) / std);
    });
}

const applyReLU = (A: Matrix): Matrix => {
    return A.map(row => row.map(val => Math.max(0, val)));
}

const addBias = (A: Matrix, b: Vector): Matrix => {
    return A.map(row => row.map((val, j) => val + b[j]));
}

const applyMask = (A: Matrix, maskValue = -Infinity): Matrix => {
    return A.map((row, i) =>
        row.map((val, j) => (j > i ? maskValue : val))
    );
};

// --- Main Calculation Function ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number; // Decoder sequence length
    n_layers: number;
    d_ff: number;
}

export const calculateTransformer = (inputText: string, dims: Dims): TransformerData | null => {
    const { d_model, h, seq_len: decoder_seq_len, n_layers, d_ff } = dims;
    if (d_model % h !== 0) return null;
    const d_k = d_model / h;

    const weights = fixedWeights(dims);
    const vocab = weights.vocab;
    const UNK_TOKEN_ID = 15;

    // --- INPUT STAGE (DYNAMIC) ---
    const tokenizedText = whitespaceTokenizer(inputText);
    const tokenizedInput = tokenizedText.map(t => {
        const entry = Object.entries(vocab).find(([id, word]) => word === t);
        return entry ? parseInt(entry[0], 10) : UNK_TOKEN_ID;
    });
    const encoder_seq_len = tokenizedInput.length;
    if (encoder_seq_len === 0) return null; // Handle empty input after tokenization

    // --- ENCODER ---
    const embeddingMatrix = createMatrixFrom2DArray(weights.embeddingMatrix);
    const inputEmbeddings = tokenizedInput.map(token_id => embeddingMatrix[token_id]);

    const posEncodings: Matrix = createMatrixFrom2DArray(weights.posEncodings).slice(0, encoder_seq_len);
    const encoderInput = addMatrices(inputEmbeddings, posEncodings);

    let currentEncoderInput = encoderInput;
    const encoderLayers: EncoderLayerData[] = [];

    for (let i = 0; i < n_layers; i++) {
        const encoder_input = currentEncoderInput;
        const heads: AttentionHeadData[] = [];
        const headOutputs: Matrix[] = [];
        for(let j=0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(weights.encoderLayers[i].mha.heads[j].Wv);
            const Q = multiplyMatrices(encoder_input, Wq);
            const K = multiplyMatrices(encoder_input, Wk);
            const V = multiplyMatrices(encoder_input, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: encoder_seq_len }, (_, c) => K[c][r]));
            const Scores = multiplyMatrices(Q, K_T);
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            headOutputs.push(HeadOutput);
        }
        const ConcatOutput = headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(encoder_seq_len).fill(0).map(() => []));
        const Wo = createMatrixFrom2DArray(weights.encoderLayers[i].mha.Wo);
        const mha_output = multiplyMatrices(ConcatOutput, Wo);
        const mha: MultiHeadAttentionData = { heads, Wo, output: mha_output };
        const add_norm_1_output = layerNorm(addMatrices(encoder_input, mha_output));
        const W1 = createMatrixFrom2DArray(weights.encoderLayers[i].ffn.W1);
        const b1 = createVectorFrom1DArray(weights.encoderLayers[i].ffn.b1);
        const Intermediate = addBias(multiplyMatrices(add_norm_1_output, W1), b1);
        const Activated = applyReLU(Intermediate);
        const W2 = createMatrixFrom2DArray(weights.encoderLayers[i].ffn.W2);
        const b2 = createVectorFrom1DArray(weights.encoderLayers[i].ffn.b2);
        const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
        const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
        const add_norm_2_output = layerNorm(addMatrices(add_norm_1_output, ffn_output));
        encoderLayers.push({ encoder_input, mha, mha_output, add_norm_1_output, ffn, ffn_output, add_norm_2_output });
        currentEncoderInput = add_norm_2_output;
    }
    const finalEncoderOutput = currentEncoderInput;

    // --- DECODER ---
    const tokenizedDecoderInput = ["<SOS>", "我", "是", "学生"].slice(0, decoder_seq_len).map(t => Object.keys(vocab).find(k => vocab[parseInt(k)] === t)!).map(Number);
    const outputEmbeddings = tokenizedDecoderInput.map(token_id => embeddingMatrix[token_id]);
    const decoderPosEncodings = createMatrixFrom2DArray(weights.posEncodings).slice(0, decoder_seq_len);
    const decoderInput = addMatrices(outputEmbeddings, decoderPosEncodings);

    let currentDecoderInput = decoderInput;
    const decoderLayers: DecoderLayerData[] = [];

    for (let i = 0; i < n_layers; i++) {
        const decoder_input = currentDecoderInput;
        const decWeights = weights.decoderLayers[i];

        const masked_mha_heads: AttentionHeadData[] = [];
        const masked_mha_headOutputs: Matrix[] = [];
        for (let j = 0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(decWeights.masked_mha.heads[j].Wv);
            const Q = multiplyMatrices(decoder_input, Wq);
            const K = multiplyMatrices(decoder_input, Wk);
            const V = multiplyMatrices(decoder_input, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: decoder_seq_len }, (_, c) => K[c][r]));
            const Scores = applyMask(multiplyMatrices(Q, K_T));
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            masked_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            masked_mha_headOutputs.push(HeadOutput);
        }
        const masked_ConcatOutput = masked_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(decoder_seq_len).fill(0).map(() => []));
        const masked_Wo = createMatrixFrom2DArray(decWeights.masked_mha.Wo);
        const masked_mha_output = multiplyMatrices(masked_ConcatOutput, masked_Wo);
        const masked_mha: MultiHeadAttentionData = { heads: masked_mha_heads, Wo: masked_Wo, output: masked_mha_output };
        const dec_add_norm_1_output = layerNorm(addMatrices(decoder_input, masked_mha_output));

        const enc_dec_mha_heads: AttentionHeadData[] = [];
        const enc_dec_mha_headOutputs: Matrix[] = [];
         for (let j = 0; j < h; j++) {
            const Wq = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wq);
            const Wk = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wk);
            const Wv = createMatrixFrom2DArray(decWeights.enc_dec_mha.heads[j].Wv);
            const Q = multiplyMatrices(dec_add_norm_1_output, Wq);
            const K = multiplyMatrices(finalEncoderOutput, Wk);
            const V = multiplyMatrices(finalEncoderOutput, Wv);
            const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: encoder_seq_len }, (_, c) => K[c][r]));
            const Scores = multiplyMatrices(Q, K_T);
            const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
            const AttentionWeights = softmaxByRow(ScaledScores);
            const HeadOutput = multiplyMatrices(AttentionWeights, V);
            enc_dec_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
            enc_dec_mha_headOutputs.push(HeadOutput);
        }
        const enc_dec_ConcatOutput = enc_dec_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(decoder_seq_len).fill(0).map(() => []));
        const enc_dec_Wo = createMatrixFrom2DArray(decWeights.enc_dec_mha.Wo);
        const enc_dec_mha_output = multiplyMatrices(enc_dec_ConcatOutput, enc_dec_Wo);
        const enc_dec_mha: MultiHeadAttentionData = { heads: enc_dec_mha_heads, Wo: enc_dec_Wo, output: enc_dec_mha_output };
        const dec_add_norm_2_output = layerNorm(addMatrices(dec_add_norm_1_output, enc_dec_mha_output));

        const W1 = createMatrixFrom2DArray(decWeights.ffn.W1);
        const b1 = createVectorFrom1DArray(decWeights.ffn.b1);
        const Intermediate = addBias(multiplyMatrices(dec_add_norm_2_output, W1), b1);
        const Activated = applyReLU(Intermediate);
        const W2 = createMatrixFrom2DArray(decWeights.ffn.W2);
        const b2 = createVectorFrom1DArray(decWeights.ffn.b2);
        const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
        const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
        const dec_add_norm_3_output = layerNorm(addMatrices(dec_add_norm_2_output, ffn_output));

        decoderLayers.push({ decoder_input, masked_mha, masked_mha_output, add_norm_1_output: dec_add_norm_1_output, enc_dec_mha, enc_dec_mha_output, add_norm_2_output: dec_add_norm_2_output, ffn, ffn_output, add_norm_3_output: dec_add_norm_3_output });
        currentDecoderInput = dec_add_norm_3_output;
    }
    const finalDecoderOutput = currentDecoderInput;

    const finalLinear = createMatrixFrom2DArray(weights.finalLinear);
    const logits = multiplyMatrices(finalDecoderOutput, finalLinear);
    const outputProbabilities = softmaxByRow(logits);

    // --- DECODING STAGE ---
    const decodedTokens = outputProbabilities.map(row => row.indexOf(Math.max(...row)));
    const outputText = decodedTokens.map(id => vocab[id] || "[UNK]"); // Handle unknown tokens

    return {
        inputText: tokenizedText,
        tokenizedInput,
        embeddingMatrix,
        vocab,
        inputEmbeddings,
        posEncodings,
        encoderInput,
        encoderLayers,
        finalEncoderOutput,
        outputEmbeddings,
        decoderPosEncodings,
        decoderInput,
        decoderLayers,
        finalDecoderOutput,
        finalLinear,
        logits,
        outputProbabilities,
        decodedTokens,
        outputText,
    };
};
// END OF FILE: lib/transformer.ts


================================================================================
### 文件路径: src/utils/matrixView.ts
================================================================================

// FILE: src/utils/matrixView.ts
export const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12; // e.g., 4 + 3 + 4 + 1 ellipsis = 12

/**
 * Calculates the visible indices for a row or column of a matrix based on a focus point.
 * It always shows the first and last `alwaysShowCount` items.
 * It shows a `windowSize` around the `focusIndex`.
 *
 * @param totalSize - The total number of items (rows or columns).
 * @param focusIndex - The index of the focused item, or -1 if no focus.
 * @param alwaysShowCount - The number of items to always show at the beginning and end.
 * @param windowSize - The size of the focus window around the focusIndex.
 * @returns An array of indices to display, with ELLIPSIS string for gaps.
 */
export const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {

  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }

  const visible = new Set<number>();

  // 1. Add always-visible indices
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }

  // 2. Add focus window indices
  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }

  // 3. Build the final array with ellipses for gaps
  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];

  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }

  return result;
};
// END OF FILE: src/utils/matrixView.ts


================================================================================
### 文件路径: public/index.html
================================================================================

<!--# FILE: public/index.html-->

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>终极 Transformer 深度探索器</title>
    <!-- 引入 MathJax 用于渲染 LaTeX 公式 -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

<!--# END OF FILE: public/index.html-->


