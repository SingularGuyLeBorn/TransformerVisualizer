================================================================================
### 文件路径: src/App.css
================================================================================

/* FILE: src/App.css */
:root {
  --highlight-color: #c0392b;
  --highlight-bg: rgba(192, 57, 43, 0.08);
  --border-color: #dcdfe6;
  --bg-color: #f5f7fa;
  --text-color: #303133;
  --arrow-color: #888;
  --component-bg: #ffffff;
  --component-header-bg: #f8f9fa;
  --residual-bg: #f0f4c3;
  --residual-border: #dce775;

  /* Highlighting */
  --highlight-target-bg: #e63946;
  --highlight-target-color: #ffffff;
  --highlight-source-bg: #606266; /* [MODIFIED] Changed from dark blue to gray */
  --highlight-source-color: #f1faee;
  /* 调整为半透明橙红色调 */
  --highlight-formula-bg: rgba(252, 163, 17, 0.15); /* 橙红色（#fca311）的15%透明度 */
  --highlight-formula-border: #fca311; /* 橙红色 */
  --highlight-vector-bg: rgba(69, 123, 157, 0.2);
}

html {
  scroll-behavior: smooth;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  background-color: var(--bg-color);
  color: var(--text-color);
  margin: 0;
  font-size: 15px;
}

#root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

h1 {
  text-align: center;
  color: #000;
  margin: 0;
  padding: 20px 0;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; /* Prevent title from shrinking */
}

.main-layout {
  display: flex;
  gap: 20px;
  flex-grow: 1; /* Allow layout to fill remaining space */
  overflow: hidden;
  padding: 20px;
  min-height: 0; /* Important for flex children scrolling */
}

.column {
  flex: 1;
  background: var(--component-bg);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
  overflow-y: auto; /* THIS IS THE KEY FOR SCROLLING */
  min-height: 0;
  min-width: 0; /* [ADDED] Critical fix for responsive overflow */
}

.column-content {
  padding: 20px;
}

.column.left-column {
  flex: 1.4;
}

.column h2 {
  font-size: 1.6em;
  margin: -20px -20px 20px -20px;
  padding: 20px 20px 15px 20px;
  text-align: center;
  color: #000;
  position: sticky;
  top: -21px; /* Adjust to hide top border */
  background: inherit;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
  border-radius: 12px 12px 0 0;
}

/* --- Left Column: Viz --- */
.diagram-component {
  border: 2px solid var(--border-color);
  border-radius: 10px;
  margin-bottom: 15px;
  background-color: #fdfdfd;
  transition: all 0.3s ease;
}
/* 新增：左侧组件激活时的样式 */
.diagram-component.active {
    border-color: var(--highlight-formula-border) !important;
    box-shadow: 0 0 30px var(--highlight-formula-bg) !important;
    transform: scale(1.01);
}

.component-header {
  background-color: var(--component-header-bg);
  padding: 8px 15px;
  font-weight: bold;
  font-size: 1.1em;
  border-bottom: 1px solid var(--border-color);
  border-radius: 8px 8px 0 0;
}
.component-body {
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  width: 100%; /* [ADDED] Critical fix for child element scrolling */
  box-sizing: border-box; /* Ensure padding is included in the width */
}

.arrow-down {
  width: 100%;
  text-align: center;
  font-size: 24px;
  color: var(--arrow-color);
  margin: 5px 0;
}

/* --- Matrix Styles --- */

.matrix-wrapper {
    position: relative;
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    vertical-align: middle; /* 改善在 flex 布局行中的对齐 */
}

.matrix-container {
  display: inline-block;
  border: 1px solid #ccc;
  padding: 5px;
  border-radius: 4px;
  background-color: #f9f9f9;
  position: relative;
}
.matrix-grid {
  display: grid;
  gap: 3px;
}

.matrix-element {
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
  z-index: 2;
  font-weight: normal; /* 确保不加粗 */
}

/* [ADDED] Styling for ellipsis cell in matrix grid */
.matrix-ellipsis {
    width: 45px;
    height: 25px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #aaa;
    font-size: 1.2em;
    font-family: monospace;
}


.matrix-element:hover {
  transform: scale(1.1);
  border-color: #007bff;
  box-shadow: 0 0 5px rgba(0,123,255,0.5);
  z-index: 5;
}

.matrix-element.source {
  background-color: var(--highlight-source-bg);
  color: var(--highlight-source-color);
  border: 1px solid var(--highlight-source-bg);
}
.matrix-element.target {
  background-color: var(--highlight-target-bg);
  color: var(--highlight-target-color);
  border: 1px solid var(--highlight-target-bg);
}

.matrix-element.destination {
  background-color: var(--highlight-formula-bg);
  border: 1px solid var(--highlight-formula-border);
}

.matrix-label-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}

.matrix-label {
  text-align: center;
  font-weight: bold;
  font-family: monospace;
  font-size: 1.1em;
  margin: 0;
}

.matrix-symbol-tag {
    background-color: #e9ecef;
    color: #495057;
    padding: 3px 7px;
    border-radius: 5px;
    font-size: 1.1em;
    border: 1px solid #ced4da;
    line-height: 1;
    font-family: 'Times New Roman', serif;
}


.op-symbol {
    font-size: 2em;
    font-weight: bold;
    color: #909399;
}

/* --- Right Column: Explanation --- */
.math-block {
  margin-bottom: 25px;
  padding: 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: #fff;
  transition: all 0.3s ease;
}
.math-block.active {
  border-color: var(--highlight-formula-border) !important;
  box-shadow: 0 0 30px var(--highlight-bg) !important;
  transform: scale(1.01);
  background-color: var(--highlight-formula-bg);
}
.math-block h3 {
  margin: -20px -20px 15px -20px;
  padding: 15px 20px;
  font-size: 1.25em;
  color: #000;
  border-bottom: 1px solid #eee;
  border-radius: 12px 12px 0 0;
  background-color: var(--component-header-bg);
}
.math-block p, .math-block li, .math-block h5 {
    line-height: 1.7;
    margin: 1em 0;
}
.math-block h5 {
    font-size: 1.1em;
    margin-top: 1.5em;
    margin-bottom: 0.5em;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
}
.math-block code {
   background-color: #e9ecef;
   padding: 2px 5px;
   border-radius: 4px;
   font-family: monospace;
}

.formula-display {
    display: flex;
    justify-content: flex-start; /* Aligned to left for better scroll */
    align-items: center;
    gap: 15px;
    overflow-x: auto; /* CRITICAL FIX: Allow horizontal scrolling */
    margin: 20px 0;
    padding: 15px 10px;
    background-color: rgba(0,0,0,0.02);
    border-radius: 8px;
}
.formula-display > * {
    flex-shrink: 0; /* CRITICAL FIX: Prevent items from shrinking */
}
.formula-display.vertical {
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.formula-display.vertical .viz-formula-row {
    justify-content: flex-start;
}

.katex-display {
    margin: 0 !important;
}

.matrix-scroll-wrapper {
    overflow-x: auto;
    padding: 5px;
    flex-shrink: 0; /* Changed from 1 to 0 */
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Symbolic Matrix & Highlighting */
.symbolic-matrix-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.symbolic-matrix-grid {
    display: grid;
    gap: 2px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f9f9f9;
}
.symbolic-element, .symbolic-ellipsis {
    min-width: 60px;
    min-height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9em;
    border-radius: 2px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    transition: all 0.2s ease-in-out;
}
.symbolic-ellipsis {
    border-style: dashed;
    color: #aaa;
}
.symbolic-element.source {
  background-color: rgba(96, 98, 102, 0.1);
  border-color: var(--highlight-source-bg);
}
.symbolic-element.target {
  background-color: rgba(230, 57, 70, 0.1);
  border-color: var(--highlight-target-bg);
}
.symbolic-element.destination {
    background-color: var(--highlight-formula-bg);
    border-color: var(--highlight-formula-border);
}


/* Controls */
.controls-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 15px 20px;
  background-color: var(--component-bg);
  border-bottom: 1px solid var(--border-color);
  gap: 30px;
  flex-shrink: 0; /* Prevent controls from shrinking */
}
.control-group {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.control-group label {
  font-size: 0.9em;
  margin-bottom: 5px;
  color: #606266;
}
.control-group input {
  width: 60px;
  padding: 6px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  text-align: center;
  font-size: 1em;
}
.d_k-value {
    width: 60px;
    padding: 6px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: center;
    font-size: 1em;
    font-weight: bold;
    background-color: #f0f2f5;
}

/* [MODIFIED] Grouping and Scrolling Logic */
.viz-formula-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    overflow-x: auto;
    padding: 15px 10px;
    border: 1px solid #eef;
    border-radius: 8px;
    background-color: rgba(0,0,0,0.015);
    gap: 5px; /* Spacing between rows/arrows inside a group */
    box-sizing: border-box; /* Ensure padding is included in the width */
}
.viz-formula-group > * {
    flex-shrink: 0; /* Ensure content inside does not shrink */
}
.viz-formula-row {
    display: flex;
    align-items: center;
    gap: 15px;
    justify-content: center;
    width: auto; /* Let the row size to its content */
    padding: 0 5px; /* Remove vertical padding */
}
.viz-formula-row > * {
    flex-shrink: 0;
}


/* Styling for sub-steps in visualization components */
.viz-step-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #606266;
    margin-top: 10px;
    margin-bottom: 5px;
    font-size: 0.9em;
    border-bottom: 1px solid #eef;
    padding-bottom: 5px;
}
.viz-formula-group .viz-step-title {
    margin-top: -5px; /* Adjust margin when inside a group */
    margin-bottom: 10px;
}

/* Styling for Elementwise Operation Visualization */
.elementwise-op-container {
    width: 100%;
    padding: 10px;
    margin: 5px 0;
    border: 1px dashed #ccc;
    border-radius: 8px;
    background-color: #f8f9fa;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    box-sizing: border-box;
}
.elementwise-op-label {
    font-weight: bold;
    font-size: 1.1em;
}
.elementwise-op-viz {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    font-family: monospace;
    font-size: 1.2em;
    padding-bottom: 5px;
}
.elementwise-op-viz > * {
    flex-shrink: 0;
}
/* [ADDED] Wrapper for function call to keep items on one line */
.elementwise-op-function-call {
    display: flex;
    align-items: center;
    gap: 5px;
}

.elementwise-op-row {
    display: flex;
    gap: 5px;
    border: 1px solid #ddd;
    padding: 4px;
    border-radius: 4px;
    background: #fff;
    align-items: center;
}
.elementwise-op-element {
  /* Inherits from .matrix-element */
  width: 45px;
  height: 25px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 2px;
  font-family: monospace;
  font-size: 0.8em;
}
/* [ADDED] Style for ellipsis in elementwise op */
.elementwise-op-element.symbolic-ellipsis {
    border: none;
    background-color: transparent;
    color: #aaa;
    width: auto;
}

/* [NEW] Styles for ElementwiseCalculation */
.elementwise-calc-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: 100%;
    font-size: 0.9em;
}
.calc-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}
.calc-label {
    color: #555;
    font-size: 0.9em;
}
.elementwise-op-element.sum {
    width: auto;
    padding: 0 10px;
    font-weight: bold;
}
.elementwise-op-element.source, .elementwise-op-element.sum.source {
    background-color: var(--highlight-source-bg) !important;
    color: var(--highlight-source-color) !important;
    border-color: var(--highlight-source-bg) !important;
}
.elementwise-op-element.target, .elementwise-op-element.sum.target {
    background-color: var(--highlight-target-bg) !important;
    color: var(--highlight-target-color) !important;
    border-color: var(--highlight-target-bg) !important;
}

/* [NEW] Styles for Residual Block */
.residual-block {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px 10px;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #fcfcfc;
}
.residual-block:hover {
    border-color: var(--highlight-formula-border);
    background-color: var(--highlight-formula-bg);
}
.residual-icon {
    font-size: 1.6em;
    font-weight: bold;
    color: var(--arrow-color);
    line-height: 1;
}
.residual-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
}
.residual-matrix-symbol {
    font-size: 1.2em;
}
.residual-matrix-dims {
    font-size: 0.8em;
    color: #666;
    font-family: monospace;
}
.residual-block.active {
    border-color: var(--highlight-formula-border);
    border-style: solid;
    box-shadow: 0 0 15px var(--highlight-formula-bg);
    transform: scale(1.05);
}
.residual-block.active .residual-icon {
    color: var(--highlight-formula-border);
}

.add-norm-component-body {
    flex-direction: column; /* Changed for vertical layout */
}

.add-norm-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap; /* Allow wrapping on small screens */
}
/* END OF FILE: src/App.css */


================================================================================
### 文件路径: src/App.tsx
================================================================================

// FILE: src/App.tsx
import React, { useState, useCallback, useEffect } from 'react';
import { Controls } from './components/Controls';
import { Viz } from './components/Viz';
import { Explanation } from './components/Explanation';
import { useTransformer } from './hooks/useTransformer';
import { ElementIdentifier, HighlightSource, HighlightState, TransformerData } from './types';
import { MATRIX_NAMES } from './config/matrixNames';

const getLayerAndHeadIndices = (name: string): [number, number] => {
    const layerIdxMatch = name.match(/\.(encoder|decoder)\.(\d+)/);
    const layerIdx = layerIdxMatch ? parseInt(layerIdxMatch[2], 10) : 0;
    const headIdxMatch = name.match(/\.h(\d+)\./);
    const headIdx = headIdxMatch ? parseInt(headIdxMatch[1], 10) : 0;
    return [layerIdx, headIdx];
};

const createBackwardHighlight = (element: ElementIdentifier, transformerData: TransformerData, dims: any): HighlightState => {
    const { name, row, col, isInternal } = element;
    let newSources: HighlightSource[] = [];
    let newTarget: ElementIdentifier | null = element;
    let activeComponent: string | null = null;
    let activeResidual: string | null = null;

    if (name.startsWith('residual.')) {
        const [, resId] = name.split('.');
        activeResidual = resId;
        const layerIdx = parseInt(resId.match(/l(\d+)/)?.[1] || '0', 10);
        const part = parseInt(resId.match(/(\d+)$/)?.[1] || '1', 10);

        if (resId.includes('-d')) {
            const LN = MATRIX_NAMES.decoderLayer(layerIdx);
            if(part === 1) { activeComponent = 'add_norm_1_dec'; newSources.push({ name: LN.decoder_input, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.masked_mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2_dec'; newSources.push({ name: LN.add_norm_1_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.enc_dec_mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 3) { activeComponent = 'add_norm_3_dec'; newSources.push({ name: LN.add_norm_2_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.ffn_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
        } else {
            const LN = MATRIX_NAMES.layer(layerIdx);
            if (part === 1) { activeComponent = 'add_norm_1'; newSources.push({ name: LN.encoder_input, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.mha_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
            else if (part === 2) { activeComponent = 'add_norm_2'; newSources.push({ name: LN.add_norm_1_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: LN.ffn_output, row: -1, col: -1, highlightRow: true, highlightCol: true }); }
        }
        return { target: null, sources: newSources, activeComponent, activeResidual, destinations: [] };
    }

    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    const LNe = MATRIX_NAMES.layer(layerIdx);
    const HNe = MATRIX_NAMES.head(layerIdx, headIdx);
    const LNd = MATRIX_NAMES.decoderLayer(layerIdx);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIdx, headIdx);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(layerIdx, headIdx);

    const baseName = isInternal ? name.replace('.internal', '') : name;
    if (name.startsWith('encoder')) {
        if(Object.values(HNe).includes(baseName) || [LNe.mha_output, LNe.Wo, LNe.encoder_input].includes(baseName)) activeComponent = 'mha';
        else if([LNe.add_norm_1_output].includes(baseName)) activeComponent = 'add_norm_1';
        else if([LNe.add_norm_2_output].includes(baseName)) activeComponent = 'add_norm_2';
        else if(baseName.includes('.ffn.')) activeComponent = 'ffn';
    } else if (name.startsWith('decoder')) {
        if(Object.values(HNd_masked).includes(baseName) || [LNd.masked_mha_output, LNd.Wo_masked, LNd.decoder_input].includes(baseName)) activeComponent = 'masked_mha';
        else if(Object.values(HNd_encdec).includes(baseName) || [LNd.enc_dec_mha_output, LNd.Wo_enc_dec, LNd.add_norm_1_output].includes(baseName)) activeComponent = 'enc_dec_mha';
        else if(baseName === LNd.add_norm_1_output) activeComponent = 'add_norm_1_dec';
        else if(baseName === LNd.add_norm_2_output) activeComponent = 'add_norm_2_dec';
        else if(baseName === LNd.add_norm_3_output) activeComponent = 'add_norm_3_dec';
        else if(baseName.includes('.ffn.')) activeComponent = 'ffn_dec';
    } else if ([MATRIX_NAMES.inputEmbeddings, MATRIX_NAMES.posEncodings, MATRIX_NAMES.encoderInput].includes(baseName)) activeComponent = 'input_embed';
    else if ([MATRIX_NAMES.outputEmbeddings, MATRIX_NAMES.decoderPosEncodings, MATRIX_NAMES.decoderInput].includes(baseName)) activeComponent = 'output_embed';
    else if ([MATRIX_NAMES.finalLinear, MATRIX_NAMES.logits, MATRIX_NAMES.outputProbabilities].includes(baseName)) activeComponent = 'final_output';

    if (isInternal) {
        newTarget = { name, row, col, isInternal: true };
        if (baseName.includes('AttentionWeights')) {
            const scaledScoresName = baseName.includes('masked_mha') ? HNd_masked.ScaledScores : baseName.includes('enc_dec_mha') ? HNd_encdec.ScaledScores : HNe.ScaledScores;
            newSources.push({ name: scaledScoresName, row, col: -1, highlightRow: true });
            newSources.push({ name, row, col: -1, isInternal: true });
        } else if (baseName.includes('Activated')) {
            const intermediateName = baseName.includes('decoder') ? LNd.Intermediate : LNe.Intermediate;
            newSources.push({ name: intermediateName, row, col });
        }
    }
    else if (name === MATRIX_NAMES.encoderInput) { newSources.push({ name: MATRIX_NAMES.inputEmbeddings, row, col }); newSources.push({ name: MATRIX_NAMES.posEncodings, row, col }); }
    else if (name === LNe.encoder_input) { newSources.push({ name: layerIdx > 0 ? MATRIX_NAMES.layer(layerIdx - 1).add_norm_2_output : MATRIX_NAMES.encoderInput, row, col }); }
    else if (name === HNe.Q || name === HNe.K || name === HNe.V) { const type = name.split('.').pop()!; newSources.push({ name: LNe.encoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: HNe[`W${type.toLowerCase()}` as 'Wq'|'Wk'|'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNe.Scores) { newSources.push({ name: HNe.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNe.K, row: col, col: -1, highlightRow: true }); }
    else if (name === HNe.ScaledScores) { newSources.push({ name: HNe.Scores, row, col }); }
    else if (name === HNe.AttentionWeights) { newSources.push({ name: HNe.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNe.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNe.HeadOutput) { newSources.push({ name: HNe.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNe.V, row: -1, col, highlightCol: true }); }
    else if (name === LNe.mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.head(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.Wo, row: -1, col, highlightCol: true }); }
    else if (name === LNe.add_norm_1_output) { newSources.push({ name: LNe.encoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.mha_output, row, col: -1, highlightRow: true }); }
    else if (name === LNe.Intermediate || name === LNe.Activated) { newSources.push({ name: LNe.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.W1, row: -1, col, highlightCol: true }); newSources.push({ name: LNe.b1, row: 0, col }); if (name === LNe.Activated) newSources.push({ name: `${LNe.Activated}.internal`, row, col, isInternal: true }); }
    else if (name === LNe.ffn_output) { newSources.push({ name: LNe.Activated, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.W2, row: -1, col, highlightCol: true }); newSources.push({ name: LNe.b2, row: 0, col }); }
    else if (name === LNe.add_norm_2_output) { newSources.push({ name: LNe.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNe.ffn_output, row: col: -1, highlightRow: true }); }
    else if (name === MATRIX_NAMES.decoderInput) { newSources.push({ name: MATRIX_NAMES.outputEmbeddings, row, col }); newSources.push({ name: MATRIX_NAMES.decoderPosEncodings, row, col }); }
    else if (name === LNd.decoder_input) { newSources.push({ name: layerIdx > 0 ? MATRIX_NAMES.decoderLayer(layerIdx - 1).add_norm_3_output : MATRIX_NAMES.decoderInput, row, col }); }
    else if (name === HNd_masked.Q || name === HNd_masked.K || name === HNd_masked.V) { const type = name.split('.').pop()!; newSources.push({ name: LNd.decoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked[`W${type.toLowerCase()}` as 'Wq'|'Wk'|'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === HNd_masked.Scores) { newSources.push({ name: HNd_masked.Q, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked.K, row, col, col: -1, highlightRow: true }); }
    else if (name === HNd_masked.AttentionWeights) { newSources.push({ name: HNd_masked.ScaledScores, row, col: -1, highlightRow: true }); newSources.push({ name: `${HNd_masked.AttentionWeights}.internal`, row, col, isInternal: true }); }
    else if (name === HNd_masked.HeadOutput) { newSources.push({ name: HNd_masked.AttentionWeights, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_masked.V, row: -1, col, highlightCol: true }); }
    else if (name === LNd.masked_mha_output) { for (let h = 0; h < dims.h; h++) newSources.push({ name: MATRIX_NAMES.maskedMhaHead(layerIdx, h).HeadOutput, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.Wo_masked, row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_1_output) { newSources.push({ name: LNd.decoder_input, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.masked_mha_output, row: -1, highlightRow: true }); }
    else if (name === HNd_encdec.Q) { newSources.push({ name: LNd.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: HNd_encdec.Wq, row: -1, col, highlightCol: true }); }
    else if (name === HNd_encdec.K || name === HNd_encdec.V) { const type = name.split('.').pop()!; newSources.push({ name: MATRIX_NAMES.finalEncoderOutput, row: -1, col: -1, highlightRow: true, highlightCol: true }); newSources.push({ name: HNd_encdec[`W${type.toLowerCase()}` as 'Wk'|'Wv'], row: -1, col, highlightCol: true }); }
    else if (name === LNd.add_norm_2_output) { newSources.push({ name: LNd.add_norm_1_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.enc_dec_mha_output, row, col: -1, highlightRow: true }); }
    else if (name === LNd.ffn_output) { newSources.push({ name: LNd.Activated, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.W2, row: -1, col, highlightCol: true }); newSources.push({ name: LNd.b2, row: 0, col }); }
    else if (name === LNd.add_norm_3_output) { newSources.push({ name: LNd.add_norm_2_output, row, col: -1, highlightRow: true }); newSources.push({ name: LNd.ffn_output, row, col: -1, highlightRow: true }); }
    else if (name === MATRIX_NAMES.logits) { newSources.push({ name: transformerData.decoderLayers[dims.n_layers-1].add_norm_3_output, row, col: -1, highlightRow: true}); newSources.push({name: MATRIX_NAMES.finalLinear, row: -1, col, highlightCol: true})}
    else if (name === MATRIX_NAMES.outputProbabilities) { newSources.push({name: MATRIX_NAMES.logits, row, col: -1, highlightRow: true})}

    return { target: newTarget, sources: newSources, activeComponent, activeResidual, destinations: [] };
};

const createForwardHighlight = (element: ElementIdentifier, transformerData: TransformerData, dims: any): HighlightState => {
    const { name, row, col } = element;
    let newDestinations: HighlightSource[] = [];
    let activeComponent: string | null = null;
    let activeResidual: string | null = null;

    const [layerIdx, headIdx] = getLayerAndHeadIndices(name);
    const LNe = MATRIX_NAMES.layer(layerIdx);
    const HNe = MATRIX_NAMES.head(layerIdx, headIdx);
    const LNd = MATRIX_NAMES.decoderLayer(layerIdx);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(layerIdx, headIdx);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(layerIdx, headIdx);

    if (name === MATRIX_NAMES.inputEmbeddings || name === MATRIX_NAMES.posEncodings) { newDestinations.push({ name: MATRIX_NAMES.encoderInput, row, col }); activeComponent = 'input_embed'; }
    else if (name === MATRIX_NAMES.encoderInput) { newDestinations.push({ name: MATRIX_NAMES.layer(0).encoder_input, row, col }); activeComponent = 'input_embed'; }
    else if (name === LNe.encoder_input) { newDestinations.push({ name: HNe.Q, row, col: -1, highlightRow: true }); newDestinations.push({ name: HNe.K, row, col: -1, highlightRow: true }); newDestinations.push({ name: HNe.V, row, col: -1, highlightRow: true }); newDestinations.push({ name: LNe.add_norm_1_output, row, col }); activeComponent = 'mha'; }
    else if (name === LNe.add_norm_2_output && layerIdx < dims.n_layers - 1) { newDestinations.push({ name: MATRIX_NAMES.layer(layerIdx+1).encoder_input, row, col }); }
    else if (name === LNe.add_norm_2_output && layerIdx === dims.n_layers - 1) { newDestinations.push({ name: MATRIX_NAMES.finalEncoderOutput, row, col }); }
    else if (name === MATRIX_NAMES.finalEncoderOutput) { for (let i = 0; i < dims.n_layers; i++) { const HNd_i = MATRIX_NAMES.encDecMhaHead(i, 0); newDestinations.push({name: HNd_i.K, row, col: -1, highlightRow: true}); newDestinations.push({name: HNd_i.V, row, col: -1, highlightRow: true}); } activeComponent = 'enc_dec_mha'; }
    else if (name === MATRIX_NAMES.outputEmbeddings || name === MATRIX_NAMES.decoderPosEncodings) { newDestinations.push({ name: MATRIX_NAMES.decoderInput, row, col }); activeComponent = 'output_embed'; }
    else if (name === MATRIX_NAMES.decoderInput) { newDestinations.push({ name: MATRIX_NAMES.decoderLayer(0).decoder_input, row, col }); activeComponent = 'output_embed'; }
    else if (name === LNd.decoder_input) { newDestinations.push({ name: HNd_masked.Q, row, col: -1, highlightRow: true}); newDestinations.push({ name: HNd_masked.K, row, col: -1, highlightRow: true}); newDestinations.push({ name: HNd_masked.V, row, col: -1, highlightRow: true}); newDestinations.push({ name: LNd.add_norm_1_output, row, col}); activeComponent = 'masked_mha';}
    else if (name === LNd.add_norm_1_output) { newDestinations.push({ name: HNd_encdec.Q, row, col: -1, highlightRow: true}); newDestinations.push({ name: LNd.add_norm_2_output, row, col}); activeComponent = 'enc_dec_mha';}

    return { target: element, sources: [], destinations: newDestinations, activeComponent, activeResidual };
};

function App() {
  const [dims, setDims] = useState({
      d_model: 8,
      h: 2,
      seq_len: 3,
      n_layers: 1,
      d_ff: 32
  });
  const [highlight, setHighlight] = useState<HighlightState>({ target: null, sources: [], destinations: [], activeComponent: null, activeResidual: null });

  const transformerData: TransformerData | null = useTransformer(dims);

  useEffect(() => {
    if (highlight.activeComponent) {
      const explanationEl = document.getElementById(`math_${highlight.activeComponent}`);
      if (explanationEl) {
          setTimeout(() => {
              explanationEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
      }
    }
  }, [highlight.activeComponent]);

  const handleElementClick = useCallback((element: ElementIdentifier) => {
      if (!transformerData) return;
      setHighlight(createBackwardHighlight(element, transformerData, dims));
  }, [transformerData, dims]);

  const handleSymbolClick = useCallback((element: ElementIdentifier) => {
    if (!transformerData) return;
    setHighlight(createForwardHighlight(element, transformerData, dims));
  }, [transformerData, dims]);

  if (!transformerData) {
      return <div>正在加载或维度设置无效... (d_model 必须能被 h 整除)</div>
  }

  return (
    <div className="app-container">
      <h1>终极 Transformer 深度探索器</h1>
      <Controls dims={dims} setDims={setDims} />
      <div className="main-layout">
        <div className="column left-column">
          <div className="column-content">
              <h2>模型结构与数据流</h2>
              <Viz
                data={transformerData}
                highlight={highlight}
                onElementClick={handleElementClick}
              />
          </div>
        </div>
        <div className="column right-column">
           <div className="column-content">
              <h2>数学原理</h2>
              <Explanation
                dims={dims}
                highlight={highlight}
                onSymbolClick={handleSymbolClick}
              />
           </div>
        </div>
      </div>
    </div>
  );
}

export default App;
// END OF FILE: src/App.tsx


================================================================================
### 文件路径: src/index.tsx
================================================================================

/* START OF FILE: src/index.tsx */
// FILE: src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './App.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
// END OF FILE: src/index.tsx
/* END OF FILE: src/index.tsx */


================================================================================
### 文件路径: src/styles.css
================================================================================

/* START OF FILE: src/styles.css */

/* END OF FILE: src/styles.css */


================================================================================
### 文件路径: src/types.ts
================================================================================

// FILE: src/types.ts
export type Matrix = number[][];
export type Vector = number[];

export interface ElementIdentifier {
  name: string; // e.g., "encoder.0.mha.h0.Q" or "residual.res1.start"
  row: number;
  col: number;
  isInternal?: boolean; // True if it's part of an internal calculation visualization
  matrixSymbol?: string; // e.g., "Z"
  matrixDims?: string; // e.g., "3x8"
}

export interface HighlightSource extends ElementIdentifier {
  highlightRow?: boolean;
  highlightCol?: boolean;
}

export interface HighlightState {
  activeComponent: string | null; // e.g., "mha", "ffn"
  activeResidual: string | null; // e.g., "res1"
  target: ElementIdentifier | null;
  sources: HighlightSource[];
  destinations?: HighlightSource[]; // For forward tracing
}

export interface AttentionHeadData {
  Wq: Matrix;
  Wk: Matrix;
  Wv: Matrix;
  Q: Matrix;
  K: Matrix;
  V: Matrix;
  Scores: Matrix;
  ScaledScores: Matrix;
  AttentionWeights: Matrix;
  HeadOutput: Matrix;
}

export interface MultiHeadAttentionData {
    heads: AttentionHeadData[];
    Wo: Matrix;
    output: Matrix;
}

export interface FFNData {
    W1: Matrix;
    b1: Vector; // bias is part of FFN data
    Intermediate: Matrix;
    Activated: Matrix;
    W2: Matrix;
    b2: Vector; // bias is part of FFN data
    Output: Matrix;
}

export interface EncoderLayerData {
    encoder_input: Matrix;
    mha: MultiHeadAttentionData;
    mha_output: Matrix;

    add_norm_1_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;

    add_norm_2_output: Matrix;
}

export interface DecoderLayerData {
    decoder_input: Matrix;
    masked_mha: MultiHeadAttentionData;
    masked_mha_output: Matrix;
    add_norm_1_output: Matrix;

    enc_dec_mha: MultiHeadAttentionData;
    enc_dec_mha_output: Matrix;
    add_norm_2_output: Matrix;

    ffn: FFNData;
    ffn_output: Matrix;
    add_norm_3_output: Matrix;
}

export interface TransformerData {
    // Encoder
    inputEmbeddings: Matrix;
    posEncodings: Matrix;
    encoderInput: Matrix;
    encoderLayers: EncoderLayerData[];
    finalEncoderOutput: Matrix;

    // Decoder
    outputEmbeddings: Matrix;
    decoderPosEncodings: Matrix;
    decoderInput: Matrix;
    decoderLayers: DecoderLayerData[];
    finalDecoderOutput: Matrix;
    finalLinear: Matrix; // Weights for the final linear layer
    logits: Matrix;
    outputProbabilities: Matrix;
}
// END OF FILE: src/types.ts


================================================================================
### 文件路径: src/components/AddNorm.tsx
================================================================================

// FILE: src/components/AddNorm.tsx
import React from 'react';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { ResidualBlock } from './ResidualBlock';

interface AddNormProps {
    inputSublayer: MatrixType;
    output: MatrixType;
    sublayerMatrixName: string;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
    activeId: string;
    residualId: string; // e.g., "res-l0-1"
    residualMatrixSymbol: string;
    residualMatrixDims: string;
}

export const AddNorm: React.FC<AddNormProps> = ({
    inputSublayer,
    output,
    sublayerMatrixName,
    outputMatrixName,
    highlight,
    onElementClick,
    activeId,
    residualId,
    residualMatrixSymbol,
    residualMatrixDims,
}) => {
    const isActive = highlight.activeComponent === activeId;

    return (
         <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Add & LayerNorm</div>
            <div className="component-body add-norm-component-body">
                <div className="add-norm-inputs">
                    <ResidualBlock
                        id={residualId}
                        type="end"
                        highlight={highlight}
                        onElementClick={onElementClick}
                        matrixSymbol={residualMatrixSymbol}
                        matrixDims={residualMatrixDims}
                    />
                    <div className="op-symbol">+</div>
                    <Matrix name={sublayerMatrixName} data={inputSublayer} highlight={highlight} onElementClick={onElementClick} />
                </div>

                <div className="arrow-down"><InlineMath math="\xrightarrow{\text{LayerNorm}}" /></div>

                <Matrix name={outputMatrixName} data={output} highlight={highlight} onElementClick={onElementClick} />
            </div>
        </div>
    );
};
// END OF FILE: src/components/AddNorm.tsx


================================================================================
### 文件路径: src/components/Controls.tsx
================================================================================

/* START OF FILE: src/components/Controls.tsx */
// FILE: src/components/Controls.tsx
import React from 'react';

interface ControlsProps {
  dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
  setDims: (dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number }) => void;
}

export const Controls: React.FC<ControlsProps> = ({ dims, setDims }) => {

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    let newDims = { ...dims, [id]: parseInt(value, 10) || 1 };

    // Ensure d_model is divisible by h
    if (id === 'h') {
        if (newDims.d_model % newDims.h !== 0) {
             newDims.d_model = Math.max(newDims.h, Math.ceil(newDims.d_model / newDims.h) * newDims.h);
        }
    }
    if (id === 'd_model') {
         if (newDims.d_model % newDims.h !== 0) {
             let best_h = 1;
             for (let i = 1; i <= newDims.d_model; i++) {
                 if (newDims.d_model % i === 0) {
                    if (Math.abs(i - newDims.h) < Math.abs(best_h - newDims.h)) {
                       best_h = i;
                    }
                 }
             }
             newDims.h = best_h;
         }
    }

    // Ensure d_ff is a multiple of d_model
    if(id === 'd_model') {
        newDims.d_ff = newDims.d_model * 4;
    }

    setDims(newDims);
  };

  const d_k = dims.d_model % dims.h === 0 ? dims.d_model / dims.h : 'N/A';

  return (
    <div className="controls-container">
      <div className="control-group">
        <label htmlFor="seq_len">序列长度 (seq_len)</label>
        <input type="number" id="seq_len" value={dims.seq_len} onChange={handleInputChange} min="2" max="5" />
      </div>
      <div className="control-group">
        <label htmlFor="d_model">模型维度 (d_model)</label>
        <input type="number" id="d_model" value={dims.d_model} onChange={handleInputChange} step={1} min={2} max="16"/>
      </div>
      <div className="control-group">
        <label htmlFor="h">注意力头数 (h)</label>
        <input type="number" id="h" value={dims.h} onChange={handleInputChange} min="1" max={dims.d_model}/>
      </div>
      <div className="control-group">
        <label htmlFor="n_layers">层数 (N)</label>
        <input type="number" id="n_layers" value={dims.n_layers} onChange={handleInputChange} min="1" max="3"/>
      </div>
       <div className="control-group">
        <label>键/查询维度 (d_k)</label>
        <div className="d_k-value">{d_k}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Controls.tsx
/* END OF FILE: src/components/Controls.tsx */


================================================================================
### 文件路径: src/components/DecoderLayer.tsx
================================================================================

// FILE: src/components/DecoderLayer.tsx
import React from 'react';
import { DecoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../config/symbolMapping';
import { Matrix } from './Matrix';
import { MaskedMultiHeadAttention } from './MaskedMultiHeadAttention';
import { EncoderDecoderAttention } from './EncoderDecoderAttention';

interface DecoderLayerProps {
  layerIndex: number;
  data: DecoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const DecoderLayer: React.FC<DecoderLayerProps> = ({ layerIndex, data, highlight, onElementClick }) => {
  const baseName = `decoder.${layerIndex}`;
  const LN = MATRIX_NAMES.decoderLayer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.decoder_input);
  const dimsRes1 = `${data.decoder_input.length}x${data.decoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  const symbolRes3 = getSymbolParts(LN.add_norm_2_output);
  const dimsRes3 = `${data.add_norm_2_output.length}x${data.add_norm_2_output[0].length}`;
  const mathSymbolRes3 = symbolRes3.base + (symbolRes3.subscript ? `_{${symbolRes3.subscript}}` : '') + (symbolRes3.superscript ? `^{${symbolRes3.superscript}}` : '');

  return (
    <div className="decoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#d1c4e9', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#ede7f6'}}>解码器层 (Decoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- Masked MHA Sub-layer --- */}
                <Matrix name={LN.decoder_input} data={data.decoder_input} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-d1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MaskedMultiHeadAttention
                    baseName={`${baseName}.masked_mha`}
                    data={data.masked_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
                <AddNorm
                    inputSublayer={data.masked_mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.masked_mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_1_dec"
                    residualId={`res-l${layerIndex}-d1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />
                <div className="arrow-down">↓</div>

                {/* --- Encoder-Decoder Attention Sub-layer --- */}
                <Matrix name={LN.add_norm_1_output} data={data.add_norm_1_output} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-d2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <EncoderDecoderAttention
                    baseName={`${baseName}.enc_dec_mha`}
                    data={data.enc_dec_mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
                <AddNorm
                    inputSublayer={data.enc_dec_mha_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.enc_dec_mha_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_2_dec"
                    residualId={`res-l${layerIndex}-d2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />
                <div className="arrow-down">↓</div>

                {/* --- FFN Sub-layer --- */}
                <Matrix name={LN.add_norm_2_output} data={data.add_norm_2_output} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-d3`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes3} matrixDims={dimsRes3} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_2_output}
                    inputName={LN.add_norm_2_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
                <AddNorm
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_3_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_3_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_3_dec"
                    residualId={`res-l${layerIndex}-d3`}
                    residualMatrixSymbol={mathSymbolRes3}
                    residualMatrixDims={dimsRes3}
                />
            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/DecoderLayer.tsx


================================================================================
### 文件路径: src/components/Element.tsx
================================================================================

// FILE: src/components/Element.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';

interface ElementProps {
  name: string;
  row: number;
  col: number;
  value: number;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const Element: React.FC<ElementProps> = React.memo(({ name, row, col, value, highlight, onElementClick }) => {

  const isTarget = highlight.target?.name === name && highlight.target?.row === row && highlight.target?.col === col && !highlight.target.isInternal;

  const isSource = highlight.sources.some(s => {
    if (s.name !== name || s.isInternal) return false;
    if (s.highlightRow) return s.row === row;
    if (s.highlightCol) return s.col === col;
    return s.row === row && s.col === col;
  });

  const isDestination = highlight.destinations?.some(d => {
    if (d.name !== name || d.isInternal) return false;
    if (d.highlightRow) return d.row === row;
    if (d.highlightCol) return d.col === col;
    return d.row === row && d.col === col;
  });

  const className = `matrix-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''} ${isDestination ? 'destination' : ''}`;

  const handleClick = () => {
    onElementClick({ name, row, col });
  };

  const displayValue = () => {
      if (value === -Infinity) return '-∞';
      if (value === Infinity) return '+∞';
      return value.toFixed(2);
  }

  return (
    <div className={className} onClick={handleClick}>
      {displayValue()}
    </div>
  );
});
// END OF FILE: src/components/Element.tsx


================================================================================
### 文件路径: src/components/ElementwiseCalculation.tsx
================================================================================

// FILE: src/components/ElementwiseCalculation.tsx
import React from 'react';
import { InlineMath } from 'react-katex';
import { ElementIdentifier, HighlightState } from '../types';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface ElementwiseCalculationProps {
  opType: 'softmax' | 'relu';
  inputRow: number[];
  outputRow: number[];
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
  baseName: string; // e.g., "encoder.0.mha.h0.AttentionWeights"
  rowIndex: number;
}

const formatNumber = (num: number, precision = 2) => num.toFixed(precision);

export const ElementwiseCalculation: React.FC<ElementwiseCalculationProps> = ({
  opType,
  inputRow,
  outputRow,
  highlight,
  onElementClick,
  baseName,
  rowIndex,
}) => {
  const targetCol = highlight.target?.isInternal && highlight.target.row === rowIndex ? highlight.target.col : -1;
  const visibleCols = getVisibleIndices(inputRow.length, targetCol);

  const handleClick = (colIndex: number) => {
    onElementClick({
      name: `${baseName}.internal`, // Special name for internal calculation
      row: rowIndex,
      col: colIndex,
      isInternal: true,
    });
  };

  const isSource = (colIndex: number) => {
      return highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === colIndex);
  }
  const isTarget = (colIndex: number) => {
      return highlight.target?.isInternal && highlight.target.row === rowIndex && highlight.target.col === colIndex;
  }


  const renderVisibleElements = (data: (number | string)[], type: 'input' | 'output' | 'exp' | 'sum') => {
    return visibleCols.map((col, i) => {
      if (col === ELLIPSIS) {
        return <div key={`ellipsis-${i}`} className="elementwise-op-element symbolic-ellipsis">...</div>;
      }
      const value = data[col];
      const className = `elementwise-op-element ${isSource(col) ? 'source' : ''} ${isTarget(col) ? 'target' : ''}`;
      return (
        <div key={`${type}-${col}`} className={className} onClick={() => handleClick(col)}>
          {typeof value === 'number' ? formatNumber(value) : value}
        </div>
      );
    });
  };

  const renderSoftmax = () => {
    const maxVal = Math.max(...inputRow);
    const exps = inputRow.map(val => Math.exp(val - maxVal));
    const sumExps = exps.reduce((a, b) => a + b, 0);

    const fullSumIsSource = highlight.sources.some(s => s.isInternal && s.row === rowIndex && s.col === -1); // -1 indicates whole row/sum

    return (
      <>
        {/* Step 1: exp(x - max(x)) */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(x_i - \text{max}(\mathbf{x}))" /></div>
          <div className="elementwise-op-row">
            {renderVisibleElements(exps.map(v => Number(formatNumber(v, 4))), 'exp')}
          </div>
        </div>
        {/* Step 2: Sum */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\sum \text{exp}(\dots)" /></div>
          <div className={`elementwise-op-element sum ${fullSumIsSource ? 'source' : ''}`} onClick={() => handleClick(-1)}>
            {formatNumber(sumExps, 4)}
          </div>
        </div>
        {/* Step 3: Division */}
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{exp}(\dots) / \sum" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };

  const renderReLU = () => {
    return (
      <>
        <div className="calc-step">
          <div className="calc-label"><InlineMath math="\text{max}(0, x_i)" /></div>
          <div className="elementwise-op-row">{renderVisibleElements(outputRow, 'output')}</div>
        </div>
      </>
    );
  };


  return (
    <div className="elementwise-calc-container">
        {opType === 'softmax' ? renderSoftmax() : renderReLU()}
    </div>
  );
};
// END OF FILE: src/components/ElementwiseCalculation.tsx


================================================================================
### 文件路径: src/components/ElementwiseOperation.tsx
================================================================================

// FILE: src/components/ElementwiseOperation.tsx
import React from 'react';
import { Matrix, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseCalculation } from './ElementwiseCalculation';

interface ElementwiseOperationProps {
    opType: 'softmax' | 'relu';
    inputMatrix: Matrix;
    outputMatrix: Matrix;
    outputMatrixName: string;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
    layerIndex: number; // [NEW] Explicitly pass layerIndex
    headIndex?: number; // [NEW] Optional headIndex for MHA
}

const getInputMatrixName = (opType: 'softmax' | 'relu', layerIndex: number, headIndex?: number) => {
    if (opType === 'softmax') {
        return MATRIX_NAMES.head(layerIndex, headIndex ?? 0).ScaledScores;
    }
    return MATRIX_NAMES.layer(layerIndex).Intermediate;
};

export const ElementwiseOperation: React.FC<ElementwiseOperationProps> = ({
    opType,
    inputMatrix,
    outputMatrix,
    outputMatrixName,
    highlight,
    onElementClick,
    layerIndex,
    headIndex,
}) => {
    const relevantInputName = getInputMatrixName(opType, layerIndex, headIndex);
    let targetRowIndex = 0;

    if (highlight.target) {
        if (highlight.target.name === relevantInputName || highlight.target.name === outputMatrixName) {
            targetRowIndex = highlight.target.row;
        } else if (highlight.target.isInternal && highlight.target.name.startsWith(outputMatrixName)) {
            targetRowIndex = highlight.target.row;
        }
    }

    const inputRow = inputMatrix[targetRowIndex] || [];
    const outputRow = outputMatrix[targetRowIndex] || [];

    const opName = opType.charAt(0).toUpperCase() + opType.slice(1);
    const opFunction = opType === 'relu' ? 'max(0, x)' : 'softmax(x_i)';

    return (
        <div className="elementwise-op-container">
            <div className="elementwise-op-label">
                <InlineMath math={`\\text{Detailed Calculation: } ${opName}(x_i) = ${opFunction}`} />
            </div>
            <p style={{margin: '0', fontSize: '0.8em', color: '#666'}}>* Showing calculation for Row {targetRowIndex}</p>
            <ElementwiseCalculation
                opType={opType}
                inputRow={inputRow}
                outputRow={outputRow}
                highlight={highlight}
                onElementClick={onElementClick}
                baseName={outputMatrixName}
                rowIndex={targetRowIndex}
            />
        </div>
    );
};
// END OF FILE: src/components/ElementwiseOperation.tsx


================================================================================
### 文件路径: src/components/EncoderDecoderAttention.tsx
================================================================================

// FILE: src/components/EncoderDecoderAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface EncDecAttentionProps {
    baseName: string; // e.g., decoder.0.enc_dec_mha
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const EncoderDecoderAttention: React.FC<EncDecAttentionProps> = ({ baseName, data, highlight, onElementClick }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Assume we visualize head 0
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'enc_dec_mha';

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Encoder-Decoder Attention</div>
            <div className="component-body">
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                     <div className="viz-formula-row">
                       <span>Q (from Decoder) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>K (from Encoder) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>V (from Encoder) ×</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                     <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.encDecMhaHead(layerIndex, headIndex).HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).Wo_enc_dec} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).enc_dec_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/EncoderDecoderAttention.tsx


================================================================================
### 文件路径: src/components/EncoderLayer.tsx
================================================================================

// FILE: src/components/EncoderLayer.tsx
import React from 'react';
import { EncoderLayerData, HighlightState, ElementIdentifier } from '../types';
import { MultiHeadAttention } from './MultiHeadAttention';
import { AddNorm } from './AddNorm';
import { FeedForward } from './FeedForward';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ResidualBlock } from './ResidualBlock';
import { getSymbolParts } from '../config/symbolMapping';
import { Matrix } from './Matrix';

interface EncoderLayerProps {
  layerIndex: number;
  data: EncoderLayerData;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const EncoderLayer: React.FC<EncoderLayerProps> = ({ layerIndex, data, highlight, onElementClick }) => {
  const baseName = `encoder.${layerIndex}`;
  const LN = MATRIX_NAMES.layer(layerIndex);

  const symbolRes1 = getSymbolParts(LN.encoder_input);
  const dimsRes1 = `${data.encoder_input.length}x${data.encoder_input[0].length}`;
  const mathSymbolRes1 = symbolRes1.base + (symbolRes1.subscript ? `_{${symbolRes1.subscript}}` : '') + (symbolRes1.superscript ? `^{${symbolRes1.superscript}}` : '');

  const symbolRes2 = getSymbolParts(LN.add_norm_1_output);
  const dimsRes2 = `${data.add_norm_1_output.length}x${data.add_norm_1_output[0].length}`;
  const mathSymbolRes2 = symbolRes2.base + (symbolRes2.subscript ? `_{${symbolRes2.subscript}}` : '') + (symbolRes2.superscript ? `^{${symbolRes2.superscript}}` : '');

  return (
    <div className="encoder-layer-container">
        <div className="arrow-down">↓</div>
        <div className="diagram-component" style={{padding: '5px', borderColor: '#e3f2fd', borderWidth: '3px'}}>
            <div className="component-header" style={{backgroundColor: '#e3f2fd'}}>编码器层 (Encoder Layer) {layerIndex + 1}</div>
            <div className="component-body">

                {/* --- MHA Sub-layer with Residual Connection --- */}
                <Matrix name={LN.encoder_input} data={data.encoder_input} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-1`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes1} matrixDims={dimsRes1} />
                <MultiHeadAttention
                    baseName={`${baseName}.mha`}
                    data={data.mha}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
                <AddNorm
                    inputSublayer={data.mha_output}
                    output={data.add_norm_1_output}
                    sublayerMatrixName={LN.mha_output}
                    outputMatrixName={LN.add_norm_1_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_1"
                    residualId={`res-l${layerIndex}-1`}
                    residualMatrixSymbol={mathSymbolRes1}
                    residualMatrixDims={dimsRes1}
                />

                {/* --- FFN Sub-layer with Residual Connection --- */}
                <div className="arrow-down">↓</div>
                <Matrix name={LN.add_norm_1_output} data={data.add_norm_1_output} highlight={highlight} onElementClick={onElementClick} />
                <ResidualBlock id={`res-l${layerIndex}-2`} type="start" highlight={highlight} onElementClick={onElementClick} matrixSymbol={mathSymbolRes2} matrixDims={dimsRes2} />
                <FeedForward
                    baseName={`${baseName}.ffn`}
                    input={data.add_norm_1_output}
                    inputName={LN.add_norm_1_output}
                    data={data.ffn}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
                <AddNorm
                    inputSublayer={data.ffn_output}
                    output={data.add_norm_2_output}
                    sublayerMatrixName={LN.ffn_output}
                    outputMatrixName={LN.add_norm_2_output}
                    highlight={highlight}
                    onElementClick={onElementClick}
                    activeId="add_norm_2"
                    residualId={`res-l${layerIndex}-2`}
                    residualMatrixSymbol={mathSymbolRes2}
                    residualMatrixDims={dimsRes2}
                />

            </div>
        </div>
    </div>
  );
};
// END OF FILE: src/components/EncoderLayer.tsx


================================================================================
### 文件路径: src/components/Explanation.tsx
================================================================================

// FILE: src/components/Explanation.tsx
import React from 'react';
import 'katex/dist/katex.min.css';
import { BlockMath, InlineMath } from 'react-katex';
import { InteractiveSymbolicMatrix } from './InteractiveSymbolicMatrix';
import { InteractiveSymbolicVector } from './InteractiveSymbolicVector';
import { HighlightState, ElementIdentifier } from '../types';
import { MATRIX_NAMES } from '../config/matrixNames';

interface ExplanationProps {
    dims: { d_model: number; h: number, seq_len: number, n_layers: number, d_ff: number };
    highlight: HighlightState;
    onSymbolClick: (element: ElementIdentifier) => void;
}

interface MathBlockProps {
    id: string;
    title: string;
    children: React.ReactNode;
    highlight: HighlightState;
}

const MathBlock: React.FC<MathBlockProps> = ({ id, title, children, highlight }) => {
    const isActive = highlight.activeComponent === id;
    return (
        <div id={`math_${id}`} className={`math-block ${isActive ? 'active' : ''}`}>
            <h3>{title}</h3>
            {children}
        </div>
    );
};

export const Explanation: React.FC<ExplanationProps> = ({ dims, highlight, onSymbolClick }) => {
    const LNe = MATRIX_NAMES.layer(0);
    const HNe = MATRIX_NAMES.head(0, 0);
    const LNd = MATRIX_NAMES.decoderLayer(0);
    const HNd_masked = MATRIX_NAMES.maskedMhaHead(0, 0);
    const HNd_encdec = MATRIX_NAMES.encDecMhaHead(0, 0);
    const d_k = dims.d_model / dims.h;

    const shouldBreakAddNorm = dims.d_model > 15 || dims.d_model * 2 > 15;

    return (
        <div>
            <div className="math-block">
                <h3>Transformer 架构概览</h3>
                <p>Transformer 模型由两个核心部分组成：<b>编码器 (Encoder)</b> 和 <b>解码器 (Decoder)</b>。编码器的任务是“理解”输入的整个句子（例如，"I am a student"），并将其转化为一组富含上下文信息的数字表示。解码器的任务是利用这些数字表示，并结合已经生成的内容，一次一个词地生成目标句子（例如，“我 是 一个 学生”）。</p>
                <p>在2017年的原始论文《Attention Is All You Need》中，编码器和解码器都由 N 个相同的层堆叠而成。此可视化工具将带您深入探索其内部的数据流动和数学原理。</p>
            </div>

            {/* --- ENCODER EXPLANATIONS --- */}
            <h2 style={{textAlign: 'center', margin: '30px 0'}}>编码器 (Encoder)</h2>
            <MathBlock id="input_embed" title="编码器第1步：输入预处理" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此步骤将输入的文本序列（一串文字）转换为模型可以处理的、包含“词义”和“位置”信息的数值向量矩阵。我们以一个长度为 {dims.seq_len} 的序列为例，当前模型维度 <InlineMath math={`d_{model}=${dims.d_model}`}/>。</p>
                <h5>计算流程</h5>
                <ol>
                    <li><b>词嵌入 (Token Embedding):</b> 将每个词元（Token）的ID转换为一个稠密的向量。</li>
                    <li><b>位置编码 (Positional Encoding):</b> 为模型注入关于序列顺序的绝对位置信息。</li>
                    <li><b>逐元素相加:</b> 得到编码器最终的输入表示 <InlineMath math="Z"/>。</li>
                </ol>
                <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.inputEmbeddings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.posEncodings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.encoderInput} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="mha" title="编码器子层1：多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>此机制的核心目的是计算句子中每个词与其他所有词的“关注度”或“相关性”，并根据这个关注度重新计算每个词的向量表示，从而让每个词的向量都融入其上下文信息。</p>
                 <h5>计算流程</h5>
                <p>输入矩阵 <InlineMath math="Z"/> 被并行地送入 {dims.h} 个独立的注意力头。每个头都拥有三块自己专属、可学习的权重矩阵。通过矩阵乘法，将输入 <InlineMath math="Z"/> 投影到三个新的矩阵：查询 (Query, <InlineMath math="Q"/>), 键 (Key, <InlineMath math="K"/>), 和 值 (Value, <InlineMath math="V"/>)。</p>
                <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\times" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNe.Wq} rows={dims.d_model} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNe.Q} rows={dims.seq_len} cols={d_k} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
                <p>然后计算注意力分数 <InlineMath math="S = QK^T"/>，进行缩放和Softmax得到权重 <InlineMath math="A"/>，最后加权求和 <InlineMath math="H = A \cdot V"/>。</p>
            </MathBlock>
            <MathBlock id="add_norm_1" title="组件：残差连接与层归一化 (1)" highlight={highlight}>
                <p>在每个子层之后，都会跟随一个“Add & Norm”模块。它包含两个关键步骤：<b>残差连接</b>将子层的输入与输出直接相加，缓解梯度消失；<b>层归一化</b>则稳定训练过程。</p>
                <BlockMath math={`Z' = \\text{LayerNorm}(Z_{in} + \\text{Sublayer}(Z_{in}))`} />
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.encoder_input} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.mha_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="ffn" title="编码器子层2：位置前馈网络" highlight={highlight}>
                <p>前馈网络 (FFN) 对每个位置的向量独立地进行一次复杂的非线性变换，极大地增加了模型的表达能力。</p>
                <BlockMath math={`F = \\text{ReLU}(Z' W_1 + b_1) W_2 + b_2`} />
                <div className="formula-display vertical">
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                    <BlockMath math="\times"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                    <BlockMath math="+"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNe.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.Activated} rows={dims.seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_2" title="组件：残差连接与层归一化 (2)" highlight={highlight}>
                <p>与第一个 "Add & Norm" 层完全相同，此步骤将 FFN 子层的输出与输入结合，产生该编码器层的最终输出。</p>
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_1_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.ffn_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="\xrightarrow{\text{LayerNorm}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNe.add_norm_2_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>

            {/* --- DECODER EXPLANATIONS --- */}
            <h2 style={{textAlign: 'center', margin: '30px 0'}}>解码器 (Decoder)</h2>
            <MathBlock id="output_embed" title="解码器第1步：输出预处理" highlight={highlight}>
                 <h5>做什么？</h5>
                <p>此步骤与编码器输入预处理类似，但作用于目标语言序列（即解码器要生成的内容）。它将目标序列（通常是已经生成的词加上一个起始符）转换为模型可以处理的数值向量矩阵。</p>
                 <div className={`formula-display ${shouldBreakAddNorm ? 'vertical' : ''}`}>
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputEmbeddings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="+" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.decoderPosEncodings} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                    <BlockMath math="=" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.decoderInput} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick} /></div>
                </div>
            </MathBlock>
            <MathBlock id="masked_mha" title="解码器子层1：带掩码的多头自注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是解码器的第一个关键子层。它与编码器的自注意力机制几乎完全相同，但有一个至关重要的区别：<b>前瞻遮罩 (Look-Ahead Mask)</b>。</p>
                <h5>设计思路</h5>
                <p>在生成任务中，模型在预测第 <code>i</code> 个词时，只能看到第 <code>i</code> 个词之前（包括第 <code>i</code> 个词）的内容，绝不能“偷看”未来的词。为了在并行的矩阵运算中实现这一点，我们在计算注意力分数后，会应用一个遮罩。这个遮罩将分数矩阵 <InlineMath math="S"/> 的上三角部分（代表未来位置）设置为一个非常大的负数（-∞）。这样，在经过 Softmax 运算后，这些位置的注意力权重将变为0，从而确保了模型无法关注未来的信息。</p>
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={HNd_masked.Scores} rows={dims.seq_len} cols={dims.seq_len} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math={`\\xrightarrow{\\text{Mask}}`} />
                    <p>上三角区域被设为-∞</p>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_1_dec" title="解码器组件：残差连接与层归一化 (1)" highlight={highlight}>
                <p>同编码器中的 Add & Norm。</p>
                <BlockMath math={`Y' = \\text{LayerNorm}(Y_{in} + \\text{Masked-MHA}(Y_{in}))`} />
            </MathBlock>
             <MathBlock id="enc_dec_mha" title="解码器子层2：编码器-解码器注意力" highlight={highlight}>
                <h5>做什么？</h5>
                <p>这是连接编码器和解码器的桥梁，也是 Transformer 架构的精髓所在。在这一层，解码器会“审视”编码器的全部输出，并判断输入序列中的哪些部分对于生成当前目标词最重要。</p>
                 <h5>计算流程</h5>
                <ol>
                    <li><b>Query (<InlineMath math="Q"/>)</b>: 来自解码器前一层的输出。它代表了“我当前需要什么信息来生成下一个词？”</li>
                    <li><b>Key (<InlineMath math="K"/>) 和 Value (<InlineMath math="V"/>)</b>: <b>均来自编码器的最终输出</b>。它们代表了整个输入序列的上下文信息。</li>
                </ol>
                <p>通过计算 <InlineMath math="Q_{dec} \cdot K_{enc}^T"/>，解码器能够评估其当前的生成需求与输入序列中每个词的相关性，然后利用这个相关性（注意力权重）从 <InlineMath math="V_{enc}"/> 中加权提取最需要的信息来辅助生成。</p>
            </MathBlock>
            <MathBlock id="add_norm_2_dec" title="解码器组件：残差连接与层归一化 (2)" highlight={highlight}>
                 <p>同编码器中的 Add & Norm。</p>
                 <BlockMath math={`Y'' = \\text{LayerNorm}(Y' + \\text{Enc-Dec-MHA}(Y', Z_{enc}))`} />
            </MathBlock>
            <MathBlock id="ffn_dec" title="解码器子层3：前馈网络" highlight={highlight}>
                <p>同编码器中的 FFN。</p>
                 <div className="formula-display vertical">
                     <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.add_norm_2_output} rows={dims.seq_len} cols={dims.d_model} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                    <BlockMath math="\times"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.W1} rows={dims.d_model} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                    <BlockMath math="+"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicVector name={LNd.b1} data={Array(dims.d_ff).fill(0)} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                    <BlockMath math="\xrightarrow{ReLU}"/>
                    <div className="viz-formula-row">
                        <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={LNd.Activated} rows={dims.seq_len} cols={dims.d_ff} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    </div>
                </div>
            </MathBlock>
            <MathBlock id="add_norm_3_dec" title="解码器组件：残差连接与层归一化 (3)" highlight={highlight}>
                 <p>同编码器中的 Add & Norm。</p>
                 <BlockMath math={`Y_{final} = \\text{LayerNorm}(Y'' + \\text{FFN}(Y''))`} />
            </MathBlock>
             <MathBlock id="final_output" title="最终输出层" highlight={highlight}>
                <h5>做什么？</h5>
                <p>在经过所有解码器层的处理后，我们得到一个最终的输出矩阵。此步骤将其转换为每个位置上词汇表中所有单词的概率分布。</p>
                 <h5>计算流程</h5>
                <ol>
                    <li><b>线性层 (Linear Layer):</b> 将解码器输出矩阵通过一个大的线性投影层，将其维度从 <InlineMath math="d_{model}"/> 扩展到词汇表大小 (<InlineMath math="V_{size}"/>)。这会为每个位置生成一个分数向量，称为 Logits。</li>
                    <li><b>Softmax:</b> 对 Logits 矩阵的每一行应用 Softmax 函数，将其转换为概率分布。概率最高的那个词，就是模型在当前位置的最终预测。</li>
                </ol>
                 <div className="formula-display">
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.finalLinear} rows={dims.d_model} cols={50} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                    <BlockMath math="\xrightarrow{\text{Softmax}}" />
                    <div className="matrix-scroll-wrapper"><InteractiveSymbolicMatrix name={MATRIX_NAMES.outputProbabilities} rows={dims.seq_len} cols={50} highlight={highlight} onSymbolClick={onSymbolClick}/></div>
                </div>
            </MathBlock>
        </div>
    );
};
// END OF FILE: src/components/Explanation.tsx


================================================================================
### 文件路径: src/components/FeedForward.tsx
================================================================================

// FILE: src/components/FeedForward.tsx
import React from 'react';
import { FFNData, HighlightState, ElementIdentifier, Matrix as MatrixType } from '../types';
import { Matrix } from './Matrix';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface FFNProps {
    baseName: string;
    input: MatrixType;
    inputName: string;
    data: FFNData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const FeedForward: React.FC<FFNProps> = ({ baseName, input, inputName, data, highlight, onElementClick }) => {
    const isActive = highlight.activeComponent === 'ffn';
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const LN = MATRIX_NAMES.layer(layerIndex);

    // --- Layout Breaking Logic ---
    const inputCols1 = input[0]?.length || 0;
    const w1Cols = data.W1[0]?.length || 0;
    const breakStep1 = inputCols1 > 15 || w1Cols > 15 || (inputCols1 + w1Cols > 15);

    const activatedCols = data.Activated[0]?.length || 0;
    const w2Cols = data.W2[0]?.length || 0;
    const breakStep2 = activatedCols > 15 || w2Cols > 15 || (activatedCols + w2Cols > 15);

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Feed-Forward Network</div>
            <div className="component-body">
                <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">1. First Linear Layer & ReLU</div>
                    {breakStep1 ? (
                        <>
                            <div className="viz-formula-row">
                                 <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                 <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                             <Matrix name={inputName} data={input} highlight={highlight} onElementClick={onElementClick} />
                             <span className="op-symbol">×</span>
                             <Matrix name={LN.W1} data={data.W1} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b1} data={[data.b1]} highlight={highlight} onElementClick={onElementClick} />
                    </div>

                    <ElementwiseOperation
                        opType="relu"
                        inputMatrix={data.Intermediate}
                        outputMatrix={data.Activated}
                        outputMatrixName={LN.Activated}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Second Linear Layer</div>
                    {breakStep2 ? (
                        <>
                            <div className="viz-formula-row">
                                 <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                 <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                            <Matrix name={LN.Activated} data={data.Activated} highlight={highlight} onElementClick={onElementClick} />
                            <span className="op-symbol">×</span>
                            <Matrix name={LN.W2} data={data.W2} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                    <div className="arrow-down">+</div>
                    <div className="viz-formula-row">
                         <Matrix name={LN.b2} data={[data.b2]} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={LN.ffn_output} data={data.Output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/FeedForward.tsx


================================================================================
### 文件路径: src/components/InteractiveSymbolicElement.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicElement.tsx
import React from 'react';
import { InlineMath } from 'react-katex';

interface InteractiveSymbolicElementProps {
  base: string;
  subscript?: string;
  row?: number;
  col?: number;
  isTarget?: boolean;
  isSource?: boolean;
  isDestination?: boolean;
  onClick: () => void;
}

export const InteractiveSymbolicElement: React.FC<InteractiveSymbolicElementProps> = React.memo(({ base, subscript, row, col, isTarget, isSource, isDestination, onClick }) => {
  const elementBase = base.toLowerCase().replace(/'/g, '').replace(/_{.*}/, '');
  const subscriptContent = [subscript, row, col].filter(s => s !== undefined && s !== null).join(',');
  const mathString = `${elementBase}_{${subscriptContent}}`;

  const className = `symbolic-element ${isTarget ? 'target' : ''} ${isSource ? 'source' : ''} ${isDestination ? 'destination' : ''}`;

  return (
    <div className={className} onClick={onClick} style={{cursor: 'pointer'}}>
      <InlineMath math={mathString} />
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicElement.tsx


================================================================================
### 文件路径: src/components/InteractiveSymbolicMatrix.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicMatrix.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicMatrixProps {
  name: string;
  rows: number;
  cols: number;
  highlight: HighlightState;
  transpose?: boolean;
  onSymbolClick: (element: ElementIdentifier) => void;
}

export const InteractiveSymbolicMatrix: React.FC<InteractiveSymbolicMatrixProps> = React.memo(({ name, rows, cols, highlight, transpose = false, onSymbolClick }) => {
  const displayRows = transpose ? cols : rows;
  const displayCols = transpose ? rows : cols;
  const symbol = getSymbolParts(name);

  let focusRow = -1;
  let focusCol = -1;

  if (highlight.target?.name === name) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const highlightedTarget = (highlight.target?.name === name) ? highlight.target : null;
  const highlightedSources = highlight.sources.filter(s => s.name === name);
  const highlightedDestinations = highlight.destinations?.filter(d => d.name === name) || [];

  const visibleRowIndices = getVisibleIndices(displayRows, transpose ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, transpose ? focusRow : focusCol);


  const gridElements = visibleRowIndices.map((r, rIdx) => {
    if (r === ELLIPSIS) {
        return visibleColIndices.map((c, cIdx) => (
             <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>
        ));
    }
    return visibleColIndices.map((c, cIdx) => {
        if (c === ELLIPSIS) {
            return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
        }

        const originalRow = transpose ? c : r;
        const originalCol = transpose ? r : c;

        const isTarget = !!highlightedTarget && highlightedTarget.row === originalRow && highlightedTarget.col === originalCol;

        const isSource = highlightedSources.some(s => {
          if (s.highlightRow) return s.row === originalRow;
          if (s.highlightCol) return s.col === originalCol;
          return s.row === originalRow && s.col === originalCol;
        });

        const isDestination = highlightedDestinations.some(d => {
            if (d.highlightRow) return d.row === originalRow;
            if (d.highlightCol) return d.col === originalCol;
            return d.row === originalRow && d.col === originalCol;
        });

        return (
            <InteractiveSymbolicElement
                key={`elem-r${r}-c${c}`}
                base={symbol.base}
                subscript={symbol.subscript}
                row={originalRow}
                col={originalCol}
                isTarget={isTarget}
                isSource={isSource}
                isDestination={isDestination}
                onClick={() => onSymbolClick({ name, row: originalRow, col: originalCol })}
            />
        );
    });
  });

  let mathSymbol = symbol.base;
  if (symbol.superscript) mathSymbol += `^{${symbol.superscript}}`;
  if (transpose) mathSymbol += '^T';

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`${rows} \\times ${cols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;

  return (
    <div className="symbolic-matrix-container">
      <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
      <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${visibleColIndices.length}, auto)` }}>
        {gridElements}
      </div>
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicMatrix.tsx


================================================================================
### 文件路径: src/components/InteractiveSymbolicVector.tsx
================================================================================

// FILE: src/components/InteractiveSymbolicVector.tsx
import React from 'react';
import { HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { Vector as VectorType } from '../types';
import { getSymbolParts } from '../config/symbolMapping';
import { InteractiveSymbolicElement } from './InteractiveSymbolicElement';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface InteractiveSymbolicVectorProps {
  name: string;
  data: VectorType;
  highlight: HighlightState;
  onSymbolClick: (element: ElementIdentifier) => void;
}

export const InteractiveSymbolicVector: React.FC<InteractiveSymbolicVectorProps> = React.memo(({ name, data, highlight, onSymbolClick }) => {
  const displayCols = data.length;
  const symbol = getSymbolParts(name);

  let focusCol = -1;
  if (highlight.target?.name === name) {
    focusCol = highlight.target.col;
  }
  const highlightedSources = highlight.sources.filter(s => s.name === name);
  const highlightedDestinations = highlight.destinations?.filter(d => d.name === name) || [];

  const visibleColIndices = getVisibleIndices(displayCols, focusCol);

  const gridElements = visibleColIndices.map((c, cIdx) => {
    if (c === ELLIPSIS) {
        return <div key={`ellipsis-c-${cIdx}`} className="symbolic-ellipsis">…</div>;
    }

    const isTarget = highlight.target?.name === name && highlight.target.col === c;
    const isSource = highlightedSources.some(s => s.col === c);
    const isDestination = highlightedDestinations.some(d => d.col === c);

    return (
        <InteractiveSymbolicElement
            key={`elem-${c}`}
            base={symbol.base}
            subscript={symbol.subscript}
            col={c}
            isTarget={isTarget}
            isSource={isSource}
            isDestination={isDestination}
            onClick={() => onSymbolClick({ name, row: 0, col: c })}
        />
    );
  });

  let mathSymbol = symbol.base;

  const subscriptParts = [];
  if (symbol.subscript) {
    subscriptParts.push(symbol.subscript);
  }
  subscriptParts.push(`1 \\times ${displayCols}`);
  mathSymbol += `_{${subscriptParts.join(',')}}`;


  return (
    <div className="symbolic-matrix-container">
      <div className="matrix-label"><InlineMath>{`${mathSymbol}`}</InlineMath></div>
      <div className="symbolic-matrix-grid" style={{ gridTemplateColumns: `repeat(${gridElements.length}, auto)` }}>
        {gridElements}
      </div>
    </div>
  );
});
// END OF FILE: src/components/InteractiveSymbolicVector.tsx


================================================================================
### 文件路径: src/components/MaskedMultiHeadAttention.tsx
================================================================================

// FILE: src/components/MaskedMultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface MHAProps {
    baseName: string; // e.g., decoder.0.masked_mha
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const MaskedMultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick }) => {
    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Assume we visualize head 0
    const headData = data.heads[headIndex];
    const isActive = highlight.activeComponent === 'masked_mha';

    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Masked Multi-Head Attention</div>
            <div className="component-body">
                {/* Visualizations for Q, K, V generation */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).Wq} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                       <span>=</span>
                       <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).Wk} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="viz-formula-row">
                       <span>(Input) ×</span>
                       <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).Wv} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                        <span>=</span>
                       <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                {/* Scaled Dot-Product Attention */}
                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).Q} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).K} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                    </div>
                    <div className="arrow-down">= (Scores)</div>
                    <div className="arrow-down" style={{fontSize: '1em', color: '#e63946', fontWeight: 'bold'}}>Apply Look-Ahead Mask</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).Scores} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).ScaledScores} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).AttentionWeights}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="viz-formula-row">
                        <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).AttentionWeights} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                        <InlineMath math="\times" />
                        <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).V} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                     <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                         <Matrix name={MATRIX_NAMES.maskedMhaHead(layerIndex, headIndex).HeadOutput} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                {/* Final Projection */}
                 <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                    <div className="viz-formula-row">
                       <InlineMath math="\text{Concat}(H_0, \dots, H_{N})" />
                     </div>
                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).Wo_masked} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={MATRIX_NAMES.decoderLayer(layerIndex).masked_mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>

            </div>
        </div>
    );
};
// END OF FILE: src/components/MaskedMultiHeadAttention.tsx


================================================================================
### 文件路径: src/components/Matrix.tsx
================================================================================

// FILE: src/components/Matrix.tsx
import React from 'react';
import { Element } from './Element';
import { Matrix as MatrixType, HighlightState, ElementIdentifier } from '../types';
import { InlineMath } from 'react-katex';
import { getSymbolParts } from '../config/symbolMapping';
import { getVisibleIndices, ELLIPSIS } from '../utils/matrixView';

interface MatrixProps {
  name: string;
  data: MatrixType;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
  isTransposed?: boolean;
}

export const Matrix: React.FC<MatrixProps> = ({ name, data, highlight, onElementClick, isTransposed = false }) => {
  if (!data || data.length === 0 || data[0].length === 0) {
    return <div>Invalid matrix data for {name}</div>;
  }

  const numRows = data.length;
  const numCols = data[0].length;

  const displayRows = isTransposed ? numCols : numRows;
  const displayCols = isTransposed ? numRows : numCols;

  let focusRow = -1;
  let focusCol = -1;

  if(highlight.target?.name === name && !highlight.target.isInternal) {
    focusRow = highlight.target.row;
    focusCol = highlight.target.col;
  }

  const relevantSource = highlight.sources.find(s => s.name === name && !s.isInternal);
  if (relevantSource) {
      focusRow = relevantSource.row === -1 ? focusRow : relevantSource.row;
      focusCol = relevantSource.col === -1 ? focusCol : relevantSource.col;
  }

  const relevantDestination = highlight.destinations?.find(d => d.name === name && !d.isInternal);
    if (relevantDestination) {
        focusRow = relevantDestination.row === -1 ? focusRow : relevantDestination.row;
        focusCol = relevantDestination.col === -1 ? focusCol : relevantDestination.col;
    }


  const visibleRowIndices = getVisibleIndices(displayRows, isTransposed ? focusCol : focusRow);
  const visibleColIndices = getVisibleIndices(displayCols, isTransposed ? focusRow : focusCol);

  const gridTemplateColumns = `repeat(${visibleColIndices.length}, auto)`;

  const symbolParts = getSymbolParts(name);
  let mathSymbol = symbolParts.base;
  if(symbolParts.superscript) mathSymbol = `${mathSymbol}^{${symbolParts.superscript}}`;
  if(symbolParts.subscript) mathSymbol = `${mathSymbol}_{${symbolParts.subscript}}`;
  if(isTransposed) mathSymbol = `${mathSymbol}^T`;

  const gridElements = visibleRowIndices.map((r, rIdx) => {
    if (r === ELLIPSIS) {
        return visibleColIndices.map((c, cIdx) => (
             <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">{c === ELLIPSIS ? '⋱' : '…'}</div>
        ));
    }
    return visibleColIndices.map((c, cIdx) => {
        if (c === ELLIPSIS) {
            return <div key={`ellipsis-r-${rIdx}-c-${cIdx}`} className="matrix-ellipsis">…</div>;
        }
        const displayRow = r;
        const displayCol = c;
        const originalRow = isTransposed ? displayCol : displayRow;
        const originalCol = isTransposed ? displayRow : displayCol;
        const value = data[originalRow][originalCol];
        return (
             <Element
              key={`${name}-${originalRow}-${originalCol}`}
              name={name}
              row={originalRow}
              col={originalCol}
              value={value}
              highlight={highlight}
              onElementClick={onElementClick}
            />
        )
    });
  });


  return (
    <div className="matrix-wrapper">
      <div className="matrix-container">
        <div className="matrix-grid" style={{ gridTemplateColumns }}>
          {gridElements}
        </div>
      </div>
      <div className="matrix-label-container">
        <div className="matrix-symbol-tag"><InlineMath>{mathSymbol}</InlineMath></div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/Matrix.tsx


================================================================================
### 文件路径: src/components/MultiHeadAttention.tsx
================================================================================

// FILE: src/components/MultiHeadAttention.tsx
import React from 'react';
import { MultiHeadAttentionData, HighlightState, ElementIdentifier } from '../types';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';
import { MATRIX_NAMES } from '../config/matrixNames';
import { ElementwiseOperation } from './ElementwiseOperation';

interface MHAProps {
    baseName: string;
    data: MultiHeadAttentionData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const MultiHeadAttention: React.FC<MHAProps> = ({ baseName, data, highlight, onElementClick }) => {
    const headData = data.heads[0];
    const headBaseName = `${baseName}.h0`;
    const isActive = highlight.activeComponent === 'mha';

    const layerIndex = parseInt(baseName.split('.')[1], 10);
    const headIndex = 0; // Visualizing head 0
    const LN = MATRIX_NAMES.layer(layerIndex);
    const numHeads = data.heads.length;

    const renderConcatHeads = () => {
        const headsToShow = [];
        // First head
        headsToShow.push(<Matrix key={0} name={MATRIX_NAMES.head(layerIndex, 0).HeadOutput} data={data.heads[0].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);

        if (numHeads > 2) {
             // Middle ellipsis
            headsToShow.push(<div key="ellipsis-start" className="op-symbol">...</div>);
            // Last head
            headsToShow.push(<Matrix key={numHeads-1} name={MATRIX_NAMES.head(layerIndex, numHeads-1).HeadOutput} data={data.heads[numHeads-1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        } else if (numHeads === 2) {
            // Second head
            headsToShow.push(<Matrix key={1} name={MATRIX_NAMES.head(layerIndex, 1).HeadOutput} data={data.heads[1].HeadOutput} highlight={highlight} onElementClick={onElementClick} />);
        }
        return headsToShow;
    };


    // --- Layout Breaking Logic ---
    const wqCols = headData.Wq[0]?.length || 0;
    const qCols = headData.Q[0]?.length || 0;
    const breakQ = wqCols > 15 || qCols > 15 || (wqCols + qCols > 15);

    const wkCols = headData.Wk[0]?.length || 0;
    const kCols = headData.K[0]?.length || 0;
    const breakK = wkCols > 15 || kCols > 15 || (wkCols + kCols > 15);

    const wvCols = headData.Wv[0]?.length || 0;
    const vCols = headData.V[0]?.length || 0;
    const breakV = wvCols > 15 || vCols > 15 || (wvCols + vCols > 15);

    const kTransposedCols = headData.K.length;
    const breakScores = qCols > 15 || kTransposedCols > 15 || (qCols + kTransposedCols > 15);

    const attnWeightsCols = headData.AttentionWeights[0]?.length || 0;
    const breakHeadOutput = attnWeightsCols > 15 || vCols > 15 || (attnWeightsCols + vCols > 15);


    return (
        <div className={`diagram-component ${isActive ? 'active' : ''}`}>
            <div className="component-header">Multi-Head Attention</div>
            <div className="component-body">
                <p>Input (from previous layer)</p>
                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">1. Generate Q, K, V (Head 1)</div>
                    {breakQ ? (
                        <>
                            <div className="viz-formula-row">
                               <span>(Input) ×</span>
                               <Matrix name={`${headBaseName}.Wq`} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="arrow-down">=</div>
                            <div className="viz-formula-row">
                               <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                           <span>(Input) ×</span>
                           <Matrix name={`${headBaseName}.Wq`} data={headData.Wq} highlight={highlight} onElementClick={onElementClick} />
                           <span>=</span>
                           <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                     {breakK ? (
                        <>
                             <div className="viz-formula-row">
                               <span>(Input) ×</span>
                               <Matrix name={`${headBaseName}.Wk`} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="arrow-down">=</div>
                            <div className="viz-formula-row">
                               <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                           <span>(Input) ×</span>
                           <Matrix name={`${headBaseName}.Wk`} data={headData.Wk} highlight={highlight} onElementClick={onElementClick} />
                            <span>=</span>
                           <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                     {breakV ? (
                        <>
                            <div className="viz-formula-row">
                               <span>(Input) ×</span>
                               <Matrix name={`${headBaseName}.Wv`} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="arrow-down">=</div>
                            <div className="viz-formula-row">
                               <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                           <span>(Input) ×</span>
                           <Matrix name={`${headBaseName}.Wv`} data={headData.Wv} highlight={highlight} onElementClick={onElementClick} />
                            <span>=</span>
                           <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">2. Scaled Dot-Product Attention (Head 1)</div>
                    {breakScores ? (
                        <>
                             <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                            </div>
                        </>
                    ) : (
                         <div className="viz-formula-row">
                            <Matrix name={`${headBaseName}.Q`} data={headData.Q} highlight={highlight} onElementClick={onElementClick} />
                            <InlineMath math="\times" />
                            <Matrix name={`${headBaseName}.K`} data={headData.K} highlight={highlight} onElementClick={onElementClick} isTransposed={true}/>
                        </div>
                    )}
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.Scores`} data={headData.Scores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Scale by } / \sqrt{d_k}}" /></div>
                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.ScaledScores`} data={headData.ScaledScores} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    <ElementwiseOperation
                        opType="softmax"
                        inputMatrix={headData.ScaledScores}
                        outputMatrix={headData.AttentionWeights}
                        outputMatrixName={`${headBaseName}.AttentionWeights`}
                        highlight={highlight}
                        onElementClick={onElementClick}
                        layerIndex={layerIndex}
                        headIndex={headIndex}
                    />

                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                    </div>

                    {breakHeadOutput ? (
                        <>
                            <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                            </div>
                            <div className="op-symbol">×</div>
                            <div className="viz-formula-row">
                                <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                            </div>
                        </>
                    ) : (
                        <div className="viz-formula-row">
                            <Matrix name={`${headBaseName}.AttentionWeights`} data={headData.AttentionWeights} highlight={highlight} onElementClick={onElementClick}/>
                            <InlineMath math="\times" />
                            <Matrix name={`${headBaseName}.V`} data={headData.V} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                    <div className="arrow-down">=</div>
                    <div className="viz-formula-row">
                        <Matrix name={`${headBaseName}.HeadOutput`} data={headData.HeadOutput} highlight={highlight} onElementClick={onElementClick}/>
                    </div>
                </div>

                <div className="arrow-down">↓</div>

                <div className="viz-formula-group">
                    <div className="viz-step-title">3. Concat & Final Projection</div>
                    <div className="viz-formula-row">
                       <InlineMath math="\text{Concat}(" />
                        {renderConcatHeads()}
                       <InlineMath math=")" />
                     </div>

                     <div className="viz-formula-row">
                       <span>(Concatenated) ×</span>
                       <Matrix name={`${baseName}.Wo`} data={data.Wo} highlight={highlight} onElementClick={onElementClick} />
                     </div>
                     <div className="arrow-down">=</div>
                     <div className="viz-formula-row">
                       <Matrix name={LN.mha_output} data={data.output} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/MultiHeadAttention.tsx


================================================================================
### 文件路径: src/components/ResidualBlock.tsx
================================================================================

// FILE: src/components/ResidualBlock.tsx
import React from 'react';
import { ElementIdentifier, HighlightState } from '../types';
import { InlineMath } from 'react-katex';

interface ResidualBlockProps {
  id: string; // e.g., "res1"
  type: 'start' | 'end';
  matrixSymbol: string;
  matrixDims: string;
  highlight: HighlightState;
  onElementClick: (element: ElementIdentifier) => void;
}

export const ResidualBlock: React.FC<ResidualBlockProps> = ({ id, type, matrixSymbol, matrixDims, highlight, onElementClick }) => {
  const isActive = highlight.activeResidual === id;
  const isStart = type === 'start';
  const icon = isStart ? '↓' : '→';

  const handleClick = () => {
    onElementClick({
      name: `residual.${id}.${type}`,
      row: -1,
      col: -1,
      matrixSymbol,
      matrixDims,
    });
  };

  return (
    <div
      className={`residual-block ${isActive ? 'active' : ''}`}
      onClick={handleClick}
      title={`Residual Connection (${matrixSymbol})`}
    >
      <div className="residual-icon">{icon}</div>
      <div className="residual-info">
          <div className="residual-matrix-symbol"><InlineMath math={matrixSymbol} /></div>
          <div className="residual-matrix-dims">{matrixDims}</div>
      </div>
    </div>
  );
};
// END OF FILE: src/components/ResidualBlock.tsx


================================================================================
### 文件路径: src/components/Viz.tsx
================================================================================

// FILE: src/components/Viz.tsx
import React from 'react';
import { TransformerData, HighlightState, ElementIdentifier } from '../types';
import { EncoderLayer } from './EncoderLayer';
import { DecoderLayer } from './DecoderLayer';
import { Matrix } from './Matrix';
import { InlineMath } from 'react-katex';

interface VizProps {
    data: TransformerData;
    highlight: HighlightState;
    onElementClick: (element: ElementIdentifier) => void;
}

export const Viz: React.FC<VizProps> = ({ data, highlight, onElementClick }) => {
    const isInputEmbedActive = highlight.activeComponent === 'input_embed';
    const isOutputEmbedActive = highlight.activeComponent === 'output_embed';
    const isFinalOutputActive = highlight.activeComponent === 'final_output';

    const cols = data.inputEmbeddings[0]?.length || 0;
    const shouldBreak = cols > 15;

    return (
        <div>
            {/* --- Encoder Side --- */}
            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header">Encoder Input & Positional Encoding</div>
                <div className="component-body">
                    {shouldBreak ? (
                         <>
                            <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                            <div className="op-symbol">+</div>
                            <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                         </>
                    ) : (
                        <div className="viz-formula-row">
                             <Matrix name="inputEmbeddings" data={data.inputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                             <div className="op-symbol">+</div>
                             <Matrix name="posEncodings" data={data.posEncodings} highlight={highlight} onElementClick={onElementClick} />
                        </div>
                    )}
                </div>
            </div>

            <div className="arrow-down">↓</div>

            <div className={`diagram-component ${isInputEmbedActive ? 'active' : ''}`}>
                <div className="component-header">Encoder Input (<InlineMath math="Z_0" />)</div>
                <div className="component-body">
                     <Matrix name="encoderInput" data={data.encoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.encoderLayers.map((layer, i) => (
                <EncoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
            ))}

            {/* --- Decoder Side --- */}
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`} style={{marginTop: '30px'}}>
                <div className="component-header">Decoder Input & Positional Encoding</div>
                <div className="component-body">
                     <div className="viz-formula-row">
                         <Matrix name="outputEmbeddings" data={data.outputEmbeddings} highlight={highlight} onElementClick={onElementClick} />
                         <div className="op-symbol">+</div>
                         <Matrix name="decoderPosEncodings" data={data.decoderPosEncodings} highlight={highlight} onElementClick={onElementClick} />
                    </div>
                </div>
            </div>
            <div className="arrow-down">↓</div>
            <div className={`diagram-component ${isOutputEmbedActive ? 'active' : ''}`}>
                <div className="component-header">Decoder Input (<InlineMath math="Y_0" />)</div>
                <div className="component-body">
                     <Matrix name="decoderInput" data={data.decoderInput} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>

            {data.decoderLayers.map((layer, i) => (
                <DecoderLayer
                    key={i}
                    layerIndex={i}
                    data={layer}
                    highlight={highlight}
                    onElementClick={onElementClick}
                />
            ))}

            {/* --- Final Output --- */}
            <div className="arrow-down">↓</div>
             <div className={`diagram-component ${isFinalOutputActive ? 'active' : ''}`}>
                <div className="component-header">Final Linear & Softmax</div>
                <div className="component-body">
                    <Matrix name="finalLinear" data={data.finalLinear} highlight={highlight} onElementClick={onElementClick} />
                    <div className="arrow-down">↓</div>
                    <Matrix name="logits" data={data.logits} highlight={highlight} onElementClick={onElementClick} />
                    <div className="arrow-down"><InlineMath math="\xrightarrow{\text{Softmax}}" /></div>
                    <Matrix name="outputProbabilities" data={data.outputProbabilities} highlight={highlight} onElementClick={onElementClick} />
                </div>
            </div>
        </div>
    );
};
// END OF FILE: src/components/Viz.tsx


================================================================================
### 文件路径: src/config/matrixNames.ts
================================================================================

// FILE: src/config/matrixNames.ts
// This file is the single source of truth for all matrix and vector names.

const generateHeadNames = (base: string) => ({
    Wq: `${base}.Wq`, Wk: `${base}.Wk`, Wv: `${base}.Wv`,
    Q: `${base}.Q`, K: `${base}.K`, V: `${base}.V`,
    Scores: `${base}.Scores`, ScaledScores: `${base}.ScaledScores`,
    AttentionWeights: `${base}.AttentionWeights`, HeadOutput: `${base}.HeadOutput`,
});

export const MATRIX_NAMES = {
    // Input
    inputEmbeddings: 'inputEmbeddings',
    posEncodings: 'posEncodings',
    encoderInput: 'encoderInput',
    finalEncoderOutput: 'finalEncoderOutput', // [ADDED]

    // Encoder Layer
    layer: (layerIndex: number) => ({
        encoder_input: `encoder.${layerIndex}.encoder_input`,
        mha_output: `encoder.${layerIndex}.mha.output`,
        Wo: `encoder.${layerIndex}.mha.Wo`,
        add_norm_1_output: `encoder.${layerIndex}.add_norm_1_output`,
        W1: `encoder.${layerIndex}.ffn.W1`, b1: `encoder.${layerIndex}.ffn.b1`,
        Intermediate: `encoder.${layerIndex}.ffn.Intermediate`, Activated: `encoder.${layerIndex}.ffn.Activated`,
        W2: `encoder.${layerIndex}.ffn.W2`, b2: `encoder.${layerIndex}.ffn.b2`,
        ffn_output: `encoder.${layerIndex}.ffn.output`,
        add_norm_2_output: `encoder.${layerIndex}.add_norm_2_output`,
    }),

    // Encoder Head
    head: (layerIndex: number, headIndex: number) => generateHeadNames(`encoder.${layerIndex}.mha.h${headIndex}`),
    concatOutput: (layerIndex: number) => `encoder.${layerIndex}.mha.ConcatOutput`,

    // Decoder Input
    outputEmbeddings: 'outputEmbeddings',
    decoderPosEncodings: 'decoderPosEncodings',
    decoderInput: 'decoderInput',

    // Decoder Layer
    decoderLayer: (layerIndex: number) => ({
        decoder_input: `decoder.${layerIndex}.decoder_input`,

        masked_mha_output: `decoder.${layerIndex}.masked_mha.output`,
        Wo_masked: `decoder.${layerIndex}.masked_mha.Wo`,
        add_norm_1_output: `decoder.${layerIndex}.add_norm_1_output`,

        enc_dec_mha_output: `decoder.${layerIndex}.enc_dec_mha.output`,
        Wo_enc_dec: `decoder.${layerIndex}.enc_dec_mha.Wo`,
        add_norm_2_output: `decoder.${layerIndex}.add_norm_2_output`,

        W1: `decoder.${layerIndex}.ffn.W1`, b1: `decoder.${layerIndex}.ffn.b1`,
        Intermediate: `decoder.${layerIndex}.ffn.Intermediate`, Activated: `decoder.${layerIndex}.ffn.Activated`,
        W2: `decoder.${layerIndex}.ffn.W2`, b2: `decoder.${layerIndex}.ffn.b2`,
        ffn_output: `decoder.${layerIndex}.ffn.output`,
        add_norm_3_output: `decoder.${layerIndex}.add_norm_3_output`,
    }),

    // Decoder Heads
    maskedMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.masked_mha.h${headIndex}`),
    encDecMhaHead: (layerIndex: number, headIndex: number) => generateHeadNames(`decoder.${layerIndex}.enc_dec_mha.h${headIndex}`),

    // Final Output
    finalLinear: 'finalLinear',
    logits: 'logits',
    outputProbabilities: 'outputProbabilities',
};
// END OF FILE: src/config/matrixNames.ts


================================================================================
### 文件路径: src/config/symbolMapping.ts
================================================================================

// FILE: src/config/symbolMapping.ts

// This file is the single source of truth for mapping a matrix's unique name
// to its mathematical symbol parts for consistent rendering.

interface SymbolParts {
    base: string;
    superscript?: string;
    subscript?: string;
}

const SYMBOL_CONFIG: { [key: string]: SymbolParts } = {
    // Input
    inputEmbeddings: { base: 'E' },
    posEncodings: { base: 'PE' },
    encoderInput: { base: 'Z' }, // Z_0
    encoder_input: { base: 'Z' },

    // MHA Weights
    Wq: { base: 'W', superscript: 'Q' },
    Wk: { base: 'W', superscript: 'K' },
    Wv: { base: 'W', superscript: 'V' },
    Wo: { base: 'W', superscript: 'O' },

    // MHA Tensors
    Q: { base: 'Q' },
    K: { base: 'K' },
    V: { base: 'V' },
    Scores: { base: 'S' },
    ScaledScores: { base: "S'" },
    AttentionWeights: { base: 'A' },
    HeadOutput: { base: 'H' },
    ConcatOutput: { base: 'H', subscript: 'cat'},
    output: { base: 'M' },
    mha_output: { base: 'M' },

    // Add & Norm
    add_norm_1_output: { base: "Z'" },
    add_norm_2_output: { base: "Z''" },
    add_norm_3_output: { base: "Z'''" },

    // FFN
    W1: { base: 'W', subscript: '1' },
    b1: { base: 'b', subscript: '1' },
    Intermediate: { base: 'H', subscript: 'ffn' },
    Activated: { base: 'H', subscript: 'act' },
    W2: { base: 'W', subscript: '2' },
    b2: { base: 'b', subscript: '2' },
    ffn_output: { base: 'F' },

    // --- Decoder Specific ---
    outputEmbeddings: { base: 'E', subscript: 'out' },
    decoderPosEncodings: { base: 'PE', subscript: 'dec' },
    decoderInput: { base: 'Y' }, // Y_0
    decoder_input: { base: 'Y' },

    masked_mha_output: { base: 'M', subscript: 'mmha' },
    Wo_masked: { base: 'W', superscript: 'O' },

    enc_dec_mha_output: { base: 'M', subscript: 'ed' },
    Wo_enc_dec: { base: 'W', superscript: 'O' },

    // Final Output
    finalLinear: { base: 'W', subscript: 'proj' },
    logits: { base: 'L' },
    outputProbabilities: { base: 'P' },
};

/**
 * Gets the consistent mathematical symbol parts for a given matrix name.
 * @param name The full, unique name of the matrix (e.g., "encoder.0.add_norm_1_output").
 * @returns An object with base, superscript, and subscript parts.
 */
export const getSymbolParts = (name: string): SymbolParts => {
    const conceptualName = name.split('.').pop() || '';
    if (conceptualName.startsWith('Wq') || conceptualName.startsWith('Wk') || conceptualName.startsWith('Wv') || conceptualName.startsWith('Wo')) {
        return SYMBOL_CONFIG[conceptualName.substring(0,2)];
    }
    return SYMBOL_CONFIG[conceptualName] || { base: 'X' }; // Default to 'X' if not found
};
// END OF FILE: src/config/symbolMapping.ts


================================================================================
### 文件路径: src/hooks/useTransformer.ts
================================================================================

// FILE: src/hooks/useTransformer.ts
import { useMemo } from 'react';
import { Matrix, TransformerData, EncoderLayerData, FFNData, MultiHeadAttentionData, AttentionHeadData, Vector, DecoderLayerData } from '../types';

// --- Utility Functions ---

const createRandomMatrix = (rows: number, cols: number): Matrix => {
  return Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)))
  );
};

const createRandomVector = (size: number): Vector => {
  return Array.from({ length: size }, () => parseFloat((Math.random() * 2 - 1).toFixed(2)));
}

const addMatrices = (A: Matrix, B: Matrix): Matrix => {
  return A.map((row, i) =>
    row.map((val, j) => parseFloat((val + B[i][j]).toFixed(2)))
  );
};

const multiplyMatrices = (A: Matrix, B: Matrix): Matrix => {
  const rowsA = A.length;
  const colsA = A[0].length;
  const colsB = B[0].length;
  const result: Matrix = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));

  for (let i = 0; i < rowsA; i++) {
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      result[i][j] = parseFloat(sum.toFixed(2));
    }
  }
  return result;
};

const scaleMatrix = (A: Matrix, scalar: number): Matrix => {
    return A.map(row => row.map(val => parseFloat((val / scalar).toFixed(2))));
}

const softmaxByRow = (A: Matrix): Matrix => {
    return A.map(row => {
        const maxVal = Math.max(...row.filter(v => isFinite(v)));
        const exps = row.map(val => isFinite(val) ? Math.exp(val - maxVal) : 0);
        const sumExps = exps.reduce((a, b) => a + b, 0);
        if (sumExps === 0) return row.map(() => 1 / row.length); // Avoid division by zero
        return exps.map(exp => parseFloat((exp / sumExps).toFixed(2)));
    });
}

const layerNorm = (A: Matrix): Matrix => {
    return A.map(row => {
        const mean = row.reduce((a,b) => a+b, 0) / row.length;
        const variance = row.map(x => (x - mean) ** 2).reduce((a,b) => a+b,0) / row.length;
        const std = Math.sqrt(variance + 1e-5);
        return row.map(x => parseFloat(((x - mean) / std).toFixed(2)));
    });
}

const applyReLU = (A: Matrix): Matrix => {
    return A.map(row => row.map(val => Math.max(0, val)));
}

const addBias = (A: Matrix, b: Vector): Matrix => {
    return A.map(row => row.map((val, j) => parseFloat((val + b[j]).toFixed(2))));
}

const applyMask = (A: Matrix, maskValue = -Infinity): Matrix => {
    return A.map((row, i) =>
        row.map((val, j) => (j > i ? maskValue : val))
    );
};


// --- Main Hook ---

interface Dims {
    d_model: number;
    h: number;
    seq_len: number;
    n_layers: number;
    d_ff: number;
}

export const useTransformer = (dims: Dims): TransformerData | null => {

  return useMemo(() => {
    try {
        const { d_model, h, seq_len, n_layers, d_ff } = dims;
        if (d_model % h !== 0) return null;
        const d_k = d_model / h;

        // --- ENCODER ---
        const inputEmbeddings = createRandomMatrix(seq_len, d_model);
        const posEncodings: Matrix = Array.from({ length: seq_len }, (_, pos) =>
          Array.from({ length: d_model }, (_, i) =>
            parseFloat((i % 2 === 0
              ? Math.sin(pos / (10000 ** (i / d_model)))
              : Math.cos(pos / (10000 ** ((i - 1) / d_model)))).toFixed(2))
          )
        );
        const encoderInput = addMatrices(inputEmbeddings, posEncodings);

        let currentEncoderInput = encoderInput;
        const encoderLayers: EncoderLayerData[] = [];

        for (let i = 0; i < n_layers; i++) {
            const encoder_input = currentEncoderInput;
            const heads: AttentionHeadData[] = [];
            const headOutputs: Matrix[] = [];
            for(let j=0; j < h; j++) {
                const Wq = createRandomMatrix(d_model, d_k);
                const Wk = createRandomMatrix(d_model, d_k);
                const Wv = createRandomMatrix(d_model, d_k);
                const Q = multiplyMatrices(encoder_input, Wq);
                const K = multiplyMatrices(encoder_input, Wk);
                const V = multiplyMatrices(encoder_input, Wv);
                const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: seq_len }, (_, c) => K[c][r]));
                const Scores = multiplyMatrices(Q, K_T);
                const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
                const AttentionWeights = softmaxByRow(ScaledScores);
                const HeadOutput = multiplyMatrices(AttentionWeights, V);
                heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
                headOutputs.push(HeadOutput);
            }
            const ConcatOutput = headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(seq_len).fill(0).map(() => []));
            const Wo = createRandomMatrix(d_model, d_model);
            const mha_output = multiplyMatrices(ConcatOutput, Wo);
            const mha: MultiHeadAttentionData = { heads, Wo, output: mha_output };
            const add_norm_1_output = layerNorm(addMatrices(encoder_input, mha_output));
            const W1 = createRandomMatrix(d_model, d_ff);
            const b1 = createRandomVector(d_ff);
            const Intermediate = addBias(multiplyMatrices(add_norm_1_output, W1), b1);
            const Activated = applyReLU(Intermediate);
            const W2 = createRandomMatrix(d_ff, d_model);
            const b2 = createRandomVector(d_model);
            const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
            const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
            const add_norm_2_output = layerNorm(addMatrices(add_norm_1_output, ffn_output));
            encoderLayers.push({ encoder_input, mha, mha_output, add_norm_1_output, ffn, ffn_output, add_norm_2_output });
            currentEncoderInput = add_norm_2_output;
        }
        const finalEncoderOutput = currentEncoderInput;

        // --- DECODER ---
        const outputEmbeddings = createRandomMatrix(seq_len, d_model);
        const decoderPosEncodings = posEncodings;
        const decoderInput = addMatrices(outputEmbeddings, decoderPosEncodings);

        let currentDecoderInput = decoderInput;
        const decoderLayers: DecoderLayerData[] = [];

        for (let i = 0; i < n_layers; i++) {
            const decoder_input = currentDecoderInput;

            const masked_mha_heads: AttentionHeadData[] = [];
            const masked_mha_headOutputs: Matrix[] = [];
            for (let j = 0; j < h; j++) {
                const Wq = createRandomMatrix(d_model, d_k);
                const Wk = createRandomMatrix(d_model, d_k);
                const Wv = createRandomMatrix(d_model, d_k);
                const Q = multiplyMatrices(decoder_input, Wq);
                const K = multiplyMatrices(decoder_input, Wk);
                const V = multiplyMatrices(decoder_input, Wv);
                const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: seq_len }, (_, c) => K[c][r]));
                const Scores = applyMask(multiplyMatrices(Q, K_T));
                const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
                const AttentionWeights = softmaxByRow(ScaledScores);
                const HeadOutput = multiplyMatrices(AttentionWeights, V);
                masked_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
                masked_mha_headOutputs.push(HeadOutput);
            }
            const masked_ConcatOutput = masked_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(seq_len).fill(0).map(() => []));
            const masked_Wo = createRandomMatrix(d_model, d_model);
            const masked_mha_output = multiplyMatrices(masked_ConcatOutput, masked_Wo);
            const masked_mha: MultiHeadAttentionData = { heads: masked_mha_heads, Wo: masked_Wo, output: masked_mha_output };
            const dec_add_norm_1_output = layerNorm(addMatrices(decoder_input, masked_mha_output));

            const enc_dec_mha_heads: AttentionHeadData[] = [];
            const enc_dec_mha_headOutputs: Matrix[] = [];
             for (let j = 0; j < h; j++) {
                const Wq = createRandomMatrix(d_model, d_k);
                const Wk = createRandomMatrix(d_model, d_k);
                const Wv = createRandomMatrix(d_model, d_k);
                const Q = multiplyMatrices(dec_add_norm_1_output, Wq);
                const K = multiplyMatrices(finalEncoderOutput, Wk);
                const V = multiplyMatrices(finalEncoderOutput, Wv);
                const K_T = Array.from({ length: d_k }, (_, r) => Array.from({ length: seq_len }, (_, c) => K[c][r]));
                const Scores = multiplyMatrices(Q, K_T);
                const ScaledScores = scaleMatrix(Scores, Math.sqrt(d_k));
                const AttentionWeights = softmaxByRow(ScaledScores);
                const HeadOutput = multiplyMatrices(AttentionWeights, V);
                enc_dec_mha_heads.push({ Wq, Wk, Wv, Q, K, V, Scores, ScaledScores, AttentionWeights, HeadOutput });
                enc_dec_mha_headOutputs.push(HeadOutput);
            }
            const enc_dec_ConcatOutput = enc_dec_mha_headOutputs.reduce((acc, current) => acc.map((row, rIdx) => [...row, ...current[rIdx]]), Array(seq_len).fill(0).map(() => []));
            const enc_dec_Wo = createRandomMatrix(d_model, d_model);
            const enc_dec_mha_output = multiplyMatrices(enc_dec_ConcatOutput, enc_dec_Wo);
            const enc_dec_mha: MultiHeadAttentionData = { heads: enc_dec_mha_heads, Wo: enc_dec_Wo, output: enc_dec_mha_output };
            const dec_add_norm_2_output = layerNorm(addMatrices(dec_add_norm_1_output, enc_dec_mha_output));

            const W1 = createRandomMatrix(d_model, d_ff);
            const b1 = createRandomVector(d_ff);
            const Intermediate = addBias(multiplyMatrices(dec_add_norm_2_output, W1), b1);
            const Activated = applyReLU(Intermediate);
            const W2 = createRandomMatrix(d_ff, d_model);
            const b2 = createRandomVector(d_model);
            const ffn_output = addBias(multiplyMatrices(Activated, W2), b2);
            const ffn: FFNData = { W1, b1, Intermediate, Activated, W2, b2, Output: ffn_output };
            const dec_add_norm_3_output = layerNorm(addMatrices(dec_add_norm_2_output, ffn_output));

            decoderLayers.push({ decoder_input, masked_mha, masked_mha_output, add_norm_1_output: dec_add_norm_1_output, enc_dec_mha, enc_dec_mha_output, add_norm_2_output: dec_add_norm_2_output, ffn, ffn_output, add_norm_3_output: dec_add_norm_3_output });
            currentDecoderInput = dec_add_norm_3_output;
        }
        const finalDecoderOutput = currentDecoderInput;

        const vocab_size = 50;
        const finalLinear = createRandomMatrix(d_model, vocab_size);
        const logits = multiplyMatrices(finalDecoderOutput, finalLinear);
        const outputProbabilities = softmaxByRow(logits);

        return {
            inputEmbeddings,
            posEncodings,
            encoderInput,
            encoderLayers,
            finalEncoderOutput,
            outputEmbeddings,
            decoderPosEncodings,
            decoderInput,
            decoderLayers,
            finalDecoderOutput,
            finalLinear,
            logits,
            outputProbabilities
        };
    } catch (e) {
        console.error("Error during transformer calculation:", e);
        return null;
    }
  }, [dims]);
};
// END OF FILE: src/hooks/useTransformer.ts


================================================================================
### 文件路径: src/utils/matrixView.ts
================================================================================

// FILE: src/utils/matrixView.ts
export const ELLIPSIS = '...';
const MIN_SIZE_FOR_TRUNCATION = 12; // e.g., 4 + 3 + 4 + 1 ellipsis = 12

/**
 * Calculates the visible indices for a row or column of a matrix based on a focus point.
 * It always shows the first and last `alwaysShowCount` items.
 * It shows a `windowSize` around the `focusIndex`.
 *
 * @param totalSize - The total number of items (rows or columns).
 * @param focusIndex - The index of the focused item, or -1 if no focus.
 * @param alwaysShowCount - The number of items to always show at the beginning and end.
 * @param windowSize - The size of the focus window around the focusIndex.
 * @returns An array of indices to display, with ELLIPSIS string for gaps.
 */
export const getVisibleIndices = (
  totalSize: number,
  focusIndex: number = -1,
  alwaysShowCount: number = 4,
  windowSize: number = 9
): (number | typeof ELLIPSIS)[] => {

  if (totalSize < MIN_SIZE_FOR_TRUNCATION) {
    return Array.from({ length: totalSize }, (_, i) => i);
  }

  const visible = new Set<number>();

  // 1. Add always-visible indices
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(i);
  }
  for (let i = 0; i < Math.min(alwaysShowCount, totalSize); i++) {
    visible.add(totalSize - 1 - i);
  }

  // 2. Add focus window indices
  if (focusIndex !== -1) {
    const windowStart = Math.max(0, focusIndex - Math.floor(windowSize / 2));
    const windowEnd = Math.min(totalSize - 1, focusIndex + Math.floor(windowSize / 2));
    for (let i = windowStart; i <= windowEnd; i++) {
      visible.add(i);
    }
  }

  // 3. Build the final array with ellipses for gaps
  const sorted = Array.from(visible).sort((a, b) => a - b);
  const result: (number | typeof ELLIPSIS)[] = [];

  if (sorted.length > 0) {
    result.push(sorted[0]);
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] > sorted[i - 1] + 1) {
        result.push(ELLIPSIS);
      }
      result.push(sorted[i]);
    }
  }

  return result;
};
// END OF FILE: src/utils/matrixView.ts


================================================================================
### 文件路径: public/index.html
================================================================================

<!-- START OF FILE: public/index.html -->
<!--# FILE: public/index.html-->

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>终极 Transformer 深度探索器</title>
    <!-- 引入 MathJax 用于渲染 LaTeX 公式 -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

<!--# END OF FILE: public/index.html-->


